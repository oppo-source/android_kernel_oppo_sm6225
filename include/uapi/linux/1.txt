commit a7ceb90b5b497d60aa242d2dded661c418bfb5d0
Author: Kang Yi <kangyi@oppo.com>
Date:   Wed Nov 18 15:02:05 2020 +0800

    [CONNECTIVITY.WiFi.Network][1/1]{WiFi移植: 6115R kernel代码移植}
    
    适用范围：{4250R}
    准入id：{无}
    分析：{无}
    方案：{无}
    风险及影响[快/稳/省/功能/安全隐私]：{无}
    测试建议：{无}
    跨组依赖(topic name)：{无}
    
    Change-Id: Ib42d4e444b3644d4d0cff912b126f8251be54b81

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
old mode 100644
new mode 100755
index 0652caa..d40602b
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -278,6 +278,41 @@ config RIONET_RX_SIZE
 	depends on RIONET
 	default "128"
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+#HuangJunyuan@CONNECTIVITY.WIFI.INTERNET, 2018/06/26, Add for limit speed function
+config IMQ
+	tristate "IMQ (intermediate queueing device) support"
+	depends on NETDEVICES && NETFILTER
+	default y
+
+	---help---
+	  The IMQ device(s) is used as placeholder for QoS queueing
+	  disciplines. Every packet entering/leaving the IP stack can be
+	  directed through the IMQ device where it's enqueued/dequeued to the
+	  attached qdisc. This allows you to treat network devices as classes
+	  and distribute bandwidth among them. Iptables is used to specify
+	  through which IMQ device, if any, packets travel.
+
+	  More information at: https://github.com/imq/linuximq
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imq.  If unsure, say N.
+
+config IMQ_NUM_DEVS
+	int "Number of IMQ devices"
+	range 2 16
+	depends on IMQ
+	default "2"
+	help
+	  This setting defines how many IMQ devices will be created.
+
+	  The default value is 16.
+
+	  More information can be found at: https://github.com/imq/linuximq
+
+	  If not sure leave the default settings alone.
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 config TUN
 	tristate "Universal TUN/TAP device driver support"
 	depends on INET
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
old mode 100644
new mode 100755
index 0d3ba05..44ec670
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -13,6 +13,10 @@ obj-$(CONFIG_DUMMY) += dummy.o
 obj-$(CONFIG_EQUALIZER) += eql.o
 obj-$(CONFIG_IFB) += ifb.o
 obj-$(CONFIG_MACSEC) += macsec.o
+ifneq ($(OPLUS_FEATURE_WIFI_LIMMITBGSPEED),)
+#HuangJunyuan@CONNECTIVITY.WIFI.INTERNET, 2018/06/26, Add for limit speed function
+obj-$(CONFIG_IMQ) += imq.o
+endif # OPLUS_FEATURE_WIFI_LIMMITBGSPEED
 obj-$(CONFIG_MACVLAN) += macvlan.o
 obj-$(CONFIG_MACVTAP) += macvtap.o
 obj-$(CONFIG_MII) += mii.o
diff --git a/drivers/net/imq.c b/drivers/net/imq.c
new file mode 100755
index 0000000..0f6ce27
--- /dev/null
+++ b/drivers/net/imq.c
@@ -0,0 +1,962 @@
+/*
+ *             Pseudo-driver for the intermediate queue device.
+ *
+ *             This program is free software; you can redistribute it and/or
+ *             modify it under the terms of the GNU General Public License
+ *             as published by the Free Software Foundation; either version
+ *             2 of the License, or (at your option) any later version.
+ *
+ * Authors:    Patrick McHardy, <kaber@trash.net>
+ *
+ *            The first version was written by Martin Devera, <devik@cdi.cz>
+ *
+ *			   See Credits.txt
+ */
+
+/************************************************************************************
+** File: - drivers/net/imq.c
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for limit speed function
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangJunyuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangJunyuan@CONNECTIVITY.WIFI  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/list.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#include <linux/netfilter_ipv6.h>
+#endif
+#include <linux/imq.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+#include <net/sock.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/if_vlan.h>
+#include <linux/if_pppox.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+
+static int imq_nf_queue(struct nf_queue_entry *entry, unsigned queue_num);
+
+static nf_hookfn imq_nf_hook;
+
+static struct nf_hook_ops imq_ops[] = {
+	{
+	/* imq_ingress_ipv4 */
+		.hook		= imq_nf_hook,
+		.pf		    = PF_INET,
+		.hooknum	= NF_INET_LOCAL_IN,
+		.priority	= NF_IP_PRI_FILTER + 1,
+
+	},
+
+	{
+	/* imq_egress_ipv4 */
+		.hook		= imq_nf_hook,
+		.pf		= PF_INET,
+		.hooknum	= NF_INET_POST_ROUTING,
+		.priority	= NF_IP_PRI_LAST,
+	},
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	{
+	/* imq_ingress_ipv6 */
+		.hook		= imq_nf_hook,
+		.pf		    = PF_INET6,
+		.hooknum	= NF_INET_LOCAL_IN,
+		.priority	= NF_IP_PRI_FILTER + 1,
+
+	},
+
+	{
+	/* imq_egress_ipv6 */
+		.hook		= imq_nf_hook,
+		.pf		= PF_INET6,
+		.hooknum	= NF_INET_POST_ROUTING,
+		.priority	= NF_IP6_PRI_LAST,
+	},
+#endif
+};
+
+#if defined(CONFIG_IMQ_NUM_DEVS)
+static int numdevs = CONFIG_IMQ_NUM_DEVS;
+#else
+static int numdevs = IMQ_MAX_DEVS;
+#endif
+
+static struct net_device *imq_devs_cache[IMQ_MAX_DEVS];
+
+#define IMQ_MAX_QUEUES 32
+static int numqueues = 1;
+static u32 imq_hashrnd;
+static int imq_dev_accurate_stats = 1;
+
+static inline __be16 pppoe_proto(const struct sk_buff *skb)
+{
+	return *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +
+			sizeof(struct pppoe_hdr)));
+}
+
+static u16 imq_hash(struct net_device *dev, struct sk_buff *skb)
+{
+	unsigned int pull_len;
+	u16 protocol = skb->protocol;
+	u32 addr1, addr2;
+	u32 hash = 0;
+	int ihl = 0;
+	union {
+		u16 in16[2];
+		u32 in32;
+	} ports;
+	u8 ip_proto;
+
+	pull_len = 0;
+
+recheck:
+	switch (protocol) {
+	case htons(ETH_P_8021Q): {
+		if (unlikely(skb_pull(skb, VLAN_HLEN) == NULL))
+			goto other;
+
+		pull_len += VLAN_HLEN;
+		skb->network_header += VLAN_HLEN;
+
+		protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
+		goto recheck;
+	}
+
+	case htons(ETH_P_PPP_SES): {
+		if (unlikely(skb_pull(skb, PPPOE_SES_HLEN) == NULL))
+			goto other;
+
+		pull_len += PPPOE_SES_HLEN;
+		skb->network_header += PPPOE_SES_HLEN;
+
+		protocol = pppoe_proto(skb);
+		goto recheck;
+	}
+
+	case htons(ETH_P_IP): {
+		const struct iphdr *iph = ip_hdr(skb);
+
+		if (unlikely(!pskb_may_pull(skb, sizeof(struct iphdr))))
+			goto other;
+
+		addr1 = iph->daddr;
+		addr2 = iph->saddr;
+
+		ip_proto = !(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET)) ?
+				 iph->protocol : 0;
+		ihl = ip_hdrlen(skb);
+
+		break;
+	}
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	case htons(ETH_P_IPV6): {
+		const struct ipv6hdr *iph = ipv6_hdr(skb);
+		__be16 fo = 0;
+
+		if (unlikely(!pskb_may_pull(skb, sizeof(struct ipv6hdr))))
+			goto other;
+
+		ip_proto = iph->nexthdr;
+		addr1 = iph->daddr.s6_addr32[3];
+		addr2 = iph->saddr.s6_addr32[3];
+		ihl = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &ip_proto,
+				       &fo);
+		if (unlikely(ihl < 0))
+			goto other;
+
+		break;
+	}
+#endif
+	default:
+other:
+		if (pull_len != 0) {
+			skb_push(skb, pull_len);
+			skb->network_header -= pull_len;
+		}
+
+		return (u16)(ntohs(protocol) % dev->real_num_tx_queues);
+	}
+
+	if (addr1 > addr2)
+		swap(addr1, addr2);
+
+	switch (ip_proto) {
+	case IPPROTO_TCP:
+	case IPPROTO_UDP:
+	case IPPROTO_DCCP:
+	case IPPROTO_ESP:
+	case IPPROTO_AH:
+	case IPPROTO_SCTP:
+	case IPPROTO_UDPLITE: {
+		if (likely(skb_copy_bits(skb, ihl, &ports.in32, 4) >= 0)) {
+			if (ports.in16[0] > ports.in16[1])
+				swap(ports.in16[0], ports.in16[1]);
+			break;
+		}
+		/* fall-through */
+	}
+	default:
+		ports.in32 = 0;
+		break;
+	}
+
+	if (pull_len != 0) {
+		skb_push(skb, pull_len);
+		skb->network_header -= pull_len;
+	}
+
+	hash = jhash_3words(addr1, addr2, ports.in32, imq_hashrnd ^ ip_proto);
+
+	return (u16)(((u64)hash * dev->real_num_tx_queues) >> 32);
+}
+
+static inline bool sk_tx_queue_recorded(struct sock *sk)
+{
+	return (sk_tx_queue_get(sk) >= 0);
+}
+
+static struct netdev_queue *imq_select_queue(struct net_device *dev,
+						struct sk_buff *skb)
+{
+	u16 queue_index = 0;
+	u32 hash;
+
+	if (likely(dev->real_num_tx_queues == 1))
+		goto out;
+
+	/* IMQ can be receiving ingress or engress packets. */
+
+	/* Check first for if rx_queue is set */
+	if (skb_rx_queue_recorded(skb)) {
+		queue_index = skb_get_rx_queue(skb);
+		goto out;
+	}
+
+	/* Check if socket has tx_queue set */
+	if (sk_tx_queue_recorded(skb->sk)) {
+		queue_index = sk_tx_queue_get(skb->sk);
+		goto out;
+	}
+
+	/* Try use socket hash */
+	if (skb->sk && skb->sk->sk_hash) {
+		hash = skb->sk->sk_hash;
+		queue_index =
+			(u16)(((u64)hash * dev->real_num_tx_queues) >> 32);
+		goto out;
+	}
+
+	/* Generate hash from packet data */
+	queue_index = imq_hash(dev, skb);
+
+out:
+	if (unlikely(queue_index >= dev->real_num_tx_queues))
+		queue_index = (u16)((u32)queue_index % dev->real_num_tx_queues);
+
+	skb_set_queue_mapping(skb, queue_index);
+	return netdev_get_tx_queue(dev, queue_index);
+}
+
+static struct net_device_stats *imq_get_stats(struct net_device *dev)
+{
+	return &dev->stats;
+}
+
+/* called for packets kfree'd in qdiscs at places other than enqueue */
+static void imq_skb_destructor(struct sk_buff *skb)
+{
+	struct nf_queue_entry *entry = skb->nf_queue_entry;
+
+	skb->nf_queue_entry = NULL;
+
+	if (entry) {
+		nf_queue_entry_release_refs(entry);
+		kfree(entry);
+	}
+
+	skb_restore_cb(skb); /* kfree backup */
+}
+
+static void imq_done_check_queue_mapping(struct sk_buff *skb,
+					 struct net_device *dev)
+{
+	unsigned int queue_index;
+
+	/* Don't let queue_mapping be left too large after exiting IMQ */
+	if (likely(skb->dev != dev && skb->dev != NULL)) {
+		queue_index = skb_get_queue_mapping(skb);
+		if (unlikely(queue_index >= skb->dev->real_num_tx_queues)) {
+			queue_index = (u16)((u32)queue_index %
+						skb->dev->real_num_tx_queues);
+			skb_set_queue_mapping(skb, queue_index);
+		}
+	} else {
+		/* skb->dev was IMQ device itself or NULL, be on safe side and
+		 * just clear queue mapping.
+		 */
+		skb_set_queue_mapping(skb, 0);
+	}
+}
+
+static netdev_tx_t imq_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct nf_queue_entry *entry = skb->nf_queue_entry;
+
+	rcu_read_lock();
+
+	skb->nf_queue_entry = NULL;
+	netif_trans_update(dev);
+
+	dev->stats.tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+
+	if (unlikely(entry == NULL)) {
+		/* We don't know what is going on here.. packet is queued for
+		 * imq device, but (probably) not by us.
+		 *
+		 * If this packet was not send here by imq_nf_queue(), then
+		 * skb_save_cb() was not used and skb_free() should not show:
+		 *   WARNING: IMQ: kfree_skb: skb->cb_next:..
+		 * and/or
+		 *   WARNING: IMQ: kfree_skb: skb->nf_queue_entry...
+		 *
+		 * However if this message is shown, then IMQ is somehow broken
+		 * and you should report this to linuximq.net.
+		 */
+
+		/* imq_dev_xmit is black hole that eats all packets, report that
+		 * we eat this packet happily and increase dropped counters.
+		 */
+
+		dev->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+
+		rcu_read_unlock();
+		return NETDEV_TX_OK;
+	}
+
+	skb_restore_cb(skb); /* restore skb->cb */
+
+	skb->imq_flags = 0;
+	skb->destructor = NULL;
+
+	imq_done_check_queue_mapping(skb, dev);
+
+	nf_reinject(entry, NF_ACCEPT);
+
+	rcu_read_unlock();
+	return NETDEV_TX_OK;
+}
+
+static struct net_device *get_imq_device_by_index(int index)
+{
+	struct net_device *dev = NULL;
+	struct net *net;
+	char buf[8];
+
+	/* get device by name and cache result */
+	snprintf(buf, sizeof(buf), "imq%d", index);
+
+	/* Search device from all namespaces. */
+	for_each_net(net) {
+		dev = dev_get_by_name(net, buf);
+		if (dev)
+			break;
+	}
+
+	if (WARN_ON_ONCE(dev == NULL)) {
+		/* IMQ device not found. Exotic config? */
+		return ERR_PTR(-ENODEV);
+	}
+
+	imq_devs_cache[index] = dev;
+	dev_put(dev);
+
+	return dev;
+}
+
+static struct nf_queue_entry *nf_queue_entry_dup(struct nf_queue_entry *e)
+{
+	struct nf_queue_entry *entry = kmemdup(e, e->size, GFP_ATOMIC);
+	if (entry) {
+		nf_queue_entry_get_refs(entry);
+		return entry;
+	}
+	return NULL;
+}
+
+#ifdef CONFIG_BRIDGE_NETFILTER
+/* When called from bridge netfilter, skb->data must point to MAC header
+ * before calling skb_gso_segment(). Else, original MAC header is lost
+ * and segmented skbs will be sent to wrong destination.
+ */
+static void nf_bridge_adjust_skb_data(struct sk_buff *skb)
+{
+	if (skb->nf_bridge)
+		__skb_push(skb, skb->network_header - skb->mac_header);
+}
+
+static void nf_bridge_adjust_segmented_data(struct sk_buff *skb)
+{
+	if (skb->nf_bridge)
+		__skb_pull(skb, skb->network_header - skb->mac_header);
+}
+#else
+#define nf_bridge_adjust_skb_data(s) do {} while (0)
+#define nf_bridge_adjust_segmented_data(s) do {} while (0)
+#endif
+
+static void free_entry(struct nf_queue_entry *entry)
+{
+	nf_queue_entry_release_refs(entry);
+	kfree(entry);
+}
+
+static int __imq_nf_queue(struct nf_queue_entry *entry, struct net_device *dev);
+
+static int __imq_nf_queue_gso(struct nf_queue_entry *entry,
+			      struct net_device *dev, struct sk_buff *skb)
+{
+	int ret = -ENOMEM;
+	struct nf_queue_entry *entry_seg;
+
+	nf_bridge_adjust_segmented_data(skb);
+
+	if (skb->next == NULL) { /* last packet, no need to copy entry */
+		struct sk_buff *gso_skb = entry->skb;
+		entry->skb = skb;
+		ret = __imq_nf_queue(entry, dev);
+		if (ret)
+			entry->skb = gso_skb;
+		return ret;
+	}
+
+	skb->next = NULL;
+
+	entry_seg = nf_queue_entry_dup(entry);
+	if (entry_seg) {
+		entry_seg->skb = skb;
+		ret = __imq_nf_queue(entry_seg, dev);
+		if (ret)
+			free_entry(entry_seg);
+	}
+	return ret;
+}
+
+static int imq_nf_queue(struct nf_queue_entry *entry, unsigned queue_num)
+{
+	struct sk_buff *skb, *segs;
+	struct net_device *dev;
+	unsigned int queued;
+	int index, retval, err;
+
+	index = entry->skb->imq_flags & IMQ_F_IFMASK;
+	if (unlikely(index > numdevs - 1)) {
+		if (net_ratelimit())
+			pr_warn("IMQ: invalid device specified, highest is %u\n",
+				numdevs - 1);
+		retval = -EINVAL;
+		goto out_no_dev;
+	}
+
+	/* check for imq device by index from cache */
+	dev = imq_devs_cache[index];
+	if (unlikely(!dev)) {
+		dev = get_imq_device_by_index(index);
+		if (IS_ERR(dev)) {
+			retval = PTR_ERR(dev);
+			goto out_no_dev;
+		}
+	}
+
+	if (unlikely(!(dev->flags & IFF_UP))) {
+		entry->skb->imq_flags = 0;
+		retval = -ECANCELED;
+		goto out_no_dev;
+	}
+
+	/* Since 3.10.x, GSO handling moved here as result of upstream commit
+	 * a5fedd43d5f6c94c71053a66e4c3d2e35f1731a2 (netfilter: move
+	 * skb_gso_segment into nfnetlink_queue module).
+	 *
+	 * Following code replicates the gso handling from
+	 * 'net/netfilter/nfnetlink_queue_core.c':nfqnl_enqueue_packet().
+	 */
+
+	skb = entry->skb;
+
+	switch (entry->state.pf) {
+	case NFPROTO_IPV4:
+		skb->protocol = htons(ETH_P_IP);
+		break;
+	case NFPROTO_IPV6:
+		skb->protocol = htons(ETH_P_IPV6);
+		break;
+	}
+
+	if (!skb_is_gso(entry->skb))
+		return __imq_nf_queue(entry, dev);
+
+	nf_bridge_adjust_skb_data(skb);
+	segs = skb_gso_segment(skb, 0);
+	/* Does not use PTR_ERR to limit the number of error codes that can be
+	 * returned by nf_queue.  For instance, callers rely on -ECANCELED to
+	 * mean 'ignore this hook'.
+	 */
+	err = -ENOBUFS;
+	if (IS_ERR(segs))
+		goto out_err;
+	queued = 0;
+	err = 0;
+	do {
+		struct sk_buff *nskb = segs->next;
+		if (nskb && nskb->next)
+			nskb->cb_next = NULL;
+		if (err == 0)
+			err = __imq_nf_queue_gso(entry, dev, segs);
+		if (err == 0)
+			queued++;
+		else
+			kfree_skb(segs);
+		segs = nskb;
+	} while (segs);
+
+	if (queued) {
+		if (err) /* some segments are already queued */
+			free_entry(entry);
+		kfree_skb(skb);
+		return 0;
+	}
+
+out_err:
+	nf_bridge_adjust_segmented_data(skb);
+	retval = err;
+out_no_dev:
+	return retval;
+}
+
+static int __imq_nf_queue(struct nf_queue_entry *entry, struct net_device *dev)
+{
+	struct sk_buff *skb_orig, *skb, *skb_shared, *skb_popd;
+	struct Qdisc *q;
+	struct sk_buff *to_free = NULL;
+	struct netdev_queue *txq;
+	spinlock_t *root_lock;
+	int users;
+	int retval = -EINVAL;
+	unsigned int orig_queue_index;
+	bool again = false;
+
+	skb = entry->skb;
+	skb_orig = NULL;
+
+	/* skb has owner? => make clone */
+	if (unlikely(skb->destructor)) {
+		skb_orig = skb;
+		skb = skb_clone(skb, GFP_ATOMIC);
+		if (unlikely(!skb)) {
+			retval = -ENOMEM;
+			goto out;
+		}
+		skb->cb_next = NULL;
+		entry->skb = skb;
+	}
+
+	dev->stats.rx_bytes += skb->len;
+	dev->stats.rx_packets++;
+
+	if (!skb->dev) {
+		/* skb->dev == NULL causes problems, try the find cause. */
+		if (net_ratelimit()) {
+			dev_warn(&dev->dev,
+				 "received packet with skb->dev == NULL\n");
+			dump_stack();
+		}
+
+		skb->dev = dev;
+	}
+
+	/* Disables softirqs for lock below */
+	rcu_read_lock_bh();
+
+	/* Multi-queue selection */
+	orig_queue_index = skb_get_queue_mapping(skb);
+	txq = imq_select_queue(dev, skb);
+
+	q = rcu_dereference(txq->qdisc);
+	if (unlikely(!q->enqueue))
+		goto packet_not_enqueue_to_imq_dev;
+
+	skb->nf_queue_entry = entry;
+	root_lock = qdisc_lock(q);
+	spin_lock(root_lock);
+
+	users = refcount_read(&skb->users);
+
+	skb_shared = skb_get(skb); /* increase reference count by one */
+
+	/* backup skb->cb, as qdisc layer will overwrite it */
+	skb_save_cb(skb_shared);
+	qdisc_enqueue_root(skb_shared, q, &to_free); /* might kfree_skb */
+	if (likely(refcount_read(&skb_shared->users) == users + 1)) {
+		bool validate;
+
+		kfree_skb(skb_shared); /* decrease reference count by one */
+
+		skb->destructor = &imq_skb_destructor;
+
+		skb_popd = qdisc_dequeue_skb(q, &validate);
+
+		/* cloned? */
+		if (unlikely(skb_orig))
+			kfree_skb(skb_orig); /* free original */
+
+		spin_unlock(root_lock);
+
+		if (likely(skb_popd)) {
+			/* Note that we validate skb (GSO, checksum, ...) outside of locks */
+			if (validate)
+				skb_popd = validate_xmit_skb_list(skb_popd, dev, &again);
+
+			if (skb_popd) {
+				int dummy_ret;
+				int cpu = smp_processor_id(); /* ok because BHs are off */
+
+				txq = skb_get_tx_queue(dev, skb_popd);
+				/*
+				IMQ device will not be frozen or stoped, and it always be successful.
+				So we need not check its status and return value to accelerate.
+				*/
+				if (imq_dev_accurate_stats && txq->xmit_lock_owner != cpu) {
+					HARD_TX_LOCK(dev, txq, cpu);
+					if (!netif_xmit_frozen_or_stopped(txq)) {
+						dev_hard_start_xmit(skb_popd, dev, txq, &dummy_ret);
+					} else {
+						kfree_skb_list(skb_popd);
+					}
+					HARD_TX_UNLOCK(dev, txq);
+				} else {
+					if (!netif_xmit_frozen_or_stopped(txq)) {
+						dev_hard_start_xmit(skb_popd, dev, txq, &dummy_ret);
+					} else {
+						kfree_skb_list(skb_popd);
+					}
+				}
+			}
+		} else {
+			/* No ready skb, then schedule it */
+			__netif_schedule(q);
+		}
+
+		rcu_read_unlock_bh();
+		retval = 0;
+		goto out;
+	} else {
+		skb_restore_cb(skb_shared); /* restore skb->cb */
+		skb->nf_queue_entry = NULL;
+		/*
+		 * qdisc dropped packet and decreased skb reference count of
+		 * skb, so we don't really want to and try refree as that would
+		 * actually destroy the skb.
+		 */
+		spin_unlock(root_lock);
+		goto packet_not_enqueue_to_imq_dev;
+	}
+
+packet_not_enqueue_to_imq_dev:
+	skb_set_queue_mapping(skb, orig_queue_index);
+	rcu_read_unlock_bh();
+
+	/* cloned? restore original */
+	if (unlikely(skb_orig)) {
+		kfree_skb(skb);
+		entry->skb = skb_orig;
+	}
+	retval = -1;
+out:
+	if (unlikely(to_free)) {
+		kfree_skb_list(to_free);
+	}
+	return retval;
+}
+static unsigned int imq_nf_hook(void *priv,
+				struct sk_buff *skb,
+				const struct nf_hook_state *state)
+{
+	return (skb->imq_flags & IMQ_F_ENQUEUE) ? NF_IMQ_QUEUE : NF_ACCEPT;
+}
+
+static int imq_close(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static int imq_open(struct net_device *dev)
+{
+	netif_start_queue(dev);
+	return 0;
+}
+
+static struct device_type imq_device_type = {
+	.name = "imq",
+};
+
+static const struct net_device_ops imq_netdev_ops = {
+	.ndo_open		= imq_open,
+	.ndo_stop		= imq_close,
+	.ndo_start_xmit		= imq_dev_xmit,
+	.ndo_get_stats		= imq_get_stats,
+};
+
+static void imq_setup(struct net_device *dev)
+{
+	dev->netdev_ops		= &imq_netdev_ops;
+	dev->type		= ARPHRD_VOID;
+	dev->mtu		= 16000; /* too small? */
+	dev->tx_queue_len	= 1000; /* too big? */
+	dev->flags		= IFF_NOARP;
+	dev->features		= NETIF_F_SG | NETIF_F_FRAGLIST |
+				  NETIF_F_GSO | NETIF_F_HW_CSUM |
+				  NETIF_F_HIGHDMA;
+	dev->priv_flags		&= ~(IFF_XMIT_DST_RELEASE |
+				     IFF_TX_SKB_SHARING);
+}
+
+static int imq_validate(struct nlattr *tb[], struct nlattr *data[],
+			struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+
+	if (tb[IFLA_ADDRESS]) {
+		if (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN) {
+			ret = -EINVAL;
+			goto end;
+		}
+		if (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS]))) {
+			ret = -EADDRNOTAVAIL;
+			goto end;
+		}
+	}
+	return 0;
+end:
+	pr_warn("IMQ: imq_validate failed (%d)\n", ret);
+	return ret;
+}
+
+static struct rtnl_link_ops imq_link_ops __read_mostly = {
+	.kind		= "imq",
+	.priv_size	= 0,
+	.setup		= imq_setup,
+	.validate	= imq_validate,
+};
+
+static const struct nf_queue_handler imq_nfqh = {
+	.outfn = imq_nf_queue,
+};
+
+static int __net_init imq_nf_register(struct net *net)
+{
+	return nf_register_net_hooks(net, imq_ops,
+				    ARRAY_SIZE(imq_ops));
+};
+
+static void __net_exit imq_nf_unregister(struct net *net)
+{
+	nf_unregister_net_hooks(net, imq_ops,
+			    ARRAY_SIZE(imq_ops));
+};
+
+static struct pernet_operations imq_net_ops = {
+	.init		= imq_nf_register,
+	.exit		= imq_nf_unregister,
+};
+
+static int __net_init imq_init_hooks(void)
+{
+	int ret;
+	nf_register_queue_imq_handler(&imq_nfqh);
+
+	ret = register_pernet_subsys(&imq_net_ops);
+	if (ret < 0)
+		nf_unregister_queue_imq_handler();
+
+	return ret;
+}
+
+#ifdef CONFIG_LOCKDEP
+static struct lock_class_key imq_netdev_addr_lock_key;
+
+static void __init imq_dev_set_lockdep_one(struct net_device *dev,
+			    struct netdev_queue *txq, void *arg)
+{
+/*
+ * the IMQ transmit locks can be taken recursively,
+ * for example with one IMQ rule for input- and one for
+ * output network devices in iptables!
+ * until we find a better solution ignore them.
+ */
+	lockdep_set_novalidate_class(&txq->_xmit_lock);
+}
+
+static void imq_dev_set_lockdep_class(struct net_device *dev)
+	{
+		lockdep_set_class_and_name(&dev->addr_list_lock,
+								   &imq_netdev_addr_lock_key, "_xmit_addr_IMQ");
+		netdev_for_each_tx_queue(dev, imq_dev_set_lockdep_one, NULL);
+}
+#else
+static inline void imq_dev_set_lockdep_class(struct net_device *dev)
+{
+}
+#endif
+
+static int __init imq_init_one(int index)
+{
+	struct net_device *dev;
+	int ret;
+
+	dev = alloc_netdev_mq(0, "imq%d", NET_NAME_UNKNOWN, imq_setup, numqueues);
+	if (!dev)
+		return -ENOMEM;
+
+	ret = dev_alloc_name(dev, dev->name);
+	if (ret < 0)
+		goto fail;
+
+	dev->rtnl_link_ops = &imq_link_ops;
+	SET_NETDEV_DEVTYPE(dev, &imq_device_type);
+	ret = register_netdevice(dev);
+	if (ret < 0)
+		goto fail;
+
+	imq_dev_set_lockdep_class(dev);
+
+	return 0;
+fail:
+	free_netdev(dev);
+	return ret;
+}
+
+static int __init imq_init_devs(void)
+{
+	int err, i;
+
+	if (numdevs < 1 || numdevs > IMQ_MAX_DEVS) {
+		pr_err("IMQ: numdevs has to be betweed 1 and %u\n",
+		       IMQ_MAX_DEVS);
+		return -EINVAL;
+	}
+
+	if (numqueues < 1 || numqueues > IMQ_MAX_QUEUES) {
+		pr_err("IMQ: numqueues has to be betweed 1 and %u\n",
+		       IMQ_MAX_QUEUES);
+		return -EINVAL;
+	}
+
+	get_random_bytes(&imq_hashrnd, sizeof(imq_hashrnd));
+
+	rtnl_lock();
+	err = __rtnl_link_register(&imq_link_ops);
+
+	for (i = 0; i < numdevs && !err; i++)
+		err = imq_init_one(i);
+
+	if (err) {
+		__rtnl_link_unregister(&imq_link_ops);
+		memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+	}
+	rtnl_unlock();
+
+	return err;
+}
+
+static int __init imq_init_module(void)
+{
+	int err;
+
+#if defined(CONFIG_IMQ_NUM_DEVS)
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS > 16);
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS < 2);
+	BUILD_BUG_ON(CONFIG_IMQ_NUM_DEVS - 1 > IMQ_F_IFMASK);
+#endif
+
+	err = imq_init_devs();
+	if (err) {
+		pr_err("IMQ: Error trying imq_init_devs(net)\n");
+		return err;
+	}
+
+	err = imq_init_hooks();
+	if (err) {
+		pr_err(KERN_ERR "IMQ: Error trying imq_init_hooks()\n");
+		rtnl_link_unregister(&imq_link_ops);
+		memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+		return err;
+	}
+
+	pr_info("IMQ driver loaded successfully. (numdevs = %d, numqueues = %d, imq_dev_accurate_stats = %d)\n",
+		numdevs, numqueues, imq_dev_accurate_stats);
+
+	return 0;
+}
+
+static void __exit imq_unhook(void)
+{
+	unregister_pernet_subsys(&imq_net_ops);
+	nf_unregister_queue_imq_handler();
+}
+
+static void __exit imq_cleanup_devs(void)
+{
+	rtnl_link_unregister(&imq_link_ops);
+	memset(imq_devs_cache, 0, sizeof(imq_devs_cache));
+}
+
+static void __exit imq_exit_module(void)
+{
+	imq_unhook();
+	imq_cleanup_devs();
+	pr_info("IMQ driver unloaded successfully.\n");
+}
+
+module_init(imq_init_module);
+module_exit(imq_exit_module);
+
+module_param(numdevs, int, 0);
+module_param(numqueues, int, 0);
+module_param(imq_dev_accurate_stats, int, 0);
+MODULE_PARM_DESC(numdevs, "number of IMQ devices (how many imq* devices will be created)");
+MODULE_PARM_DESC(numqueues, "number of queues per IMQ device");
+MODULE_PARM_DESC(imq_dev_accurate_stats, "Notify if need the accurate imq device stats");
+
+MODULE_AUTHOR("https://github.com/imq/linuximq");
+MODULE_DESCRIPTION("Pseudo-driver for the intermediate queue device. See https://github.com/imq/linuximq/wiki for more information.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_RTNL_LINK("imq");
+
diff --git a/include/linux/imq.h b/include/linux/imq.h
new file mode 100755
index 0000000..ca017ff
--- /dev/null
+++ b/include/linux/imq.h
@@ -0,0 +1,34 @@
+
+#ifndef _IMQ_H
+#define _IMQ_H
+
+/************************************************************************************
+** File: - include/linux/imq.h
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for limit speed function
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangJunyuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangJunyuan@CONNECTIVITY.WIFI  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+
+/* IFMASK (16 device indexes, 0 to 15) and flag(s) fit in 5 bits */
+#define IMQ_F_BITS	5
+
+#define IMQ_F_IFMASK	0x0f
+#define IMQ_F_ENQUEUE	0x10
+
+#define IMQ_MAX_DEVS	(IMQ_F_IFMASK + 1)
+
+#endif /* _IMQ_H */
+
diff --git a/include/linux/netfilter/xt_IMQ.h b/include/linux/netfilter/xt_IMQ.h
new file mode 100755
index 0000000..9e651b9
--- /dev/null
+++ b/include/linux/netfilter/xt_IMQ.h
@@ -0,0 +1,28 @@
+#ifndef _XT_IMQ_H
+#define _XT_IMQ_H
+
+/************************************************************************************
+** File: - include/linux/netfilter/xt_IMQ.h
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for limit speed function
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangJunyuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangJunyuan@CONNECTIVITY.WIFI  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+
+struct xt_imq_info {
+	unsigned int todev;     /* target imq device */
+};
+
+#endif /* _XT_IMQ_H */
diff --git a/include/linux/netfilter_ipv4/ipt_IMQ.h b/include/linux/netfilter_ipv4/ipt_IMQ.h
new file mode 100755
index 0000000..7aa2933
--- /dev/null
+++ b/include/linux/netfilter_ipv4/ipt_IMQ.h
@@ -0,0 +1,30 @@
+#ifndef _IPT_IMQ_H
+#define _IPT_IMQ_H
+/************************************************************************************
+** File: - include/linux/netfilter_ipv4/ipt_IMQ.h
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for limit speed function
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangJunyuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangJunyuan@CONNECTIVITY.WIFI  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+
+
+/* Backwards compatibility for old userspace */
+#include <linux/netfilter/xt_IMQ.h>
+
+#define ipt_imq_info xt_imq_info
+
+#endif /* _IPT_IMQ_H */
+
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
old mode 100644
new mode 100755
index 25407c2..f9398c7
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -40,6 +40,11 @@
 #include <linux/in6.h>
 #include <linux/if_packet.h>
 #include <net/flow.h>
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+#include <linux/imq.h>
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 
 /* The interface for checksum offload between the stack and networking drivers
  * is as follows...
@@ -698,6 +703,10 @@ struct sk_buff {
 	 * first. This is owned by whoever has the skb queued ATM.
 	 */
 	char			cb[48] __aligned(8);
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	void			*cb_next;
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 
 	union {
 		struct {
@@ -713,6 +722,11 @@ struct sk_buff {
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	unsigned long		 _nfct;
 #endif
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	struct nf_queue_entry   *nf_queue_entry;
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	struct nf_bridge_info	*nf_bridge;
 #endif
@@ -790,6 +804,12 @@ struct sk_buff {
 	__u8			offload_fwd_mark:1;
 	__u8			offload_mr_fwd_mark:1;
 #endif
+
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	__u8			imq_flags:IMQ_F_BITS;
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 #ifdef CONFIG_NET_CLS_ACT
 	__u8			tc_skip_classify:1;
 	__u8			tc_at_ingress:1;
@@ -979,6 +999,13 @@ void skb_tx_error(struct sk_buff *skb);
 void consume_skb(struct sk_buff *skb);
 void __consume_stateless_skb(struct sk_buff *skb);
 void  __kfree_skb(struct sk_buff *skb);
+
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+int skb_save_cb(struct sk_buff *skb);
+int skb_restore_cb(struct sk_buff *skb);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 extern struct kmem_cache *skbuff_head_cache;
 
 void kfree_skb_partial(struct sk_buff *skb, bool head_stolen);
@@ -3922,6 +3949,13 @@ static inline void __nf_copy(struct sk_buff *dst, const struct sk_buff *src,
 	dst->_nfct = src->_nfct;
 	nf_conntrack_get(skb_nfct(src));
 #endif
+
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	dst->imq_flags = src->imq_flags;
+	dst->nf_queue_entry = src->nf_queue_entry;
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	dst->nf_bridge  = src->nf_bridge;
 	nf_bridge_get(src->nf_bridge);
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
old mode 100644
new mode 100755
index f45141b..40e6855
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -27,6 +27,7 @@
 
 #include <net/netfilter/nf_conntrack_tuple.h>
 
+#define OPLUS_FEATURE_WIFI_LUCKYMONEY
 /* per conntrack: protocol private data */
 union nf_conntrack_proto {
 	/* insert conntrack proto private data here */
@@ -86,6 +87,26 @@ struct nf_conn {
 #endif
 	/* all members below initialized via memset */
 	u8 __nfct_init_offset[0];
+        //#ifdef OPLUS_FEATURE_WIFI_SLA
+
+	u32 oplus_game_skb_len;
+	u32 oplus_game_detect_status;
+	u32 oplus_game_time_interval;
+	u32 oplus_game_up_count;
+	u32 oplus_game_down_count;
+	u32 oplus_game_lost_count;
+	u32 oplus_game_same_count;
+	u32 oplus_http_flag;
+	u32 oplus_skb_count;
+	int oplus_app_type;
+	s64 oplus_game_timestamp;
+	s64 oplus_game_last_timestamp;
+	//#endif /* OPLUS_FEATURE_WIFI_SLA */
+
+	#ifdef OPLUS_FEATURE_WIFI_LUCKYMONEY
+
+	u32 oplus_app_uid;
+	#endif /* OPLUS_FEATURE_WIFI_LUCKYMONEY */
 
 	/* If we were expected by an expectation, this will be it */
 	struct nf_conn *master;
diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h
old mode 100644
new mode 100755
index a50a69f..ce68cbf
--- a/include/net/netfilter/nf_queue.h
+++ b/include/net/netfilter/nf_queue.h
@@ -32,6 +32,12 @@ void nf_register_queue_handler(struct net *net, const struct nf_queue_handler *q
 void nf_unregister_queue_handler(struct net *net);
 void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict);
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+void nf_register_queue_imq_handler(const struct nf_queue_handler *qh);
+void nf_unregister_queue_imq_handler(void);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 void nf_queue_entry_get_refs(struct nf_queue_entry *entry);
 void nf_queue_entry_release_refs(struct nf_queue_entry *entry);
 
diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
old mode 100644
new mode 100755
index 366e2a6..bea7e6c
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -178,6 +178,11 @@ struct netns_ipv4 {
 	int sysctl_udp_wmem_min;
 	int sysctl_udp_rmem_min;
 
+	#ifdef OPLUS_BUG_STABILITY
+
+	int sysctl_tcp_random_timestamp;
+	#endif /* OPLUS_BUG_STABILITY */
+
 #ifdef CONFIG_NET_L3_MASTER_DEV
 	int sysctl_udp_l3mdev_accept;
 #endif
diff --git a/include/net/oplus/oplus_kernel2user.h b/include/net/oplus/oplus_kernel2user.h
new file mode 100755
index 0000000..dfb8b03
--- /dev/null
+++ b/include/net/oplus/oplus_kernel2user.h
@@ -0,0 +1,32 @@
+#ifndef _OPLUS_KERNEL2USER_H
+#define _OPLUS_KERNEL2USER_H
+
+#include <net/sock.h>
+
+/*NLMSG_MIN_TYPE is 0x10,so user to kernel we start at 0x20,kernel to user we start at 0x30*/
+enum{
+    OPLUS_FOREGROUND_ANDROID_UID		= 0x20,
+    OPLUS_MPTCP_UID					= 0x21,
+    OPLUS_SEND_TCP_RETRANSMIT		= 0x30,
+    OPLUS_SEND_NETWORK_SCORE			= 0x31,
+};
+
+#define MAX_PARA_LEN 100
+#define MAX_MPTCP_APP_LEN 100
+#define MAX_LINK_LEN 32
+
+struct general_oplus_info {
+    u32 para_type;
+    u32 para_one;
+    u32 para_two;
+    u32 para_three;
+    char para_array[MAX_PARA_LEN];
+};
+
+extern u32 oplus_foreground_uid;
+extern int oplus_kernel_send_to_user(int msg_type, char *payload, int payload_len);
+extern void oplus_handle_retransmit(const struct sock *sk, int type);
+extern uid_t get_uid_from_sock(const struct sock *sk);
+extern int get_link_index_from_sock(const struct sock *sk);
+
+#endif
diff --git a/include/net/pkt_sched.h b/include/net/pkt_sched.h
old mode 100644
new mode 100755
index 7dc769e..0f2c4b4
--- a/include/net/pkt_sched.h
+++ b/include/net/pkt_sched.h
@@ -114,6 +114,11 @@ bool sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,
 
 void __qdisc_run(struct Qdisc *q);
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+struct sk_buff *qdisc_dequeue_skb(struct Qdisc *q, bool *validate);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 static inline void qdisc_run(struct Qdisc *q)
 {
 	if (qdisc_run_begin(q)) {
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
old mode 100644
new mode 100755
index d737a6a..2c9c025
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -705,6 +705,16 @@ static inline int qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
 	return sch->enqueue(skb, sch, to_free);
 }
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+static inline int qdisc_enqueue_root(struct sk_buff *skb, struct Qdisc *sch,
+				      struct sk_buff **to_free)
+{
+    qdisc_skb_cb(skb)->pkt_len = skb->len;
+    return qdisc_enqueue(skb, sch, to_free) & NET_XMIT_MASK;
+}
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 static inline bool qdisc_is_percpu_stats(const struct Qdisc *q)
 {
 	return q->flags & TCQ_F_CPUSTATS;
diff --git a/include/net/sock.h b/include/net/sock.h
old mode 100644
new mode 100755
index 94ffacc..be07b40
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -187,6 +187,10 @@ struct sock_common {
 	struct proto		*skc_prot;
 	possible_net_t		skc_net;
 
+        //#ifdef OPLUS_FEATURE_WIFI_SLA
+
+	u32 skc_oplus_mark;
+	//#endif /* OPLUS_FEATURE_WIFI_SLA */
 #if IS_ENABLED(CONFIG_IPV6)
 	struct in6_addr		skc_v6_daddr;
 	struct in6_addr		skc_v6_rcv_saddr;
@@ -364,6 +368,10 @@ struct sock {
 #define sk_flags		__sk_common.skc_flags
 #define sk_rxhash		__sk_common.skc_rxhash
 
+//#ifdef OPLUS_FEATURE_WIFI_SLA
+
+#define oplus_sla_mark   __sk_common.skc_oplus_mark
+//#endif /* OPLUS_FEATURE_WIFI_SLA */
 	socket_lock_t		sk_lock;
 	atomic_t		sk_drops;
 	int			sk_rcvlowat;
@@ -1923,6 +1931,10 @@ static inline void sk_dst_confirm(struct sock *sk)
 
 static inline void sock_confirm_neigh(struct sk_buff *skb, struct neighbour *n)
 {
+	#ifndef VENDOR_EDIT
+
+	//Remove for [1357567],some AP doesn't send arp when it needs to send data to DUT
+	//We remove this code to send arp more frequently to notify our mac to AP
 	if (skb_get_dst_pending_confirm(skb)) {
 		struct sock *sk = skb->sk;
 		unsigned long now = jiffies;
@@ -1933,6 +1945,7 @@ static inline void sock_confirm_neigh(struct sk_buff *skb, struct neighbour *n)
 		if (sk && sk->sk_dst_pending_confirm)
 			sk->sk_dst_pending_confirm = 0;
 	}
+	#endif /* VENDOR_EDIT */
 }
 
 bool sk_mc_loop(struct sock *sk);
diff --git a/include/net/tcp.h b/include/net/tcp.h
old mode 100644
new mode 100755
index b6531f0..52f435f
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -262,6 +262,11 @@ extern int sysctl_tcp_use_userconfig;
 extern struct percpu_counter tcp_sockets_allocated;
 extern unsigned long tcp_memory_pressure;
 
+#ifdef OPLUS_BUG_STABILITY
+
+extern int sysctl_tcp_ts_control[2];
+#endif /* OPLUS_BUG_STABILITY */
+
 /* optimized version of sk_under_memory_pressure() for TCP sockets */
 static inline bool tcp_under_memory_pressure(const struct sock *sk)
 {
diff --git a/include/uapi/linux/netfilter.h b/include/uapi/linux/netfilter.h
old mode 100644
new mode 100755
index cca10e7..43f3dfa
--- a/include/uapi/linux/netfilter.h
+++ b/include/uapi/linux/netfilter.h
@@ -14,7 +14,14 @@
 #define NF_QUEUE 3
 #define NF_REPEAT 4
 #define NF_STOP 5	/* Deprecated, for userspace nf_queue compatibility. */
+
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+#define NF_IMQ_QUEUE 6
+#define NF_MAX_VERDICT NF_IMQ_QUEUE
+#else /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 #define NF_MAX_VERDICT NF_STOP
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 
 /* we overload the higher bits for encoding auxiliary data such as the queue
  * number or errno values. Not nice, but better than additional function
diff --git a/include/uapi/linux/netlink.h b/include/uapi/linux/netlink.h
old mode 100644
new mode 100755
index 5fa3fcc..1d0cc15
--- a/include/uapi/linux/netlink.h
+++ b/include/uapi/linux/netlink.h
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI__LINUX_NETLINK_H
 #define _UAPI__LINUX_NETLINK_H
+#define OPLUS_FEATURE_WIFI_LUCKYMONEY
 
 #include <linux/kernel.h>
 #include <linux/socket.h> /* for __kernel_sa_family_t */
@@ -32,7 +33,26 @@
 #define NETLINK_SOCKEV		23	/* Socket Administrative Events */
 #define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
 
-#define MAX_LINKS 32		
+#ifdef OPLUS_FEATURE_WIFI_LUCKYMONEY
+
+#define NETLINK_OPLUS_NF_HOOKS	32
+#endif /* OPLUS_FEATURE_WIFI_LUCKYMONEY */
+//#ifdef OPLUS_FEATURE_WIFI_SLA
+
+#define NETLINK_OPLUS_SLA  33      /*SLA NETLINK SOCK*/
+//#endif /* OPLUS_FEATURE_WIFI_SLA */
+
+
+//Add for apps network monitors
+#define NETLINK_OPLUS_APPS_MONITOR  35      /* Apps monitor NETLINK SOCK */
+//#endif /* VENDOR_EDIT */
+//#ifdef OPLUS_FEATURE_DHCP
+
+#define NETLINK_OPLUS_DHCP 38
+//#endif /* OPLUS_FEATURE_DHCP */
+//#define MAX_LINKS 40
+#define MAX_LINKS 42
+//#endif /* OPLUS_FEATURE_WIFI_CAPCENTER */
 
 struct sockaddr_nl {
 	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
diff --git a/net/Makefile b/net/Makefile
old mode 100644
new mode 100755
index bdaf539..057d4aa
--- a/net/Makefile
+++ b/net/Makefile
@@ -87,3 +87,17 @@ endif
 obj-$(CONFIG_QRTR)		+= qrtr/
 obj-$(CONFIG_NET_NCSI)		+= ncsi/
 obj-$(CONFIG_XDP_SOCKETS)	+= xdp/
+#ifdef OPLUS_FEATURE_WIFI_SLA
+#HuangJunyuan@CONNECTIVITY.WIFI.INTERNET.1197891, 2018/04/10,Add code for appo sla function
+obj-y                   	+= oplus_sla/
+#endif /* OPLUS_FEATURE_WIFI_SLA */
+OPLUS_FEATURE_WIFI_LUCKYMONEY=1
+ifneq ($(OPLUS_FEATURE_WIFI_LUCKYMONEY),)
+#HuangYuan@CONNECTIVITY.WIFI.INTERNET, 2018/06/18, Add for WeChat lucky money recognition
+obj-y				+= oplus_nf_hooks/
+endif #/* OPLUS_FEATURE_WIFI_LUCKYMONEY */
+OPLUS_FEATURE_DHCP=1
+ifneq ($(OPLUS_FEATURE_DHCP),)
+#LianGenglin@CONNECTIVITY.WIFI.INTERNET, 2020/05/09, Add for Dhcp conflict
+obj-y				+= oplus_dhcp/
+endif #/* OPLUS_FEATURE_DHCP */
diff --git a/net/core/dev.c b/net/core/dev.c
old mode 100644
new mode 100755
index 4d57311..14be349
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -142,6 +142,11 @@
 #include <linux/hrtimer.h>
 #include <linux/netfilter_ingress.h>
 #include <linux/crash_dump.h>
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+#include <linux/imq.h>
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 #include <linux/sctp.h>
 #include <net/udp_tunnel.h>
 #include <linux/net_namespace.h>
@@ -3252,7 +3257,13 @@ static int xmit_one(struct sk_buff *skb, struct net_device *dev,
 	unsigned int len;
 	int rc;
 
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	if ((!list_empty(&ptype_all) || !list_empty(&dev->ptype_all)) &&
+		!(skb->imq_flags & IMQ_F_ENQUEUE))
+	#else /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 		dev_queue_xmit_nit(skb, dev);
 
 	len = skb->len;
@@ -3290,6 +3301,11 @@ struct sk_buff *dev_hard_start_xmit(struct sk_buff *first, struct net_device *de
 	*ret = rc;
 	return skb;
 }
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+EXPORT_SYMBOL_GPL(dev_hard_start_xmit);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 
 static struct sk_buff *validate_xmit_vlan(struct sk_buff *skb,
 					  netdev_features_t features)
diff --git a/net/core/secure_seq.c b/net/core/secure_seq.c
old mode 100644
new mode 100755
index af6ad46..0f9104f
--- a/net/core/secure_seq.c
+++ b/net/core/secure_seq.c
@@ -119,6 +119,14 @@ u32 secure_tcp_ts_off(const struct net *net, __be32 saddr, __be32 daddr)
 	if (net->ipv4.sysctl_tcp_timestamps != 1)
 		return 0;
 
+	#ifdef OPLUS_BUG_STABILITY
+
+	if (net->ipv4.sysctl_tcp_random_timestamp == 0)
+	{
+		return 0;
+	}
+	#endif /* OPLUS_BUG_STABILITY */
+
 	ts_secret_init();
 	return siphash_2u32((__force u32)saddr, (__force u32)daddr,
 			    &ts_secret);
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
old mode 100644
new mode 100755
index 0629ca8..3ab834c
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -82,6 +82,63 @@ static struct kmem_cache *skbuff_fclone_cache __ro_after_init;
 int sysctl_max_skb_frags __read_mostly = MAX_SKB_FRAGS;
 EXPORT_SYMBOL(sysctl_max_skb_frags);
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+static struct kmem_cache *skbuff_cb_store_cache __read_mostly;
+
+/* Control buffer save/restore for IMQ devices */
+struct skb_cb_table {
+	char			cb[48] __aligned(8);
+	void			*cb_next;
+	atomic_t		refcnt;
+};
+
+
+int skb_save_cb(struct sk_buff *skb)
+{
+	struct skb_cb_table *next;
+
+	next = kmem_cache_alloc(skbuff_cb_store_cache, GFP_ATOMIC);
+	if (!next)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(sizeof(skb->cb) != sizeof(next->cb));
+
+	memcpy(next->cb, skb->cb, sizeof(skb->cb));
+	next->cb_next = skb->cb_next;
+
+	skb->cb_next = next;
+	smp_wmb();
+
+	return 0;
+}
+EXPORT_SYMBOL(skb_save_cb);
+
+int skb_restore_cb(struct sk_buff *skb)
+{
+	struct skb_cb_table *next;
+
+	if (!skb->cb_next)
+		return 0;
+
+	next = skb->cb_next;
+
+	BUILD_BUG_ON(sizeof(skb->cb) != sizeof(next->cb));
+
+	memcpy(skb->cb, next->cb, sizeof(skb->cb));
+	skb->cb_next = next->cb_next;
+
+	smp_wmb();
+
+	kmem_cache_free(skbuff_cb_store_cache, next);
+
+	return 0;
+}
+EXPORT_SYMBOL(skb_restore_cb);
+
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
+
 /**
  *	skb_panic - private function for out-of-line support
  *	@skb:	buffer
@@ -615,6 +672,30 @@ void skb_release_head_state(struct sk_buff *skb)
 		WARN_ON(in_irq());
 		skb->destructor(skb);
 	}
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	/*
+	 * This should not happen. When it does, avoid memleak by restoring
+	 * the chain of cb-backups.
+	 */
+	while (skb->cb_next != NULL) {
+		if (net_ratelimit())
+			pr_warn("IMQ: kfree_skb: skb->cb_next: %08x\n",
+				(unsigned int)(uintptr_t)skb->cb_next);
+
+		skb_restore_cb(skb);
+	}
+	/*
+	 * This should not happen either, nf_queue_entry is nullified in
+	 * imq_dev_xmit(). If we have non-NULL nf_queue_entry then we are
+	 * leaking entry pointers, maybe memory. We don't know if this is
+	 * pointer to already freed memory, or should this be freed.
+	 * If this happens we need to add refcounting, etc for nf_queue_entry.
+	 */
+	if (skb->nf_queue_entry && net_ratelimit())
+		pr_warn("%s\n", "IMQ: kfree_skb: skb->nf_queue_entry != NULL");
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
 	nf_conntrack_put(skb_nfct(skb));
 #endif
@@ -805,6 +886,13 @@ static void __copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 #endif
 	__nf_copy(new, old, false);
 
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	new->cb_next = NULL;
+	/*skb_copy_stored_cb(new, old);*/
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
+
 	/* Note : this field could be in headers_start/headers_end section
 	 * It is not yet because we do not want to have a 16 bit hole
 	 */
@@ -3969,6 +4057,14 @@ void __init skb_init(void)
 						0,
 						SLAB_HWCACHE_ALIGN|SLAB_PANIC,
 						NULL);
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	skbuff_cb_store_cache = kmem_cache_create("skbuff_cb_store_cache",
+						  sizeof(struct skb_cb_table),
+						  0,
+						  SLAB_HWCACHE_ALIGN|SLAB_PANIC,
+						  NULL);
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 }
 
 static int
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
old mode 100644
new mode 100755
index 08235e5..1cdbbc5
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -1117,6 +1117,15 @@ struct dst_entry *inet_csk_update_pmtu(struct sock *sk, u32 mtu)
 			goto out;
 	}
 	dst->ops->update_pmtu(dst, sk, NULL, mtu, true);
+	#ifdef OPLUS_FEATURE_WIFI_MTUDETECT
+
+	//Add for [1066205] when receives ICMP_FRAG_NEEDED, reduces the mtu of net_device.
+	pr_err("%s: current_mtu = %d , frag_mtu = %d mtu = %d\n", __func__, dst->dev->mtu, dst_mtu(dst),mtu);
+	//do not use dst_mtu here, because dst_mtu should be changed by update_pmtu after inet_csk_rebuild_route
+	if (dst->dev->mtu > mtu && mtu > IPV6_MIN_MTU) {
+		dst->dev->mtu = mtu;
+	}
+	#endif /* OPLUS_FEATURE_WIFI_MTUDETECT */
 
 	dst = __sk_dst_check(sk, 0);
 	if (!dst)
diff --git a/net/ipv4/netfilter/ipt_REJECT.c b/net/ipv4/netfilter/ipt_REJECT.c
old mode 100644
new mode 100755
index e8bed33..29f3c58
--- a/net/ipv4/netfilter/ipt_REJECT.c
+++ b/net/ipv4/netfilter/ipt_REJECT.c
@@ -30,6 +30,12 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: packet \"rejection\" target for IPv4");
 
+//#ifdef OPLUS_FEATURE_WIFI_SLA
+
+void (*mark_streams_for_iptables_reject)(struct sk_buff *skb,enum ipt_reject_with reject_type) = NULL;
+EXPORT_SYMBOL(mark_streams_for_iptables_reject);
+//#endif /* OPLUS_FEATURE_WIFI_SLA */
+
 static unsigned int
 reject_tg(struct sk_buff *skb, const struct xt_action_param *par)
 {
@@ -64,7 +70,12 @@ reject_tg(struct sk_buff *skb, const struct xt_action_param *par)
 		/* Doesn't happen. */
 		break;
 	}
-
+        //#ifdef OPLUS_FEATURE_WIFI_SLA
+
+        if (mark_streams_for_iptables_reject) {
+	        mark_streams_for_iptables_reject(skb,reject->with);
+	}
+        //#endif /* OPLUS_FEATURE_WIFI_SLA */
 	return NF_DROP;
 }
 
diff --git a/net/ipv4/netfilter/nf_dup_ipv4.c b/net/ipv4/netfilter/nf_dup_ipv4.c
old mode 100644
new mode 100755
index 39895b9..9d3f80b
--- a/net/ipv4/netfilter/nf_dup_ipv4.c
+++ b/net/ipv4/netfilter/nf_dup_ipv4.c
@@ -22,11 +22,14 @@
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
 #include <net/netfilter/nf_conntrack.h>
 #endif
+// add by PengHao
+#include <linux/inetdevice.h>
 
+extern tee_use_src;
 static bool nf_dup_ipv4_route(struct net *net, struct sk_buff *skb,
 			      const struct in_addr *gw, int oif)
 {
-	const struct iphdr *iph = ip_hdr(skb);
+	struct iphdr *iph = ip_hdr(skb);
 	struct rtable *rt;
 	struct flowi4 fl4;
 
@@ -46,6 +49,8 @@ static bool nf_dup_ipv4_route(struct net *net, struct sk_buff *skb,
 	skb_dst_set(skb, &rt->dst);
 	skb->dev      = rt->dst.dev;
 	skb->protocol = htons(ETH_P_IP);
+	if (tee_use_src)
+		iph->saddr = inet_select_addr(skb->dev, 0, RT_SCOPE_UNIVERSE);
 
 	return true;
 }
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
old mode 100644
new mode 100755
index 4d473ea..129c01d
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -574,7 +574,16 @@ static struct ctl_table ipv4_table[] = {
 		.extra1		= &tcp_use_userconfig_min,
 		.extra2		= &tcp_use_userconfig_max,
 	},
-
+	#ifdef OPLUS_BUG_STABILITY
+	//ZhaoMengqingCONNECTIVITY.WIFI.INTERNET.1394484, 2019/04/02,add for: When find TCP SYN-ACK Timestamp value error, just do not use Timestamp
+	{
+		.procname	= "tcp_timestamps_control",
+		.data		= &sysctl_tcp_ts_control,
+		.maxlen		= sizeof(sysctl_tcp_ts_control),
+		.mode		= 0664,
+		.proc_handler	= proc_dointvec
+	},
+	#endif /* OPLUS_BUG_STABILITY */
 	{ }
 };
 
@@ -1024,6 +1033,16 @@ static struct ctl_table ipv4_net_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+	#ifdef OPLUS_BUG_STABILITY
+
+	{
+		.procname	= "tcp_random_timestamp",
+		.data		= &init_net.ipv4.sysctl_tcp_random_timestamp,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	#endif /* OPLUS_BUG_STABILITY */
 	{
 		.procname	= "tcp_early_retrans",
 		.data		= &init_net.ipv4.sysctl_tcp_early_retrans,
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
old mode 100644
new mode 100755
index 5bc66da..14078eb
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -302,6 +302,12 @@ EXPORT_SYMBOL(sysctl_tcp_delack_seg);
 int sysctl_tcp_use_userconfig __read_mostly;
 EXPORT_SYMBOL(sysctl_tcp_use_userconfig);
 
+#ifdef OPLUS_BUG_STABILITY
+
+int sysctl_tcp_ts_control[2] __read_mostly = {0,0};
+EXPORT_SYMBOL(sysctl_tcp_ts_control);
+#endif /* OPLUS_BUG_STABILITY */
+
 /*
  * Current number of TCP sockets.
  */
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
old mode 100644
new mode 100755
index 496a5ac..2b6e64d
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -108,6 +108,11 @@ int sysctl_tcp_max_orphans __read_mostly = NR_FILE;
 #define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)
 #define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))
 
+//#ifdef OPLUS_FEATURE_WIFI_SLA
+
+void (*statistic_dev_rtt)(struct sock *sk,long rtt) = NULL;
+EXPORT_SYMBOL(statistic_dev_rtt);
+//#endif /* OPLUS_FEATURE_WIFI_SLA */
 #define REXMIT_NONE	0 /* no loss recovery to do */
 #define REXMIT_LOST	1 /* retransmit packets marked lost */
 #define REXMIT_NEW	2 /* FRTO-style transmit of unsent/new packets */
@@ -771,6 +776,13 @@ static void tcp_rtt_estimator(struct sock *sk, long mrtt_us)
 			tp->rtt_seq = tp->snd_nxt;
 			tp->mdev_max_us = tcp_rto_min_us(sk);
 		}
+                //#ifdef OPLUS_FEATURE_WIFI_SLA
+
+                //Add code for appo sla function
+                if(TCP_ESTABLISHED == sk->sk_state && NULL != statistic_dev_rtt){
+                        statistic_dev_rtt(sk,mrtt_us);
+                }
+                //#endif /* OPLUS_FEATURE_WIFI_SLA */
 	} else {
 		/* no previous measure. */
 		srtt = m << 3;		/* take the measured time to be rtt */
@@ -5771,6 +5783,17 @@ static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,
 	struct tcp_fastopen_cookie foc = { .len = -1 };
 	int saved_clamp = tp->rx_opt.mss_clamp;
 	bool fastopen_fail;
+	#ifdef OPLUS_BUG_STABILITY
+
+	static int ts_error_count = 0;
+	int ts_error_threshold = sysctl_tcp_ts_control[0];
+
+	//when network change (frameworks set sysctl_tcp_ts_control[1] = 1), clear ts_error_count
+	if (sysctl_tcp_ts_control[1] == 1) {
+			ts_error_count = 0;
+			sysctl_tcp_ts_control[1] = 0;
+	}
+	#endif /* OPLUS_BUG_STABILITY */
 
 	tcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0, &foc);
 	if (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)
@@ -5794,9 +5817,27 @@ static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,
 			     tcp_time_stamp(tp))) {
 			NET_INC_STATS(sock_net(sk),
 					LINUX_MIB_PAWSACTIVEREJECTED);
+			#ifdef OPLUS_BUG_STABILITY
+
+			//if count > threshold, disable TCP Timestamps
+			if (ts_error_threshold > 0) {
+				ts_error_count++;
+				if (ts_error_count >= ts_error_threshold) {
+					sock_net(sk)->ipv4.sysctl_tcp_timestamps = 0;
+					ts_error_count = 0;
+				}
+			}
+			#endif /* OPLUS_BUG_STABILITY */
 			goto reset_and_undo;
 		}
-
+                #ifdef OPLUS_BUG_STABILITY
+
+                //if other connection's Timestamp is correct, the network environment may be OK
+                if (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&
+                    ts_error_threshold > 0 && ts_error_count > 0) {
+                    ts_error_count--;
+                }
+                #endif /* OPLUS_BUG_STABILITY */
 		/* Now ACK is acceptable.
 		 *
 		 * "If the RST bit is set
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
old mode 100644
new mode 100755
index da19770..eac4479
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -2560,6 +2560,10 @@ static int __net_init tcp_sk_init(struct net *net)
 	net->ipv4.sysctl_tcp_sack = 1;
 	net->ipv4.sysctl_tcp_window_scaling = 1;
 	net->ipv4.sysctl_tcp_timestamps = 1;
+	#ifdef OPLUS_BUG_STABILITY
+
+	net->ipv4.sysctl_tcp_random_timestamp = 1;
+	#endif /* OPLUS_BUG_STABILITY */
 	net->ipv4.sysctl_tcp_early_retrans = 3;
 	net->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;
 	net->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
old mode 100644
new mode 100755
index dda4e53..91dd40e
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -184,8 +184,16 @@ static int tcp_orphan_retries(struct sock *sk, bool alive)
 
 static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)
 {
+	#ifndef OPLUS_FEATURE_WIFI_MTUDETECT
+
+	//Modify for [804055] enabling mtu probing when an ICMP black hole detected,
 	const struct net *net = sock_net(sk);
 	int mss;
+	#else
+	struct net *net = sock_net(sk);
+	int mss;
+	net->ipv4.sysctl_tcp_mtu_probing = 1;
+	#endif /* OPLUS_FEATURE_WIFI_MTUDETECT */
 
 	/* Black hole detection */
 	if (!net->ipv4.sysctl_tcp_mtu_probing)
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
old mode 100644
new mode 100755
index 7a204db..812c014
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2377,6 +2377,14 @@ static void __ip6_rt_update_pmtu(struct dst_entry *dst, const struct sock *sk,
 	if (confirm_neigh)
 		dst_confirm_neigh(dst, daddr);
 
+#ifdef OPLUS_BUG_STABILITY
+
+        //ipv6 RFC8201 test
+        if (mtu < IPV6_MIN_MTU) {
+                return;
+        }
+#endif /* OPLUS_BUG_STABILITY */
+
 	mtu = max_t(u32, mtu, IPV6_MIN_MTU);
 	if (mtu >= dst_mtu(dst))
 		return;
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
old mode 100644
new mode 100755
index 76b5041..76a4100
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -934,6 +934,21 @@ config NETFILTER_XT_TARGET_LOG
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+#HuangJunyuan@CONNECTIVITY.WIFI.INTERNET, 2018/06/26, Add for limit speed function
+config NETFILTER_XT_TARGET_IMQ
+    tristate '"IMQ" target support'
+	depends on NETFILTER_XTABLES
+	depends on IP_NF_MANGLE || IP6_NF_MANGLE
+	select IMQ
+	default y
+        help
+          This option adds a `IMQ' target which is used to specify if and
+          to which imq device packets should get enqueued/dequeued.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 config NETFILTER_XT_TARGET_MARK
 	tristate '"MARK" target support'
 	depends on NETFILTER_ADVANCED
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
old mode 100644
new mode 100755
index ad603cd..c874d8d
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -142,6 +142,10 @@ obj-$(CONFIG_NETFILTER_XT_TARGET_CT) += xt_CT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
+ifneq ($(OPLUS_FEATURE_WIFI_LIMMITBGSPEED),)
+#HuangJunyuan@CONNECTIVITY.WIFI.INTERNET, 2018/06/26, Add for limit speed function
+obj-$(CONFIG_NETFILTER_XT_TARGET_IMQ) += xt_IMQ.o
+endif # OPLUS_FEATURE_WIFI_LIMMITBGSPEED
 obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_LOG) += xt_LOG.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NETMAP) += xt_NETMAP.o
diff --git a/net/netfilter/core.c b/net/netfilter/core.c
old mode 100644
new mode 100755
index 93aaec3..7c519cb7
--- a/net/netfilter/core.c
+++ b/net/netfilter/core.c
@@ -518,6 +518,15 @@ int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
 			if (ret == 0)
 				ret = -EPERM;
 			return ret;
+		#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+		case NF_IMQ_QUEUE:
+			ret = nf_queue(skb, state, e, s, verdict);
+			if (ret == -ECANCELED)
+				continue;
+			return ret;
+		#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 		case NF_QUEUE:
 			ret = nf_queue(skb, state, e, s, verdict);
 			if (ret == 1)
diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
old mode 100644
new mode 100755
index ee6d983..abb7c72
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -29,6 +29,24 @@
  * receives, no matter what.
  */
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+static const struct nf_queue_handler __rcu *queue_imq_handler __read_mostly;
+
+void nf_register_queue_imq_handler(const struct nf_queue_handler *qh)
+{
+	rcu_assign_pointer(queue_imq_handler, qh);
+}
+EXPORT_SYMBOL_GPL(nf_register_queue_imq_handler);
+
+void nf_unregister_queue_imq_handler(void)
+{
+	RCU_INIT_POINTER(queue_imq_handler, NULL);
+	synchronize_rcu();
+}
+EXPORT_SYMBOL_GPL(nf_unregister_queue_imq_handler);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 /* return EBUSY when somebody else is registered, return EEXIST if the
  * same handler is registered, return 0 in case of success. */
 void nf_register_queue_handler(struct net *net, const struct nf_queue_handler *qh)
@@ -139,18 +157,40 @@ static void nf_ip6_saveroute(const struct sk_buff *skb,
 	}
 }
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+static int __nf_queue(struct sk_buff *skb, const struct nf_hook_state *state,
+				  const struct nf_hook_entries *entries,
+				  unsigned int index, unsigned int verdict)
+#else /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 static int __nf_queue(struct sk_buff *skb, const struct nf_hook_state *state,
 		      const struct nf_hook_entries *entries,
 		      unsigned int index, unsigned int queuenum)
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 {
 	int status = -ENOENT;
 	struct nf_queue_entry *entry = NULL;
 	const struct nf_queue_handler *qh;
 	struct net *net = state->net;
+
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	unsigned int queuetype = verdict & NF_VERDICT_MASK;
+	unsigned int queuenum  = verdict >> NF_VERDICT_QBITS;
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	unsigned int route_key_size;
 
 	/* QUEUE == DROP if no one is waiting, to be safe. */
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	if (queuetype == NF_IMQ_QUEUE) {
+		qh = rcu_dereference(queue_imq_handler);
+	} else {
+		qh = rcu_dereference(net->nf.queue_handler);
+	}
+	#else /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	qh = rcu_dereference(net->nf.queue_handler);
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	if (!qh) {
 		status = -ESRCH;
 		goto err;
@@ -218,8 +258,21 @@ int nf_queue(struct sk_buff *skb, struct nf_hook_state *state,
 {
 	int ret;
 
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	ret = __nf_queue(skb, state, entries, index, verdict);
+	#else /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	ret = __nf_queue(skb, state, entries, index, verdict >> NF_VERDICT_QBITS);
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 	if (ret < 0) {
+		#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+		/* IMQ Bypass */
+		if (ret == -ECANCELED && skb->imq_flags == 0) {
+			return 1;
+		}
+		#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 		if (ret == -ESRCH &&
 		    (verdict & NF_VERDICT_FLAG_QUEUE_BYPASS))
 			return 1;
@@ -322,6 +375,10 @@ void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)
 		entry->state.okfn(entry->state.net, entry->state.sk, skb);
 		local_bh_enable();
 		break;
+	#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+	case NF_IMQ_QUEUE:
+	#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
 	case NF_QUEUE:
 		err = nf_queue(skb, &entry->state, hooks, i, verdict);
 		if (err == 1)
diff --git a/net/netfilter/xt_IMQ.c b/net/netfilter/xt_IMQ.c
new file mode 100755
index 0000000..fc68f27
--- /dev/null
+++ b/net/netfilter/xt_IMQ.c
@@ -0,0 +1,93 @@
+/*
+ * This target marks packets to be enqueued to an imq device
+ */
+
+/************************************************************************************
+** File: - net/netfilter/xt_IMQ.c
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for limit speed function
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangJunyuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangJunyuan@CONNECTIVITY.WIFI  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_IMQ.h>
+#include <linux/imq.h>
+
+static unsigned int imq_target(struct sk_buff *pskb,
+				const struct xt_action_param *par)
+{
+	const struct xt_imq_info *mr = par->targinfo;
+
+	pskb->imq_flags = (mr->todev & IMQ_F_IFMASK) | IMQ_F_ENQUEUE;
+
+	return XT_CONTINUE;
+}
+
+static int imq_checkentry(const struct xt_tgchk_param *par)
+{
+	struct xt_imq_info *mr = par->targinfo;
+
+	if (mr->todev > IMQ_MAX_DEVS - 1) {
+		pr_warn("IMQ: invalid device specified, highest is %u\n",
+			IMQ_MAX_DEVS - 1);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct xt_target xt_imq_reg[] __read_mostly = {
+	{
+		.name           = "IMQ",
+		.family		= AF_INET,
+		.checkentry     = imq_checkentry,
+		.target         = imq_target,
+		.targetsize	= sizeof(struct xt_imq_info),
+		.table		= "mangle",
+		.me             = THIS_MODULE
+	},
+	{
+		.name           = "IMQ",
+		.family		= AF_INET6,
+		.checkentry     = imq_checkentry,
+		.target         = imq_target,
+		.targetsize	= sizeof(struct xt_imq_info),
+		.table		= "mangle",
+		.me             = THIS_MODULE
+	},
+};
+
+static int __init imq_init(void)
+{
+	return xt_register_targets(xt_imq_reg, ARRAY_SIZE(xt_imq_reg));
+}
+
+static void __exit imq_fini(void)
+{
+	xt_unregister_targets(xt_imq_reg, ARRAY_SIZE(xt_imq_reg));
+}
+
+module_init(imq_init);
+module_exit(imq_fini);
+
+MODULE_AUTHOR("https://github.com/imq/linuximq");
+MODULE_DESCRIPTION("Pseudo-driver for the intermediate queue device. See https://github.com/imq/linuximq/wiki for more information.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_IMQ");
+MODULE_ALIAS("ip6t_IMQ");
+
diff --git a/net/oplus_apps_monitor/Makefile b/net/oplus_apps_monitor/Makefile
new file mode 100755
index 0000000..de9585f4
--- /dev/null
+++ b/net/oplus_apps_monitor/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the netfilter modules on top of IPv4.
+#
+obj-y += oplus_app_monitor.o
+oplus_app_monitor-objs := oplus_apps_monitor.o oplus_apps_power_monitor.o
\ No newline at end of file
diff --git a/net/oplus_apps_monitor/oplus_apps_monitor.c b/net/oplus_apps_monitor/oplus_apps_monitor.c
new file mode 100755
index 0000000..3db4d25
--- /dev/null
+++ b/net/oplus_apps_monitor/oplus_apps_monitor.c
@@ -0,0 +1,700 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+* Copyright (C) 2018-2020 Oplus. All rights reserved.
+*/
+
+#include <net/oplus/oplus_apps_monitor.h>
+#include <net/oplus/oplus_apps_power_monitor.h>
+
+#define MONITOR_APPS_NUM_MAX     (32)
+#define IFACE_NUM_MAX            (2)
+#define WLAN_INDEX               (0)
+#define CELL_INDEX               (1)
+#define ALL_IF_INDEX             (IFACE_NUM_MAX)
+
+#define DEFAULT_RTT_EXCE_THRED  (100)
+#define DEFAULT_RTT_GOOD_THRED  (150)
+#define DEFAULT_RTT_FAIR_THRED  (200)
+#define DEFAULT_RTT_POOR_THRED  (250)
+
+#define APP_UID_IS_EMPTY         (-1)
+#define TIMER_EXPIRES HZ
+
+//the dual sta feature, the wlan/cell index is changed in oplus_sla.c
+#define DUAL_STA_FEATRUE_FLAG    (1)
+#define DUAL_STA_WLAN0_INDEX     (0)
+#define DUAL_STA_WLAN1_INDEX     (1)
+#define DUAL_STA_CELL_INDEX      (2)
+
+/*NLMSG_MIN_TYPE is 0x10,so we start at 0x11*/
+enum{
+	APPS_MONITOR_SET_ANDROID_PID        = 0x11,
+	APPS_MONITOR_SET_APPS_UID           = 0x12,
+	APPS_MONITOR_GET_APPS_CELL_RTT      = 0x13,
+	APPS_MONITOR_GET_APPS_WLAN_RTT      = 0x14,
+	APPS_MONITOR_GET_APPS_ALL_RTT       = 0x15,
+	APPS_MONITOR_REPORT_APPS_CELL_RTT   = 0x16,
+	APPS_MONITOR_REPORT_APPS_WLAN_RTT   = 0x17,
+	APPS_MONITOR_REPORT_APPS_ALL_RTT    = 0x18,
+	APPS_MOINTOR_SET_RTT_THRED          = 0x19,
+	APPS_MONITOR_GET_DEV_RTT            = 0x20,
+	APPS_MONITOR_REPORT_DEV_RTT         = 0x21,
+	//added for power monitor function
+	APPS_POWER_MONITOR_MSG_DL_CTRL = 0x30,
+	APPS_POWER_MONITOR_MSG_DL_RPT_CTRL,
+	APPS_POWER_MONITOR_MSG_UL_INFO,
+	APPS_POWER_MONITOR_MSG_UL_BEAT_ALARM,
+	APPS_POWER_MONITOR_MSG_UL_PUSH_ALARM,
+	APPS_POWER_MONITOR_MSG_UL_TRAFFIC_ALARM,
+};
+
+typedef struct rtt_params {
+	u64 rtt_exce_count;
+	u64 rtt_good_count;
+	u64 rtt_fair_count;
+	u64 rtt_poor_count;
+	u64 rtt_bad_count;
+	u64 rtt_total_count;
+} rtt_params;
+
+typedef struct rtt_params_thred {
+	u32 rtt_exce_thred;
+	u32 rtt_good_thred;
+	u32 rtt_fair_thred;
+	u32 rtt_poor_thred;
+} rtt_params_thred;
+
+typedef struct monitor_app_params {
+	int app_uid;
+	rtt_params app_rtt[IFACE_NUM_MAX];
+} monitor_app_params;
+
+static int g_monitor_apps_num = 0;
+static monitor_app_params g_monitor_apps_table[MONITOR_APPS_NUM_MAX];
+static rtt_params g_monitor_dev_table[IFACE_NUM_MAX];
+static rtt_params_thred g_rtt_params_thred = {DEFAULT_RTT_EXCE_THRED, DEFAULT_RTT_GOOD_THRED, DEFAULT_RTT_FAIR_THRED, DEFAULT_RTT_POOR_THRED};
+
+static u32 apps_monitor_netlink_pid = 0;
+static int apps_monitor_debug = 0;
+static int rrt_period_report_enable = 1;
+static int rrt_period_report_timer = 5; //5 sec
+static struct sock *apps_monitor_netlink_sock;
+static struct timer_list apps_monitor_timer;
+
+static DEFINE_MUTEX(apps_monitor_netlink_mutex);
+static struct ctl_table_header *apps_monitor_table_hrd;
+static rwlock_t apps_monitor_lock;
+
+#define apps_monitor_read_lock() 			read_lock_bh(&apps_monitor_lock);
+#define apps_monitor_read_unlock() 			read_unlock_bh(&apps_monitor_lock);
+#define apps_monitor_write_lock() 			write_lock_bh(&apps_monitor_lock);
+#define apps_monitor_write_unlock()			write_unlock_bh(&apps_monitor_lock);
+
+/* send to user space */
+int apps_monitor_netlink_send_to_user(int msg_type, char *payload, int payload_len)
+{
+	int ret = 0;
+	struct sk_buff *skbuff;
+	struct nlmsghdr *nlh;
+
+	if (!apps_monitor_netlink_pid) {
+		printk("oplus_apps_monitor: apps_monitor_netlink_send_to_user, can not unicast skbuff, apps_monitor_netlink_pid=0\n");
+		return -1;
+	}
+
+	/*allocate new buffer cache */
+	skbuff = alloc_skb(NLMSG_SPACE(payload_len), GFP_ATOMIC);
+	if (skbuff == NULL) {
+		printk("oplus_apps_monitor: apps_monitor_netlink_send_to_user, skbuff alloc_skb failed\n");
+		return -1;
+	}
+
+	/* fill in the data structure */
+	nlh = nlmsg_put(skbuff, 0, 0, msg_type, NLMSG_ALIGN(payload_len), 0);
+	if (nlh == NULL) {
+		printk("oplus_apps_monitor: apps_monitor_netlink_send_to_user, nlmsg_put failaure\n");
+		nlmsg_free(skbuff);
+		return -1;
+	}
+
+	//compute nlmsg length
+	nlh->nlmsg_len = NLMSG_HDRLEN + NLMSG_ALIGN(payload_len);
+
+	if(NULL != payload){
+		memcpy((char *)NLMSG_DATA(nlh),payload,payload_len);
+	}
+
+	/* set control field,sender's pid */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
+	NETLINK_CB(skbuff).pid = 0;
+#else
+	NETLINK_CB(skbuff).portid = 0;
+#endif
+
+	NETLINK_CB(skbuff).dst_group = 0;
+
+	/* send data */
+	if(apps_monitor_netlink_pid){
+		ret = netlink_unicast(apps_monitor_netlink_sock, skbuff, apps_monitor_netlink_pid, MSG_DONTWAIT);
+	} else {
+		printk(KERN_ERR "oplus_apps_monitor: apps_monitor_netlink_send_to_user, can not unicast skbuff, apps_monitor_netlink_pid=0\n");
+		kfree_skb(skbuff);
+	}
+
+	if(ret < 0){
+		printk(KERN_ERR "oplus_apps_monitor: apps_monitor_netlink_send_to_user, can not unicast skbuff, ret = %d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(apps_monitor_netlink_send_to_user);
+
+static struct ctl_table apps_monitor_sysctl_table[] = {
+	{
+		.procname	= "apps_monitor_debug",
+		.data		= &apps_monitor_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+	.procname	= "rrt_period_report_enable",
+	.data		= &rrt_period_report_enable,
+	.maxlen		= sizeof(int),
+	.mode		= 0644,
+	.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static void set_monitor_apps_param_default(void)
+{
+	int i = 0;
+	int j = 0;
+
+	for (i = 0; i < MONITOR_APPS_NUM_MAX; ++i) {
+		g_monitor_apps_table[i].app_uid = APP_UID_IS_EMPTY;
+
+		for (j = 0; j < IFACE_NUM_MAX; ++j) {
+			g_monitor_apps_table[i].app_rtt[j].rtt_exce_count = 0;
+			g_monitor_apps_table[i].app_rtt[j].rtt_fair_count = 0;
+			g_monitor_apps_table[i].app_rtt[j].rtt_good_count = 0;
+			g_monitor_apps_table[i].app_rtt[j].rtt_poor_count = 0;
+			g_monitor_apps_table[i].app_rtt[j].rtt_bad_count = 0;
+			g_monitor_apps_table[i].app_rtt[j].rtt_total_count = 0;
+		}
+	}
+}
+
+static void clear_apps_rtt_record(int if_index)
+{
+	int i = 0;
+	int j = 0;
+
+	switch (if_index) {
+		case WLAN_INDEX:
+			for (i = 0; i < g_monitor_apps_num; ++i) {
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_exce_count = 0;
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_fair_count = 0;
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_good_count = 0;
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_poor_count = 0;
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_bad_count = 0;
+					g_monitor_apps_table[i].app_rtt[WLAN_INDEX].rtt_total_count = 0;
+			}
+			break;
+		case CELL_INDEX:
+			for (i = 0; i < g_monitor_apps_num; ++i) {
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_exce_count = 0;
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_fair_count = 0;
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_good_count = 0;
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_poor_count = 0;
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_bad_count = 0;
+					g_monitor_apps_table[i].app_rtt[CELL_INDEX].rtt_total_count = 0;
+			}
+			break;
+		case ALL_IF_INDEX:
+			for (i = 0; i < g_monitor_apps_num; ++i) {
+				for (j = 0; j < IFACE_NUM_MAX; ++j) {
+					g_monitor_apps_table[i].app_rtt[j].rtt_exce_count = 0;
+					g_monitor_apps_table[i].app_rtt[j].rtt_fair_count = 0;
+					g_monitor_apps_table[i].app_rtt[j].rtt_good_count = 0;
+					g_monitor_apps_table[i].app_rtt[j].rtt_poor_count = 0;
+					g_monitor_apps_table[i].app_rtt[j].rtt_bad_count = 0;
+					g_monitor_apps_table[i].app_rtt[j].rtt_total_count = 0;
+				}
+			}
+			break;
+		default:
+			break;
+	}
+}
+
+static void clear_dev_rtt_record(void)
+{
+	int i = 0;
+
+	for (i = 0; i < IFACE_NUM_MAX; ++i) {
+			g_monitor_dev_table[i].rtt_exce_count = 0;
+			g_monitor_dev_table[i].rtt_fair_count = 0;
+			g_monitor_dev_table[i].rtt_good_count = 0;
+			g_monitor_dev_table[i].rtt_poor_count = 0;
+			g_monitor_dev_table[i].rtt_bad_count = 0;
+			g_monitor_dev_table[i].rtt_total_count = 0;
+	}
+}
+
+static int find_skb_uid_index_in_apps_record_table(struct sock *sk)
+{
+	kuid_t uid;
+	kuid_t sk_uid;
+	int index = 0;
+	int uid_index = -1;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0))
+	const struct file *filp = NULL;
+#endif
+
+	if (NULL == sk || !sk_fullsock(sk) || NULL == sk->sk_socket) {
+		return uid_index;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0))
+	filp = sk->sk_socket->file;
+
+	if(NULL == filp) {
+		return false;
+	}
+
+	sk_uid = filp->f_cred->fsuid;
+#else
+	sk_uid = sk->sk_uid;
+#endif
+
+	for(index = 0; index < g_monitor_apps_num; ++index) {
+		uid = make_kuid(&init_user_ns, g_monitor_apps_table[index].app_uid);
+
+		if(uid_eq(sk_uid, uid)) {
+			uid_index = index;
+			break;
+		}
+	}
+
+	return uid_index;
+}
+
+void update_dev_rtt_count(int if_index, int rtt)
+{
+	if (rtt < 0 || if_index < 0 || if_index >= IFACE_NUM_MAX) {
+		return;
+	}
+
+	if (rtt <= g_rtt_params_thred.rtt_exce_thred) {
+		++(g_monitor_dev_table[if_index].rtt_exce_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_good_thred) {
+		++(g_monitor_dev_table[if_index].rtt_good_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_fair_thred) {
+		++(g_monitor_dev_table[if_index].rtt_fair_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_poor_thred) {
+		++(g_monitor_dev_table[if_index].rtt_poor_count);
+	} else {
+		++(g_monitor_dev_table[if_index].rtt_bad_count);
+	}
+
+	++(g_monitor_dev_table[if_index].rtt_total_count);
+
+	return;
+}
+
+void update_app_rtt_count(int if_index, int sk_uid_index, int rtt)
+{
+	if (rtt < 0 || if_index < 0 || if_index >= IFACE_NUM_MAX) {
+		return;
+	}
+
+	if (rtt <= g_rtt_params_thred.rtt_exce_thred) {
+		++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_exce_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_good_thred) {
+		++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_good_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_fair_thred) {
+		++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_fair_count);
+	} else if (rtt <= g_rtt_params_thred.rtt_poor_thred) {
+		++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_poor_count);
+	} else {
+		++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_bad_count);
+	}
+
+	++(g_monitor_apps_table[sk_uid_index].app_rtt[if_index].rtt_total_count);
+
+	return;
+}
+
+void statistics_monitor_apps_rtt_via_uid(int if_index, int rtt, struct sock *sk)
+{
+	int sk_uid_index = -1;
+
+#if DUAL_STA_FEATRUE_FLAG
+	if (if_index == DUAL_STA_WLAN0_INDEX || if_index == DUAL_STA_WLAN1_INDEX ) {
+		if_index = WLAN_INDEX;
+	} else {
+		if_index = CELL_INDEX;
+	}
+#endif
+
+	if (rtt < 0 || sk == NULL || if_index < 0 || if_index >= IFACE_NUM_MAX) {
+		return;
+	}
+
+#if 0
+	printk("oplus_apps_monitor: statistics_monitor_apps_rtt_via_uid, if_index = %d, rtt = %d\n", if_index, rtt);
+#endif
+
+	apps_monitor_write_lock();
+	update_dev_rtt_count(if_index, rtt);
+
+	sk_uid_index = find_skb_uid_index_in_apps_record_table(sk);
+
+	if (sk_uid_index < 0) {
+		apps_monitor_write_unlock(); //need release lock
+		return;
+	}
+
+	update_app_rtt_count(if_index, sk_uid_index, rtt);
+	apps_monitor_write_unlock();
+}
+
+static int apps_monitor_sysctl_init(void)
+{
+	apps_monitor_table_hrd = register_net_sysctl(&init_net, "net/oplus_apps_monitor",
+		                                          apps_monitor_sysctl_table);
+	return apps_monitor_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+static int apps_monitor_set_android_pid(struct sk_buff *skb)
+{
+	apps_monitor_netlink_pid = NETLINK_CB(skb).portid;
+	printk("oplus_apps_monitor: apps_monitor_netlink_set_android_pid pid=%d\n",apps_monitor_netlink_pid);
+	return 0;
+}
+
+static int apps_monitor_set_apps_uid(struct nlmsghdr *nlh)
+{
+	int index = 0;
+	u32 *uidInfo = (u32 *)NLMSG_DATA(nlh);
+	u32 apps_uid_num = uidInfo[0];
+	u32 *apps_uid = &(uidInfo[1]);
+
+	if (apps_uid_num >= MONITOR_APPS_NUM_MAX) {
+		printk("oplus_apps_monitor: the input apps_uid_num is bigger than MONITOR_APPS_NUM_MAX! \n");
+		return -EINVAL;
+	}
+
+	set_monitor_apps_param_default();
+	g_monitor_apps_num = apps_uid_num;
+
+	for (index = 0; index < apps_uid_num; ++index) {
+		g_monitor_apps_table[index].app_uid = apps_uid[index];
+
+		if (apps_monitor_debug) {
+			printk("oplus_apps_monitor: apps_monitor_netlink_set_apps_uid, g_monitor_apps_table[%d].app_uid = %d \n", index, g_monitor_apps_table[index].app_uid);
+		}
+	}
+
+	return 0;
+}
+
+static int apps_monitor_set_rtt_thred(struct nlmsghdr *nlh)
+{
+	u32 *uidInfo = (u32 *)NLMSG_DATA(nlh);
+	u32 rtt_thred_num = uidInfo[0];
+	u32 *rtt_thred = &(uidInfo[1]);
+
+	if (rtt_thred_num > sizeof(rtt_params_thred) / sizeof(u32)) {
+		printk("oplus_apps_monitor: the input rtt_thred_num is bigger than except! the input rtt_thred_num=  %d \n", rtt_thred_num);
+		return -EINVAL;
+	}
+
+	g_rtt_params_thred.rtt_exce_thred = rtt_thred[0];
+	g_rtt_params_thred.rtt_good_thred = rtt_thred[1];
+	g_rtt_params_thred.rtt_fair_thred = rtt_thred[2];
+	g_rtt_params_thred.rtt_poor_thred = rtt_thred[3];
+
+	return 0;
+}
+
+static void print_apps_rtt_record(void) {
+	int i = 0;
+	int j = 0;
+
+	for (i = 0; i < g_monitor_apps_num; ++i) {
+		for(j = 0; j < IFACE_NUM_MAX; ++j) {
+			printk("oplus_apps_monitor: print_apps_rtt_record, the uid = %d, the if_index = %d, RTT = %llu:%llu:%llu:%llu:%llu:%llu\n",
+													g_monitor_apps_table[i].app_uid,
+													j,
+													g_monitor_apps_table[i].app_rtt[j].rtt_exce_count,
+													g_monitor_apps_table[i].app_rtt[j].rtt_good_count,
+													g_monitor_apps_table[i].app_rtt[j].rtt_fair_count,
+													g_monitor_apps_table[i].app_rtt[j].rtt_poor_count,
+													g_monitor_apps_table[i].app_rtt[j].rtt_bad_count,
+													g_monitor_apps_table[i].app_rtt[j].rtt_total_count);
+		}
+	}
+}
+
+static void print_dev_rtt_record(void) {
+	int i = 0;
+
+	for(i = 0; i < IFACE_NUM_MAX; ++i) {
+		printk("oplus_apps_monitor: print_dev_rtt_record, the if_index = %d, RTT = %llu:%llu:%llu:%llu:%llu:%llu\n",
+												i,
+												g_monitor_dev_table[i].rtt_exce_count,
+												g_monitor_dev_table[i].rtt_good_count,
+												g_monitor_dev_table[i].rtt_fair_count,
+												g_monitor_dev_table[i].rtt_poor_count,
+												g_monitor_dev_table[i].rtt_bad_count,
+												g_monitor_dev_table[i].rtt_total_count);
+	}
+}
+
+static int apps_monitor_report_apps_rtt_to_user(int if_index)
+{
+#define MAX_RTT_MSG_LEN (2048)
+	int ret = 0;
+	int index = 0;
+	int step = 0;
+	int rtt_params_size = sizeof(rtt_params);
+	int int_size = sizeof(int);
+	static char send_msg[MAX_RTT_MSG_LEN] = {0};
+
+	memset(send_msg, 0, MAX_RTT_MSG_LEN);
+
+	if ((rtt_params_size + int_size) * IFACE_NUM_MAX * g_monitor_apps_num > MAX_RTT_MSG_LEN) {
+		printk("oplus_apps_monitor: apps_monitor_report_apps_rtt_to_user, the RTT Msg is too big, len = %0x \n",
+															(rtt_params_size + int_size) * g_monitor_apps_num);
+		return -EINVAL;
+	}
+
+	switch (if_index) {
+		case WLAN_INDEX:
+			for(index = 0; index < g_monitor_apps_num; ++index) {
+				step = (rtt_params_size * index)  + index * int_size;
+				memcpy(send_msg + step, &g_monitor_apps_table[index].app_uid, int_size);
+				memcpy(send_msg + step + int_size, &(g_monitor_apps_table[index].app_rtt[WLAN_INDEX]), rtt_params_size);
+			}
+
+			ret = apps_monitor_netlink_send_to_user(APPS_MONITOR_REPORT_APPS_WLAN_RTT, (char *) send_msg,
+														(rtt_params_size + int_size) * g_monitor_apps_num);
+			break;
+		case CELL_INDEX:
+			for(index = 0; index < g_monitor_apps_num; ++index) {
+				step = (rtt_params_size * index)  + index * int_size;
+				memcpy(send_msg + step, &g_monitor_apps_table[index].app_uid, int_size);
+				memcpy(send_msg + step + int_size, &(g_monitor_apps_table[index].app_rtt[CELL_INDEX]), rtt_params_size);
+			}
+
+			ret = apps_monitor_netlink_send_to_user(APPS_MONITOR_REPORT_APPS_CELL_RTT, (char *) send_msg,
+														(rtt_params_size + int_size) * g_monitor_apps_num);
+			break;
+		case ALL_IF_INDEX:
+			for(index = 0; index < g_monitor_apps_num; ++index) {
+				step = rtt_params_size * IFACE_NUM_MAX * index + index * int_size;
+				memcpy(send_msg + step, &g_monitor_apps_table[index].app_uid, int_size);
+				memcpy(send_msg + step + int_size, &(g_monitor_apps_table[index].app_rtt), rtt_params_size * IFACE_NUM_MAX);
+			}
+
+			ret = apps_monitor_netlink_send_to_user(APPS_MONITOR_REPORT_APPS_ALL_RTT, (char *) send_msg,
+									(rtt_params_size + int_size) * IFACE_NUM_MAX * g_monitor_apps_num);
+			break;
+		default:
+			printk("oplus_apps_monitor: apps_monitor_report_apps_rtt_to_user, the if_index is unvalue! \n");
+			return -EINVAL;
+	}
+
+	if (ret == 0) {
+		if (apps_monitor_debug) {
+			print_apps_rtt_record();
+		}
+		//report success,clear the rtt record in kernel
+		clear_apps_rtt_record(if_index);
+	} else {
+		printk("oplus_apps_monitor: apps_monitor_netlink_send_rtt_to_user fail! \n");
+	}
+
+	return ret;
+}
+
+static int apps_monitor_report_dev_rtt_to_user(void)
+{
+#define MAX_DEV_RTT_MSG_LEN (256)
+	int ret = 0;
+	int index = 0;
+	int step = 0;
+	int rtt_params_size = sizeof(rtt_params);
+	static char send_msg[MAX_DEV_RTT_MSG_LEN] = {0};
+
+	memset(send_msg, 0, MAX_DEV_RTT_MSG_LEN);
+
+	if (rtt_params_size * IFACE_NUM_MAX > MAX_DEV_RTT_MSG_LEN) {
+		printk("oplus_apps_monitor: apps_monitor_report_dev_rtt_to_user, the RTT Msg is too big, len = %0x \n",
+															rtt_params_size * IFACE_NUM_MAX);
+		return -EINVAL;
+	}
+
+	for(index = 0; index < IFACE_NUM_MAX; ++index) {
+		step = rtt_params_size * index;
+		memcpy(send_msg + step, &g_monitor_dev_table[index], rtt_params_size);
+	}
+
+	ret = apps_monitor_netlink_send_to_user(APPS_MONITOR_REPORT_DEV_RTT, (char *) send_msg,
+															rtt_params_size * IFACE_NUM_MAX);
+
+	if (ret == 0) {
+		if (apps_monitor_debug) {
+			print_dev_rtt_record();
+		}
+		//report success,clear the rtt record in kernel
+		clear_dev_rtt_record();
+	} else {
+		printk("oplus_apps_monitor: apps_monitor_report_dev_rtt_to_user fail! \n");
+	}
+
+	return ret;
+}
+
+static int apps_monitor_netlink_nlmsg_handle(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+
+	if (apps_monitor_debug) {
+		printk("oplus_apps_monitor: apps_monitor_netlink_recv_handle, the nlh->nlmsg_type = %0x \n", nlh->nlmsg_type);
+	}
+
+	switch (nlh->nlmsg_type) {
+		case APPS_MONITOR_SET_ANDROID_PID:
+			ret = apps_monitor_set_android_pid(skb);
+			break;
+		case APPS_MONITOR_SET_APPS_UID:
+			ret = apps_monitor_set_apps_uid(nlh);
+			break;
+		case APPS_MONITOR_GET_APPS_CELL_RTT:
+			ret = apps_monitor_report_apps_rtt_to_user(CELL_INDEX);
+			break;
+		case APPS_MONITOR_GET_APPS_WLAN_RTT:
+			ret = apps_monitor_report_apps_rtt_to_user(WLAN_INDEX);
+			break;
+		case APPS_MONITOR_GET_APPS_ALL_RTT:
+			ret = apps_monitor_report_apps_rtt_to_user(ALL_IF_INDEX);
+			break;
+		case APPS_MOINTOR_SET_RTT_THRED:
+			ret = apps_monitor_set_rtt_thred(nlh);
+			break;
+		case APPS_MONITOR_GET_DEV_RTT:
+			ret = apps_monitor_report_dev_rtt_to_user();
+			break;
+		case APPS_POWER_MONITOR_MSG_DL_CTRL:
+			printk("[app_monitor]:rececice APPS_POWER_MONITOR_MSG_DL_CTRL\n");
+			ret = app_monitor_dl_ctl_msg_handle(nlh);
+			break;
+		case APPS_POWER_MONITOR_MSG_DL_RPT_CTRL:
+			printk("[app_monitor]:rececice APPS_POWER_MONITOR_MSG_DL_RPT_CTRL\n");
+			ret = app_monitor_dl_report_msg_handle(nlh);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+static void apps_monitor_netlink_recv(struct sk_buff *skb)
+{
+	mutex_lock(&apps_monitor_netlink_mutex);
+	netlink_rcv_skb(skb, &apps_monitor_netlink_nlmsg_handle);
+	mutex_unlock(&apps_monitor_netlink_mutex);
+}
+
+static int apps_monitor_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input	= apps_monitor_netlink_recv,
+	};
+
+	apps_monitor_netlink_sock = netlink_kernel_create(&init_net, NETLINK_OPLUS_APPS_MONITOR, &cfg);
+
+	return apps_monitor_netlink_sock == NULL ? -ENOMEM : 0;
+}
+
+static void apps_monitor_netlink_exit(void)
+{
+	netlink_kernel_release(apps_monitor_netlink_sock);
+	apps_monitor_netlink_sock = NULL;
+}
+
+static void apps_monitor_timer_function(void) {
+	if (rrt_period_report_enable && apps_monitor_netlink_pid != 0) {
+		apps_monitor_report_apps_rtt_to_user(ALL_IF_INDEX);
+		apps_monitor_report_dev_rtt_to_user();
+	}
+
+	mod_timer(&apps_monitor_timer, jiffies + rrt_period_report_timer * TIMER_EXPIRES);
+}
+
+static int is_need_period_timer(void) {
+	return rrt_period_report_enable; //For more period funs, {return xx_period_enable | xx_period_enable}
+}
+
+static void apps_monitor_timer_init(void)
+{
+	timer_setup(&apps_monitor_timer, (void*)apps_monitor_timer_function, 0);
+	apps_monitor_timer.expires = jiffies + rrt_period_report_timer * TIMER_EXPIRES;
+	add_timer(&apps_monitor_timer);
+}
+
+static void apps_monitor_timer_del(void)
+{
+	del_timer(&apps_monitor_timer);
+}
+
+static int __init oplus_apps_monitor_init(void)
+{
+	int ret = 0;
+
+	rwlock_init(&apps_monitor_lock);
+	set_monitor_apps_param_default();
+	ret = apps_monitor_netlink_init();
+
+	if (ret < 0) {
+		printk("oplus_apps_monitor: oplus_apps_monitor_init module failed to init netlink.\n");
+	} else {
+		printk("oplus_apps_monitor: oplus_apps_monitor_init module init netlink successfully.\n");
+	}
+
+	ret |= apps_monitor_sysctl_init();
+
+	if (is_need_period_timer()) {
+		apps_monitor_timer_init();
+	}
+
+       oplus_app_power_monitor_init();
+	return ret;
+}
+
+static void __exit oplus_apps_monitor_fini(void)
+{
+	clear_apps_rtt_record(ALL_IF_INDEX);
+	clear_dev_rtt_record();
+	apps_monitor_netlink_exit();
+
+	if (is_need_period_timer()) {
+		apps_monitor_timer_del();
+	}
+
+	if(apps_monitor_table_hrd){
+		unregister_net_sysctl_table(apps_monitor_table_hrd);
+	}
+
+	oplus_app_power_monitor_fini();
+}
+
+module_init(oplus_apps_monitor_init);
+module_exit(oplus_apps_monitor_fini);
diff --git a/net/oplus_apps_monitor/oplus_apps_power_monitor.c b/net/oplus_apps_monitor/oplus_apps_power_monitor.c
new file mode 100755
index 0000000..7093b9c
--- /dev/null
+++ b/net/oplus_apps_monitor/oplus_apps_power_monitor.c
@@ -0,0 +1,1190 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+* Copyright (C) 2018-2020 Oplus. All rights reserved.
+*/
+
+#include <net/oplus/oplus_apps_power_monitor.h>
+#include <linux/tcp.h>
+#include <net/tcp.h>
+#include <linux/sysctl.h>
+
+#define TOP_APP_NUM     5
+#define APP_MONITOR_HASHTABLE_SIZE 64
+#define APP_MONITOR_HASH_MASK   (APP_MONITOR_HASHTABLE_SIZE - 1)
+#define INVALID_APP_INDEX 0xff
+#define ALARM_TYPE_BEAT 0x01
+#define ALARM_TYPE_PUSH 0x02
+#define ALARM_TYPE_TRAFFIC 0x04
+#define PERIOD_CHECK_TIME   10   //unit second
+#define ALARM_DETECT_PERIOD 600  //unit second
+#define ALARM_DETECT_COUNT 10
+#define REPORT_INTERVAL 1800    //unit second
+#define REPORT_PERIOD 5
+
+enum
+{
+    APPS_POWER_MONITOR_MSG_DL_CTRL = 0x30,
+    APPS_POWER_MONITOR_MSG_DL_RPT_CTRL,
+    APPS_POWER_MONITOR_MSG_UL_INFO,
+    APPS_POWER_MONITOR_MSG_UL_BEAT_ALARM,
+    APPS_POWER_MONITOR_MSG_UL_PUSH_ALARM,
+    APPS_POWER_MONITOR_MSG_UL_TRAFFIC_ALARM,
+};
+
+#define IPV4ADDRTOSTR(addr) \
+((unsigned char *)&addr)[0], \
+((unsigned char *)&addr)[1], \
+((unsigned char *)&addr)[2], \
+((unsigned char *)&addr)[3]
+
+#pragma pack(4)
+struct app_monitor_beat_msg_st
+{
+    u32 uid_val;
+    u32 beat_period;
+    u32 beat_count;
+};
+
+struct app_monitor_push_msg_st
+{
+    u32 uid_val;
+    u32 push_period;
+    u32 push_count;
+};
+
+struct app_monitor_traffic_msg_st
+{
+    u32 uid_val;
+    u64 total_packets;
+    u64 total_bytes;
+    u64 send_packets;
+    u64 send_bytes;
+    u64 recv_packets;
+    u64 recv_bytes;
+};
+
+struct app_monitor_retrans_msg_st
+{
+    u32 uid_val;
+    u64 app_retrans_total_packets;
+    u64 app_retrans_syn_packets;
+};
+
+struct app_monitor_dl_ctl_msg_st
+{
+    u32 msg_len;
+    u32 start_flag;
+};
+
+struct app_monitor_dl_req_report_msg_st
+{
+    u32 msg_len;
+    u32 request_report_flag;
+};
+
+struct app_monitor_ul_report_msg_st
+{
+    u32 msg_len;
+    u32 beat_app_count;
+    u32 push_app_count;
+    u32 traffic_app_count;
+    u32 retrans_app_count;    //for retrams static
+    u64 sys_total_packets;
+    u64 sys_total_bytes;
+    u64 sys_send_packets;
+    u64 sys_send_bytes;
+    u64 sys_recv_packets;
+    u64 sys_recv_bytes;
+    u64 sys_retrans_total_packets;
+    u64 sys_retrans_syn_packets;
+    struct app_monitor_beat_msg_st app_beat_info[TOP_APP_NUM];
+    struct app_monitor_push_msg_st app_push_info[TOP_APP_NUM];
+    struct app_monitor_traffic_msg_st app_traffic_info[TOP_APP_NUM];
+    struct app_monitor_retrans_msg_st app_retrans_info[TOP_APP_NUM]; //for retrans static
+};
+
+struct app_monitor_ul_beat_alarm_msg_st
+{
+    u32 msg_len;
+    u32 uid_val;
+    u32 beat_period;     //unit second
+};
+
+struct app_monitor_ul_push_alarm_msg_st
+{
+    u32 msg_len;
+    u32 uid_val;
+    u32 push_period;     //unit second
+};
+
+struct app_monitor_ul_traffic_alarm_msg_st
+{
+    u32 msg_len;
+    u32 uid_val;
+    u64 total_packets;
+    u64 total_bytes;
+    u64 send_packets;
+    u64 send_bytes;
+    u64 recv_packets;
+    u64 recv_bytes;
+    u32 traffic_period;   //default  10 * 60 seconds;
+};
+#pragma pack()
+
+struct app_monitor_app_info_st
+{
+    u32 uid_val;
+    u64 total_packets;
+    u64 total_bytes;
+    u64 send_packets;
+    u64 send_bytes;
+    u64 recv_packets;
+    u64 recv_bytes;
+    u64 retrans_total_packets;
+    u64 retrans_syn_packets;
+    u32 last_send_time;
+    u32 beat_period;
+    u32 beat_count;
+    u32 last_active_time;
+    u32 push_period;
+    u32 push_count;
+    u32 beat_alarm_start_time;
+    u32 push_alarm_start_time;
+};
+
+struct app_monitor_top_app_beat_info_st
+{
+    u32 real_app_num;
+    u32 max_index;
+    u32 read_flag[TOP_APP_NUM];
+    struct app_monitor_app_info_st  app_beat_info[TOP_APP_NUM];
+};
+
+struct app_monitor_top_app_push_info_st
+{
+    u32 real_app_num;
+    u32 max_index;
+    u32 read_flag[TOP_APP_NUM];
+    struct app_monitor_app_info_st  app_push_info[TOP_APP_NUM];
+};
+
+struct app_monitor_top_app_trafffic_info_st
+{
+    u32 real_app_num;
+    u32 min_index;
+    u32 read_flag[TOP_APP_NUM];
+    struct app_monitor_app_info_st  app_traffic_info[TOP_APP_NUM];
+};
+
+struct app_monitor_top_app_retrans_info_st
+{
+    u32 real_app_num;
+    u32 min_index;
+    u32 read_flag[TOP_APP_NUM];
+    struct app_monitor_app_info_st app_retrans_info[TOP_APP_NUM];
+};
+
+struct app_monitor_app_info_list_node_st
+{
+    struct app_monitor_app_info_st app_info;
+    struct list_head   list_node;
+};
+
+struct app_monitor_list_st
+{
+    u32 m_count;
+    struct list_head m_listhead;
+};
+
+struct sys_stati_info_st
+{
+    u64 sys_total_packets;
+    u64 sys_total_bytes;
+    u64 sys_send_packets;
+    u64 sys_send_bytes;
+    u64 sys_recv_packets;
+    u64 sys_recv_bytes;
+    u64 sys_retrans_total_packets;
+    u64 sys_retrans_syn_packets;
+};
+
+struct app_monitor_top_app_trafffic_info_st top_app_traffic_info;
+struct app_monitor_top_app_beat_info_st top_app_beat_info;
+struct app_monitor_top_app_push_info_st top_app_push_info;
+struct app_monitor_top_app_retrans_info_st top_app_retrans_info;
+struct sys_stati_info_st sys_stati_info;
+struct app_monitor_list_st app_monitor_list[APP_MONITOR_HASHTABLE_SIZE];
+static rwlock_t app_power_monitor_lock;
+static int app_monitor_enable = 0;
+static int app_monitor_start = 0;
+static int app_report_request = 0;
+static int app_beat_alarm_period = 0;
+static int app_push_alarm_period = 0;
+static struct timer_list apps_monitor_report_timer;
+static struct ctl_table_header *app_power_monitor_table_hrd;
+static struct timeval last_report_tv;
+
+//added for test
+static void print_report_info(struct app_monitor_ul_report_msg_st *report_msg){
+    int i = 0;
+
+    printk("[app_monitor]: report_info:beat_app_count=%u, push_app_count=%u, traffic_app_count=%u, retrans_app_count=%u\n",
+    report_msg->beat_app_count, report_msg->push_app_count, report_msg->traffic_app_count, report_msg->retrans_app_count);
+    printk("[app_monitor]:sys_total_packet=%llu,sys_send_packet=%llu,sys_recv_packet=%llu,sys_retrans_total_packet=%llu, sys_retrans_syn_packet=%llu\n",
+              report_msg->sys_total_packets, report_msg->sys_send_packets, report_msg->sys_recv_packets,
+              report_msg->sys_retrans_total_packets, report_msg->sys_retrans_syn_packets);
+    printk("[app_monitor]:sys_total_byte=%llu,sys_send_byte=%llu,sys_recv_byte=%llu\n",
+              report_msg->sys_total_bytes, report_msg->sys_send_bytes, report_msg->sys_recv_bytes);
+    for(i = 0; i < report_msg->beat_app_count; i++){
+        printk("[app_monitor]:report_info:beat:i=%d,uid=%u,period=%u,count=%u\n",
+               i, report_msg->app_beat_info[i].uid_val,
+               report_msg->app_beat_info[i].beat_period,
+               report_msg->app_beat_info[i].beat_count);
+    }
+
+    for(i = 0; i < report_msg->push_app_count; i++){
+    printk("[app_monitor]:report_info:push:i=%d,uid=%u,period=%u,count=%u\n",
+           i, report_msg->app_push_info[i].uid_val,
+           report_msg->app_push_info[i].push_period,
+           report_msg->app_push_info[i].push_count);
+    }
+
+    for(i = 0; i < report_msg->traffic_app_count; i++){
+        printk("[app_monitor]:report_info:traffic:i=%d,uid=%u,t_bytes=%llu,t_packet=%llu,s_byte=%llu,s_packet=%llu,r_byte=%llu,r_packet=%llu\n",
+               i, report_msg->app_traffic_info[i].uid_val,
+               report_msg->app_traffic_info[i].total_bytes,
+               report_msg->app_traffic_info[i].total_packets,
+               report_msg->app_traffic_info[i].send_bytes,
+               report_msg->app_traffic_info[i].send_packets,
+               report_msg->app_traffic_info[i].recv_bytes,
+               report_msg->app_traffic_info[i].recv_packets);
+    }
+
+    for(i = 0; i < report_msg->retrans_app_count; i++){
+        printk("[app_monitor]:report_info:retrans:i=%d,uid=%u,total_retrans=%llu, syn_retrans=%llu\n",
+               i, report_msg->app_retrans_info[i].uid_val,
+               report_msg->app_retrans_info[i].app_retrans_total_packets,
+               report_msg->app_retrans_info[i].app_retrans_syn_packets);
+    }
+}
+
+void oplus_app_monitor_fill_beat_app_info(struct app_monitor_ul_report_msg_st *report_msg)
+{
+    int  i, j, k;
+    int app_num = top_app_beat_info.real_app_num;
+    int max_count = 0;
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        top_app_beat_info.read_flag[i] = 0;
+    }
+
+    for(i = 0; i < app_num; i++){
+        max_count = 0;
+        k = TOP_APP_NUM;
+        for(j = 0; j < TOP_APP_NUM;  j++){
+            if(top_app_beat_info.read_flag[j] || top_app_beat_info.app_beat_info[j].beat_period == 0)
+            continue;
+
+            if(!max_count || max_count < top_app_beat_info.app_beat_info[j].beat_count){
+                max_count = top_app_beat_info.app_beat_info[j].beat_count;
+                k = j;
+            }
+        }
+
+        if(k < TOP_APP_NUM){
+            report_msg->app_beat_info[i].uid_val = top_app_beat_info.app_beat_info[k].uid_val;
+            report_msg->app_beat_info[i].beat_period = top_app_beat_info.app_beat_info[k].beat_period;
+            report_msg->app_beat_info[i].beat_count= top_app_beat_info.app_beat_info[k].beat_count;
+            top_app_beat_info.read_flag[k] = 1;
+        }
+    }
+}
+
+void oplus_app_monitor_fill_push_app_info(struct app_monitor_ul_report_msg_st *report_msg)
+{
+    int  i, j, k;
+    int app_num = top_app_push_info.real_app_num;
+    int max_count = 0;
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        top_app_push_info.read_flag[i] = 0;
+    }
+
+    for(i = 0; i < app_num; i++){
+        max_count = 0;
+        k = TOP_APP_NUM;
+        for(j = 0; j < TOP_APP_NUM;  j++){
+            if(top_app_push_info.read_flag[j] || top_app_push_info.app_push_info[j].push_period == 0)
+                continue;
+
+            if(!max_count || max_count < top_app_push_info.app_push_info[j].push_count){
+                max_count = top_app_push_info.app_push_info[j].push_count;
+                k = j;
+            }
+        }
+
+        if(k < TOP_APP_NUM){
+            report_msg->app_push_info[i].uid_val = top_app_push_info.app_push_info[k].uid_val;
+            report_msg->app_push_info[i].push_period = top_app_push_info.app_push_info[k].push_period;
+            report_msg->app_push_info[i].push_count= top_app_push_info.app_push_info[k].push_count;
+            top_app_push_info.read_flag[k] = 1;
+        }
+    }
+}
+
+void oplus_app_monitor_fill_traffic_app_info(struct app_monitor_ul_report_msg_st *report_msg)
+{
+    int  i, j, k;
+    int app_num = top_app_traffic_info.real_app_num;
+    int max_traffic = 0;
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        top_app_traffic_info.read_flag[i] = 0;
+    }
+
+    for(i = 0; i < app_num; i++){
+        max_traffic = 0;
+        k = TOP_APP_NUM;
+        for(j = 0; j < TOP_APP_NUM;  j++){
+            if(top_app_traffic_info.read_flag[j] || top_app_traffic_info.app_traffic_info[j].total_bytes == 0)
+                continue;
+
+            if(!max_traffic || max_traffic < top_app_traffic_info.app_traffic_info[j].total_bytes){
+                max_traffic = top_app_traffic_info.app_traffic_info[j].total_bytes;
+                k = j;
+            }
+        }
+
+        if(k < TOP_APP_NUM){
+           report_msg->app_traffic_info[i].uid_val = top_app_traffic_info.app_traffic_info[k].uid_val;
+           report_msg->app_traffic_info[i].total_bytes = top_app_traffic_info.app_traffic_info[k].total_bytes;
+           report_msg->app_traffic_info[i].total_packets= top_app_traffic_info.app_traffic_info[k].total_packets;
+           report_msg->app_traffic_info[i].send_bytes = top_app_traffic_info.app_traffic_info[k].send_bytes;
+           report_msg->app_traffic_info[i].send_packets= top_app_traffic_info.app_traffic_info[k].send_packets;
+           report_msg->app_traffic_info[i].recv_bytes = top_app_traffic_info.app_traffic_info[k].recv_bytes;
+           report_msg->app_traffic_info[i].recv_packets= top_app_traffic_info.app_traffic_info[k].recv_packets;
+           top_app_traffic_info.read_flag[k] = 1;
+        }
+    }
+}
+
+void oplus_app_monitor_fill_retrans_app_info(struct app_monitor_ul_report_msg_st *report_msg)
+{
+    int  i, j, k;
+    int app_num = top_app_retrans_info.real_app_num;
+    int max_retrans = 0;
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        top_app_retrans_info.read_flag[i] = 0;
+    }
+
+    for(i = 0; i < app_num; i++){
+        max_retrans = 0;
+        k = TOP_APP_NUM;
+        for(j = 0; j < TOP_APP_NUM;  j++){
+            if(top_app_retrans_info.read_flag[j] || top_app_retrans_info.app_retrans_info[j].retrans_total_packets == 0)
+                continue;
+
+            if(!max_retrans || max_retrans < top_app_retrans_info.app_retrans_info[j].retrans_total_packets){
+                max_retrans = top_app_retrans_info.app_retrans_info[j].retrans_total_packets;
+                k = j;
+            }
+        }
+
+        if(k < TOP_APP_NUM){
+           report_msg->app_retrans_info[i].uid_val = top_app_retrans_info.app_retrans_info[k].uid_val;
+           report_msg->app_retrans_info[i].app_retrans_total_packets = top_app_retrans_info.app_retrans_info[k].retrans_total_packets;
+           report_msg->app_retrans_info[i].app_retrans_syn_packets= top_app_retrans_info.app_retrans_info[k].retrans_syn_packets;
+           top_app_retrans_info.read_flag[k] = 1;
+        }
+    }
+}
+
+
+extern int apps_monitor_netlink_send_to_user(int msg_type, char *payload, int payload_len);
+void oplus_app_monitor_send_app_info_report(void)
+{
+    int ret;
+    char msg_buf[1024] = {0};
+    struct app_monitor_ul_report_msg_st *report_msg  = (struct app_monitor_ul_report_msg_st*)msg_buf;
+    struct timeval now_tv;
+    unsigned long flags;
+
+    do_gettimeofday(&now_tv);
+    if(!app_monitor_start || before((u32)now_tv.tv_sec , (u32)(REPORT_INTERVAL + last_report_tv.tv_sec))){
+        /*printk("[app_monitor]:oplus_app_monitor_send_app_info_report,now_tv=%lld,last_tv=%lld\n",
+                 (long long)now_tv.tv_sec,  (long long)last_report_tv.tv_sec);*/
+        return;
+    }
+
+    write_lock_irqsave(&app_power_monitor_lock, flags);
+    report_msg->msg_len = sizeof(struct app_monitor_ul_report_msg_st);
+    report_msg->sys_total_packets = sys_stati_info.sys_total_packets;
+    report_msg->sys_total_bytes = sys_stati_info.sys_total_bytes;
+    report_msg->sys_send_packets = sys_stati_info.sys_send_packets;
+    report_msg->sys_send_bytes = sys_stati_info.sys_send_bytes;
+    report_msg->sys_recv_packets = sys_stati_info.sys_recv_packets;
+    report_msg->sys_recv_bytes = sys_stati_info.sys_recv_bytes;
+    report_msg->sys_retrans_total_packets = sys_stati_info.sys_retrans_total_packets;
+    report_msg->sys_retrans_syn_packets = sys_stati_info.sys_retrans_syn_packets;
+    report_msg->beat_app_count = top_app_beat_info.real_app_num;
+    report_msg->push_app_count = top_app_push_info.real_app_num;
+    report_msg->traffic_app_count = top_app_traffic_info.real_app_num;
+    report_msg->retrans_app_count = top_app_retrans_info.real_app_num;
+    oplus_app_monitor_fill_push_app_info(report_msg);
+    oplus_app_monitor_fill_beat_app_info(report_msg);
+    oplus_app_monitor_fill_traffic_app_info(report_msg);
+    oplus_app_monitor_fill_retrans_app_info(report_msg);
+    write_unlock_irqrestore(&app_power_monitor_lock, flags);
+
+    ret = apps_monitor_netlink_send_to_user(APPS_POWER_MONITOR_MSG_UL_INFO, (char *) msg_buf, report_msg->msg_len );
+    if(ret){
+        printk("[app_monitor]:send app info report error!\n");
+    }
+    else{
+        printk("[app_monitor]:send app info report success!now=%lld, now_jiffies=%u\n", (long long)now_tv.tv_sec, tcp_time_stamp);
+        print_report_info(report_msg);
+    }
+
+    do_gettimeofday(&last_report_tv);
+    return;
+}
+
+static void apps_monitor_report_timer_function(void){
+    oplus_app_monitor_send_app_info_report();
+    mod_timer(&apps_monitor_report_timer, jiffies + REPORT_PERIOD * HZ);
+}
+
+static void report_timer_init(void)
+{
+    printk("[app_monitor]:report_timer_init\n");
+    timer_setup(&apps_monitor_report_timer, (void*)apps_monitor_report_timer_function, 0);
+}
+static void report_timer_start(void){
+    printk("[app_monitor]:report_timer_start\n");
+    apps_monitor_report_timer.function = (void*)apps_monitor_report_timer_function;
+    apps_monitor_report_timer.expires = jiffies + REPORT_PERIOD * HZ;
+    //add_timer(&apps_monitor_report_timer);
+    mod_timer(&apps_monitor_report_timer, apps_monitor_report_timer.expires);
+}
+
+static void report_timer_restart(void)
+{
+    apps_monitor_report_timer.function = (void*)apps_monitor_report_timer_function;
+    mod_timer(&apps_monitor_report_timer, jiffies + REPORT_PERIOD * HZ);
+}
+
+static void report_timer_del(void)
+{
+    printk("[app_monitor]:report_timer_del\n");
+    del_timer_sync(&apps_monitor_report_timer);
+}
+
+static void oplus_app_monitor_start(void)
+{
+    int i;
+    struct list_head *head;
+    struct list_head *this_node;
+    struct list_head *next_node;
+    struct app_monitor_app_info_list_node_st *app_node_info;
+    unsigned long flags;
+
+    read_lock(&app_power_monitor_lock);
+    if(app_monitor_enable == 1){
+       read_unlock(&app_power_monitor_lock);
+       return;
+    }
+    else{
+        read_unlock(&app_power_monitor_lock);
+        write_lock_irqsave(&app_power_monitor_lock, flags);
+        for(i = 0; i < APP_MONITOR_HASHTABLE_SIZE; i++){
+            head = &(app_monitor_list[i].m_listhead);
+            this_node = head->next;
+            while(this_node != head){
+                next_node = this_node->next;
+                list_del(this_node);
+                app_node_info = list_entry(this_node, struct app_monitor_app_info_list_node_st, list_node);
+                kfree(app_node_info);
+                this_node = next_node;
+            }
+
+            app_monitor_list[i].m_count = 0;
+        }
+
+        app_monitor_enable = 1;
+        do_gettimeofday(&last_report_tv);
+        app_monitor_start = 1;
+        write_unlock_irqrestore(&app_power_monitor_lock, flags);
+    }
+
+    printk("[app_monitor]:monitor start\n");
+    report_timer_start();
+}
+
+static void oplus_app_monitor_stop(void)
+{
+    unsigned long flags;
+    int i;
+    struct list_head *head;
+    struct list_head *this_node;
+    struct list_head *next_node;
+    struct app_monitor_app_info_list_node_st *app_node_info;
+
+    write_lock_irqsave(&app_power_monitor_lock, flags);
+    app_monitor_enable = 0;
+    app_monitor_start = 0;
+    for(i = 0; i < APP_MONITOR_HASHTABLE_SIZE; i++){
+        head = &(app_monitor_list[i].m_listhead);
+        this_node = head->next;
+        while(this_node != head){
+            next_node = this_node->next;
+            list_del(this_node);
+            app_node_info = list_entry(this_node, struct app_monitor_app_info_list_node_st, list_node);
+            kfree(app_node_info);
+            this_node = next_node;
+        }
+
+        app_monitor_list[i].m_count = 0;
+    }
+    write_unlock_irqrestore(&app_power_monitor_lock, flags);
+    printk("[app_monitor]:monitor end\n");
+    report_timer_del();
+    return;
+}
+
+static inline u32 oplus_app_monitor_find_app_traffic_index(u32 uid_val)
+{
+    u32 index;
+    u32 app_num = top_app_traffic_info.real_app_num;
+
+    for(index = 0; index < app_num; index++){
+        if(uid_val == top_app_traffic_info.app_traffic_info[index].uid_val){
+            return index;
+        }
+    }
+
+    return INVALID_APP_INDEX;
+}
+
+static inline u32 oplus_app_monitor_find_app_retrans_index(u32 uid_val)
+{
+    u32 index;
+    u32 app_num = top_app_retrans_info.real_app_num;
+
+    for(index = 0; index < app_num; index++){
+        if(uid_val == top_app_retrans_info.app_retrans_info[index].uid_val){
+            return index;
+        }
+    }
+
+    return INVALID_APP_INDEX;
+}
+
+static inline u32 oplus_app_monitor_find_app_beat_index(u32 uid_val)
+{
+    u32 index;
+    u32 app_num = top_app_beat_info.real_app_num;
+
+    for(index = 0; index < app_num; index++){
+        if(uid_val == top_app_beat_info.app_beat_info[index].uid_val){
+            return index;
+        }
+    }
+
+    return INVALID_APP_INDEX;
+}
+
+static  inline u32 oplus_app_monitor_find_app_push_index(u32 uid_val)
+{
+    u32 index;
+    u32 app_num = top_app_push_info.real_app_num;
+
+    for(index = 0; index < app_num; index++){
+        if(uid_val == top_app_push_info.app_push_info[index].uid_val){
+            return index;
+        }
+    }
+
+    return INVALID_APP_INDEX;
+}
+
+void oplus_app_monitor_update_top_trafffic_app(struct app_monitor_app_info_st *app_info)
+{
+    u32 min_index = top_app_traffic_info.min_index;
+    u32 app_index;
+    u32 app_uid = app_info->uid_val;
+    u32 i;
+
+    app_index = oplus_app_monitor_find_app_traffic_index(app_uid);
+    //app record exsit, just update it
+    if(app_index < TOP_APP_NUM){
+        top_app_traffic_info.app_traffic_info[app_index] = *app_info;
+        return;
+    }
+
+    //record app traffic info is small than TOP_APP_NUM,just record  it
+    if(top_app_traffic_info.real_app_num < TOP_APP_NUM){
+        top_app_traffic_info.app_traffic_info[top_app_traffic_info.real_app_num] = *app_info;
+        top_app_traffic_info.real_app_num++;
+        return;
+    }
+
+    //compare with the min record
+    if(app_info->total_bytes > top_app_traffic_info.app_traffic_info[min_index].total_bytes){
+        top_app_traffic_info.app_traffic_info[min_index] = *app_info;
+    }
+    else{
+        return;
+    }
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        if(i == 0){
+            min_index = i;
+        }
+        else if(top_app_traffic_info.app_traffic_info[min_index].total_bytes > top_app_traffic_info.app_traffic_info[i].total_bytes){
+            min_index = i;
+        }
+    }
+
+    top_app_traffic_info.min_index = min_index;
+    return;
+}
+
+
+void oplus_app_monitor_update_top_retrans_app(struct app_monitor_app_info_st *app_info)
+{
+    u32 min_index = top_app_retrans_info.min_index;
+    u32 app_index;
+    u32 app_uid = app_info->uid_val;
+    u32 i;
+
+    app_index = oplus_app_monitor_find_app_retrans_index(app_uid);
+    //app record exsit, just update it
+    if(app_index < TOP_APP_NUM){
+        top_app_retrans_info.app_retrans_info[app_index] = *app_info;
+        return;
+    }
+
+    //record app traffic info is small than TOP_APP_NUM,just record  it
+    if(top_app_retrans_info.real_app_num < TOP_APP_NUM){
+        top_app_retrans_info.app_retrans_info[top_app_retrans_info.real_app_num] = *app_info;
+        top_app_retrans_info.real_app_num++;
+        return;
+    }
+
+    //compare with the min record
+    if(app_info->retrans_total_packets > top_app_retrans_info.app_retrans_info[min_index].retrans_total_packets){
+        top_app_retrans_info.app_retrans_info[min_index] = *app_info;
+    }
+    else{
+        return;
+    }
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        if(i == 0){
+            min_index = i;
+        }
+        else if(top_app_retrans_info.app_retrans_info[min_index].retrans_total_packets > top_app_retrans_info.app_retrans_info[i].retrans_total_packets){
+            min_index = i;
+        }
+    }
+
+    top_app_retrans_info.min_index = min_index;
+    return;
+}
+
+
+void oplus_app_monitor_update_top_beat_app(struct app_monitor_app_info_st *app_info)
+{
+    u32 max_index = top_app_beat_info.max_index;
+    u32 app_index;
+    u32 app_uid = app_info->uid_val;
+    u32 i;
+
+    app_index = oplus_app_monitor_find_app_beat_index(app_uid);
+    //app record exsit, just update it
+    if(app_index < TOP_APP_NUM){
+        top_app_beat_info.app_beat_info[app_index] = *app_info;
+        return;
+    }
+
+    //record app traffic info is small than TOP_APP_NUM,just record  it
+    if(top_app_beat_info.real_app_num < TOP_APP_NUM){
+        top_app_beat_info.app_beat_info[top_app_beat_info.real_app_num] = *app_info;
+        top_app_beat_info.real_app_num++;
+        return;
+    }
+
+    //compare with the min record
+    if(app_info->beat_count > top_app_beat_info.app_beat_info[max_index].beat_count){
+        top_app_beat_info.app_beat_info[max_index] = *app_info;
+    }
+    else{
+        return;
+    }
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        if(i == 0){
+            max_index = i;
+        }
+        else if(top_app_beat_info.app_beat_info[max_index].beat_count > top_app_beat_info.app_beat_info[i].beat_count){
+            max_index = i;
+        }
+    }
+
+    top_app_beat_info.max_index = max_index;
+    return;
+
+}
+
+static void oplus_app_monitor_update_top_push_app(struct app_monitor_app_info_st *app_info)
+{
+    u32 max_index = top_app_push_info.max_index;
+    u32 app_index;
+    u32 app_uid = app_info->uid_val;
+    u32 i;
+
+    app_index = oplus_app_monitor_find_app_push_index(app_uid);
+    //app record exsit, just update it
+    if(app_index < TOP_APP_NUM){
+        top_app_push_info.app_push_info[app_index] = *app_info;
+        return;
+    }
+
+    //record app traffic info is small than TOP_APP_NUM,just record  it
+    if(top_app_push_info.real_app_num < TOP_APP_NUM){
+        top_app_push_info.app_push_info[top_app_push_info.real_app_num] = *app_info;
+        top_app_push_info.real_app_num++;
+        return;
+    }
+
+    //compare with the min record
+    if(app_info->push_count > top_app_push_info.app_push_info[max_index].push_count){
+        top_app_push_info.app_push_info[max_index] = *app_info;
+    }
+    else{
+        return;
+    }
+
+    for(i = 0; i < TOP_APP_NUM; i++){
+        if(i == 0){
+            max_index = i;
+        }
+        else if(top_app_push_info.app_push_info[max_index].push_count > top_app_push_info.app_push_info[i].push_count){
+            max_index = i;
+        }
+    }
+
+    top_app_push_info.max_index = max_index;
+    return;
+}
+
+static struct app_monitor_app_info_list_node_st* oplus_app_monitor_get_app_info_by_uid(u32 uid)
+{
+    struct app_monitor_app_info_list_node_st *app_info_node = NULL;
+    u32 hash_index = uid & APP_MONITOR_HASH_MASK;
+
+    //list_for_each_entry(app_info_node, &app_moniter_list_head[hash_index], list_node){
+    list_for_each_entry(app_info_node, &app_monitor_list[hash_index].m_listhead, list_node){
+        if(app_info_node->app_info.uid_val == uid){
+            return app_info_node;
+        }
+    }
+
+    app_info_node = kzalloc(sizeof(struct app_monitor_app_info_list_node_st), GFP_ATOMIC);
+    if(!app_info_node){
+        return NULL;
+    }
+    else
+    {
+        app_info_node->app_info.uid_val = uid;
+        list_add(&app_info_node->list_node, &app_monitor_list[hash_index].m_listhead);
+    }
+
+     return app_info_node;
+}
+
+void oplus_app_monitor_update_flow_stat(struct app_monitor_app_info_list_node_st *app_info_node,
+                                       const  struct sk_buff *skb, int send)
+{
+    if(send){
+        app_info_node->app_info.send_packets++;
+        app_info_node->app_info.send_bytes += skb->len;
+    }
+    else{
+        app_info_node->app_info.recv_packets++;
+        app_info_node->app_info.recv_bytes += skb->len;
+    }
+
+    app_info_node->app_info.total_packets++;
+    app_info_node->app_info.total_bytes += skb->len;
+    return;
+}
+
+void oplus_app_monitor_update_retrans_stat(struct app_monitor_app_info_list_node_st *app_info_node,
+                                       const  struct sk_buff *skb)
+{
+    app_info_node->app_info.retrans_total_packets++;
+    if((TCP_SKB_CB(skb)->tcp_flags) & TCPHDR_SYN){
+        app_info_node->app_info.retrans_syn_packets++;
+    }
+
+    return;
+}
+
+
+void oplus_app_monitor_send_beat_alarm(u32 uid_val, u32 period)
+{
+    int ret;
+    char msg_buf[1024] = {0};
+    struct app_monitor_ul_beat_alarm_msg_st  *beat_alarm_msg = (struct app_monitor_ul_beat_alarm_msg_st  *)msg_buf;
+
+    beat_alarm_msg->uid_val = uid_val;
+    beat_alarm_msg->beat_period = period;
+    beat_alarm_msg->msg_len = sizeof(struct app_monitor_ul_beat_alarm_msg_st);
+    ret = apps_monitor_netlink_send_to_user(APPS_POWER_MONITOR_MSG_UL_BEAT_ALARM, (char *) msg_buf,
+                                            beat_alarm_msg->msg_len );
+    if(ret){
+        printk("[app_monitor]:send beat alarm info error!\n ");
+    }
+
+    return;
+}
+
+void oplus_app_monitor_send_push_alarm(u32  uid_val, u32 period)
+{
+    int ret;
+    char msg_buf[1024] = {0};
+    struct app_monitor_ul_push_alarm_msg_st  *push_alarm_msg = (struct app_monitor_ul_push_alarm_msg_st  *)msg_buf;
+
+    push_alarm_msg->uid_val = uid_val;
+    push_alarm_msg->push_period= period;
+    push_alarm_msg->msg_len = sizeof(struct app_monitor_ul_push_alarm_msg_st);
+    ret = apps_monitor_netlink_send_to_user(APPS_POWER_MONITOR_MSG_UL_PUSH_ALARM, (char *) msg_buf, push_alarm_msg->msg_len );
+    if(ret){
+        printk("[app_monitor]:send push alarm info error!\n ");
+    }
+
+    return;
+}
+
+void oplus_app_monitor_send_traffic_alarm(struct app_monitor_app_info_st *app_info)
+{
+    int ret;
+    char msg_buf[1024] = {0};
+    struct app_monitor_ul_traffic_alarm_msg_st  *traffic_alarm_msg = (struct app_monitor_ul_traffic_alarm_msg_st  *)msg_buf;
+
+    traffic_alarm_msg->uid_val = app_info->uid_val;
+    traffic_alarm_msg->msg_len = sizeof(struct app_monitor_ul_traffic_alarm_msg_st);
+    traffic_alarm_msg->total_bytes = app_info->total_bytes;
+    traffic_alarm_msg->total_packets = app_info->total_packets;
+    traffic_alarm_msg->recv_bytes = app_info->recv_bytes;
+    traffic_alarm_msg->recv_packets = app_info->recv_packets;
+    traffic_alarm_msg->send_bytes = app_info->send_bytes;
+    traffic_alarm_msg->send_packets = app_info->send_packets;
+    traffic_alarm_msg->traffic_period = ALARM_DETECT_PERIOD;
+    ret = apps_monitor_netlink_send_to_user(APPS_POWER_MONITOR_MSG_UL_TRAFFIC_ALARM,(char *) msg_buf,traffic_alarm_msg->msg_len);
+    if(ret){
+        printk("[app_monitor]:send traffic alarm info error!\n ");
+    }
+
+    return;
+}
+
+void oplus_app_update_sys_static_info(const struct sk_buff *skb, int send, int retrans)
+{
+    if(send && retrans){
+        sys_stati_info.sys_retrans_total_packets++;
+	 if((TCP_SKB_CB(skb)->tcp_flags) & TCPHDR_SYN){
+	     sys_stati_info.sys_retrans_syn_packets++;
+	 }
+	 return;
+    }
+
+    sys_stati_info.sys_total_packets++;
+    sys_stati_info.sys_total_bytes += skb->len;
+    if(send){
+        sys_stati_info.sys_send_packets++;
+	 sys_stati_info.sys_send_bytes += skb->len;
+    }
+    else{
+        sys_stati_info.sys_recv_packets++;
+        sys_stati_info.sys_recv_bytes += skb->len;
+    }
+}
+
+void oplus_app_monitor_update_app_info(struct sock *sk, const struct sk_buff *skb, int send, int retrans)
+{
+    u32 uid_val;
+    u32 hash_index;
+    struct app_monitor_app_info_list_node_st *app_info_node = 0;
+    u32 app_samp_time; //unit:second
+    struct timeval now_tv;
+    u32 now_sec;
+    unsigned long flags;
+
+    uid_val = sk->sk_uid.val;
+    if(uid_val < 10000 || !skb){
+         return;
+    }
+
+    hash_index = uid_val & APP_MONITOR_HASH_MASK;
+    do_gettimeofday(&now_tv);
+    now_sec = (u32)now_tv.tv_sec;
+    write_lock_irqsave(&app_power_monitor_lock, flags);
+    if(!app_monitor_enable){
+        goto exit_func;
+    }
+
+    oplus_app_update_sys_static_info(skb, send, retrans);
+
+    app_info_node =  oplus_app_monitor_get_app_info_by_uid(uid_val);
+    if(!app_info_node){
+        printk("[app_monitor]:get app_info_node error!\n");
+        goto exit_func;
+    }
+
+    if(retrans){
+        oplus_app_monitor_update_retrans_stat(app_info_node, skb);
+        oplus_app_monitor_update_top_retrans_app(&app_info_node->app_info);
+    }
+
+    if(!skb->len){
+        goto exit_func;
+    }
+    //do traffic ralative operation
+    oplus_app_monitor_update_flow_stat(app_info_node, skb, send);
+    oplus_app_monitor_update_top_trafffic_app(&app_info_node->app_info);
+
+    if(retrans){
+        goto exit_func;
+    }
+
+    //do beat check ralative operation
+    if(send){
+        if(!app_info_node->app_info.last_send_time){
+            goto exit_func;
+        }
+
+        app_samp_time = now_sec -  app_info_node->app_info.last_active_time;
+        if(app_samp_time >= PERIOD_CHECK_TIME && app_samp_time < REPORT_INTERVAL){
+            app_info_node->app_info.beat_period = (app_info_node->app_info.beat_period * app_info_node->app_info.beat_count +
+                                                                  app_samp_time) / (app_info_node->app_info.beat_count + 1);
+            if(!app_info_node->app_info.beat_count)
+                app_info_node->app_info.beat_alarm_start_time = now_sec;
+
+            app_info_node->app_info.beat_count++;
+            oplus_app_monitor_update_top_beat_app(&app_info_node->app_info);
+
+            if(app_info_node->app_info.beat_count % ALARM_DETECT_COUNT == 0){
+                int time_gap = now_sec - app_info_node->app_info.beat_alarm_start_time;
+                int period = time_gap / ALARM_DETECT_COUNT;
+                if(app_info_node->app_info.beat_alarm_start_time && time_gap < ALARM_DETECT_PERIOD){
+                    oplus_app_monitor_send_beat_alarm(app_info_node->app_info.uid_val, period);
+                }
+                app_info_node->app_info.beat_alarm_start_time = now_sec;
+            }
+        }
+    }
+    else{
+        if(!app_info_node->app_info.last_active_time){
+            goto exit_func;
+        }
+
+        app_samp_time = now_sec -  app_info_node->app_info.last_active_time;
+        if(app_samp_time > PERIOD_CHECK_TIME && app_samp_time < REPORT_INTERVAL){
+            app_info_node->app_info.push_period = (app_info_node->app_info.push_period * app_info_node->app_info.push_count +
+                                                                   app_samp_time) / (app_info_node->app_info.push_count + 1);
+            if(!app_info_node->app_info.push_count)
+                app_info_node->app_info.push_alarm_start_time = now_sec;
+
+            app_info_node->app_info.push_count++;
+            oplus_app_monitor_update_top_push_app(&app_info_node->app_info);
+
+            if(app_info_node->app_info.push_count % ALARM_DETECT_COUNT == 0){
+                int time_gap = now_sec - app_info_node->app_info.push_alarm_start_time;
+                int period = time_gap / ALARM_DETECT_COUNT;
+                if(app_info_node->app_info.push_alarm_start_time && time_gap < ALARM_DETECT_PERIOD){
+                    oplus_app_monitor_send_push_alarm(app_info_node->app_info.uid_val, period);
+                }
+                app_info_node->app_info.push_alarm_start_time = now_sec;
+            }
+        }
+    }
+
+exit_func:
+    if(app_info_node){
+        app_info_node->app_info.last_active_time = now_sec;
+        if(send){
+            app_info_node->app_info.last_send_time = now_sec;
+        }
+    }
+    write_unlock_irqrestore(&app_power_monitor_lock, flags);
+}
+EXPORT_SYMBOL(oplus_app_monitor_update_app_info);
+
+int app_monitor_dl_ctl_msg_handle(struct nlmsghdr *nlh)
+{
+    struct app_monitor_dl_ctl_msg_st *dl_ctl_msg = (struct app_monitor_dl_ctl_msg_st *)NLMSG_DATA(nlh);
+    printk("[app_monitor]:dl_ctl_msg received\n");
+
+    if(dl_ctl_msg->msg_len != sizeof(struct app_monitor_dl_ctl_msg_st)){
+        printk("[app_monitor]:msg_len err, msg_len=%u, expected_len=%lu\n",
+        dl_ctl_msg->msg_len, sizeof(struct app_monitor_dl_ctl_msg_st));
+        return -EINVAL;
+    }
+
+    if(dl_ctl_msg->start_flag){
+        oplus_app_monitor_start();
+    }else{
+        oplus_app_monitor_stop();
+    }
+
+    return 0;
+}
+
+static int proc_app_power_monitor_start(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp,loff_t *ppos)
+{
+    int ret;
+    printk("[app_monitor]:proc_app_power_monitor_start\n");
+    ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+    if (write && ret == 0){
+        if(app_monitor_start){
+            oplus_app_monitor_start();
+        }
+        else{
+            oplus_app_monitor_stop();
+        }
+    }
+
+    return ret;
+}
+
+static int proc_app_power_report_request(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+    int  ret;
+    printk("[app_monitor]:proc_app_power_report_request");
+    ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+    if (write && ret == 0){
+        if(app_report_request){
+            oplus_app_monitor_send_app_info_report();
+        }
+    }
+
+    return ret;
+}
+
+static int proc_app_set_beat_alarm_period(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+    int  ret;
+    int  index;
+    printk("[app_monitor]:proc_app_set_beat_alarm_period");
+    ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+    if (write && ret == 0){
+        index = top_app_beat_info.max_index;
+        oplus_app_monitor_send_beat_alarm(top_app_beat_info.app_beat_info[index].uid_val, (u32)app_beat_alarm_period);
+        printk("[app_monitor]:alarm:uid=%u,beat_period=%d", top_app_beat_info.app_beat_info[index].uid_val, app_beat_alarm_period);
+    }
+
+    return ret;
+}
+
+static int proc_app_set_push_alarm_period(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+    int  ret;
+    int  index;
+    printk("[app_monitor]:proc_app_set_push_alarm_period");
+    ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+    if (write && ret == 0){
+        index = top_app_push_info.max_index;
+        oplus_app_monitor_send_push_alarm(top_app_push_info.app_push_info[index].uid_val, (u32)app_push_alarm_period);
+        printk("[app_monitor]:alarm:uid=%u,push_period=%d", top_app_push_info.app_push_info[index].uid_val, app_push_alarm_period);
+    }
+
+    return ret;
+}
+
+int app_monitor_dl_report_msg_handle(struct nlmsghdr *nlh)
+{
+    printk("[app_monitor]:dl_report_req_msg received\n");
+    oplus_app_monitor_send_app_info_report();
+    report_timer_restart();
+    return 0;
+}
+
+static struct ctl_table app_power_monitor_sysctl_table[] =
+{
+    {
+        .procname = "app_monitor_start",
+        .data = &app_monitor_start,
+        .maxlen = sizeof(int),
+        .mode = 0644,
+        .proc_handler = proc_app_power_monitor_start,
+    },
+    {
+        .procname = "app_report_request",
+        .data = &app_report_request,
+        .maxlen = sizeof(int),
+        .mode = 0644,
+        .proc_handler = proc_app_power_report_request,
+    },
+    {
+        .procname = "app_beat_alarn_period",
+        .data = &app_beat_alarm_period,
+        .maxlen = sizeof(int),
+        .mode = 0644,
+        .proc_handler = proc_app_set_beat_alarm_period,
+    },
+    {
+        .procname = "app_push_alarn_period",
+        .data = &app_push_alarm_period,
+        .maxlen = sizeof(int),
+        .mode = 0644,
+        .proc_handler = proc_app_set_push_alarm_period,
+    },
+    { }
+};
+
+static int  oplus_app_power_monitor_sysctl_init(void)
+{
+    app_power_monitor_table_hrd = register_net_sysctl(&init_net, "net/oplus_app_power_monitor", app_power_monitor_sysctl_table);
+    return app_power_monitor_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+void oplus_app_power_monitor_init(void)
+{
+    int i;
+    unsigned long flags;
+
+    report_timer_init();
+    oplus_app_power_monitor_sysctl_init();
+    rwlock_init(&app_power_monitor_lock);
+    write_lock_irqsave(&app_power_monitor_lock, flags);
+    app_monitor_enable = 0;
+
+    memset(&top_app_traffic_info, 0, sizeof(struct app_monitor_top_app_trafffic_info_st));
+    memset(&top_app_beat_info, 0, sizeof(struct app_monitor_top_app_beat_info_st));
+    memset(&top_app_push_info, 0, sizeof(struct app_monitor_top_app_push_info_st));
+    memset(&top_app_retrans_info, 0, sizeof(struct app_monitor_top_app_retrans_info_st));
+    memset(&sys_stati_info, 0, sizeof(struct sys_stati_info_st));
+
+    for(i = 0; i < APP_MONITOR_HASHTABLE_SIZE; i++){
+        INIT_LIST_HEAD(&app_monitor_list[i].m_listhead);
+    }
+
+    write_unlock_irqrestore(&app_power_monitor_lock, flags);
+    printk("[app_monitor]:oplus_app_power_monitor_init\n");
+    return;
+}
+
+void oplus_app_power_monitor_fini(void)
+{
+    report_timer_del();
+    oplus_app_monitor_stop();
+    if(app_power_monitor_table_hrd){
+        unregister_net_sysctl_table(app_power_monitor_table_hrd);
+    }
+}
+
+
+
diff --git a/net/oplus_dhcp/Makefile b/net/oplus_dhcp/Makefile
new file mode 100755
index 0000000..bb6773f
--- /dev/null
+++ b/net/oplus_dhcp/Makefile
@@ -0,0 +1,25 @@
+#/************************************************************************************
+#** File: - Makefile
+#** VENDOR_EDIT
+#** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+#**
+#** Description:
+#**      1. Add for dhcp conflict
+#**
+#** Version: 1.0
+#** Date :   2020-05-09
+#** Author:  LianGenglin@CONNECTIVITY.WIFI.INTERNET
+#** TAG  :   OPLUS_FEATURE_DHCP_CONFLICT
+#**
+#** ---------------------Revision History: ---------------------
+#**  <author>                      <data>     <version >   <desc>
+#** ---------------------------------------------------------------
+#**  LianGenglin@CONNECTIVITY.WIFI.INTERNET  2020/05/09  1.0          build this module
+#**
+#************************************************************************************/
+
+#
+# Makefile for the netfilter modules on top of IPv4.
+#
+KBUILD_CFLAGS += -Wno-unused-variable -Wno-unused-function
+obj-y += oplus_dhcp.o
diff --git a/net/oplus_dhcp/oplus_dhcp.c b/net/oplus_dhcp/oplus_dhcp.c
new file mode 100755
index 0000000..8ead562
--- /dev/null
+++ b/net/oplus_dhcp/oplus_dhcp.c
@@ -0,0 +1,661 @@
+/************************************************************************************
+** File: - oplus_dhcp.c
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**		1. Add for dhcp conflict
+**
+** Version: 1.0
+** Date :	2020-05-09
+** Author:	LianGenglin@CONNECTIVITY.WIFI.INTERNET
+** TAG	:	OPLUS_FEATURE_WIFI_DHCP
+**
+** ---------------------Revision History: ---------------------
+**	<author>					  <data>	 <version >   <desc>
+** ---------------------------------------------------------------
+**	LianGenglin@CONNECTIVITY.WIFI.INTERNET	2020/05/09	1.0			 build this module
+**	LiYi@CONNECTIVITY.WIFI.INTERNET			2020/06/01	2.0			 modify this module
+**
+************************************************************************************/
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/icmp.h>
+#include <linux/sysctl.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <linux/random.h>
+#include <net/sock.h>
+#include <net/dst.h>
+#include <linux/file.h>
+#include <net/tcp_states.h>
+#include <linux/netlink.h>
+#include <net/sch_generic.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+#include <linux/netfilter/xt_state.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_owner.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+
+/* packet ops */
+#define BOOTP_REQUEST	1
+#define BOOTP_REPLY	2
+
+/* DHCP message types */
+#define DHCPDISCOVER	1
+#define DHCPOFFER		2
+#define DHCPREQUEST		3
+#define DHCPDECLINE		4
+#define DHCPACK			5
+#define DHCPNAK			6
+#define DHCPRELEASE		7
+#define DHCPINFORM		8
+
+#define NONE cpu_to_be32(INADDR_NONE)
+#define ANY cpu_to_be32(INADDR_ANY)
+
+#define DUP_SERVER_COUNT 2
+#define IFACE_COUNT 2
+#define OPLUS_DHCP_MAX_SERVERS 4
+
+#define MAIN_WLAN_IFACE "wlan0"
+#define SECOND_WLAN_IFACE "wlan1"
+
+#define MAIN_WLAN_INDEX 0
+#define SECOND_WLAN_INDEX 1
+
+#define LOG_TAG "[oplus_dhcp] %s line:%d "
+#define debug(fmt,args...) printk(LOG_TAG fmt,__FUNCTION__,__LINE__,##args)
+
+#define IP_MASK(addr) ((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2]
+
+#define MAC_MASK(addr) addr[0], \
+	addr[1], \
+	addr[4], \
+	addr[5]
+
+extern int (*handle_dhcp)(struct sock *sk, struct sk_buff *skb, struct net_device *dev, struct packet_type *pt);
+static bool oplus_dhcp_get_notify_state(struct net_device *dev);
+
+/*NLMSG_MIN_TYPE is 0x10,so we start at 0x11*/
+enum{
+	OPLUS_DHCP_SET_ANDROID_PID	 = 0x11,
+	OPLUS_DHCP_L2CONNECTED_CMD	 =0x12,
+	OPLUS_DHCP_NOTIFY_DUP_OFFER_EVENT	= 0x13,
+	OPLUS_DHCP_INTERNET_ACCESS_CMD	= 0x14,
+	OPLUS_DHCP_L2DISCONNECTED_CMD = 0x15,
+	OPLUS_DHCP_MAX = 0x16,
+};
+
+/* dhcp packet */
+struct dhcp_pkt {	   /* BOOTP packet format */
+	struct iphdr iph;	/* IP header */
+	struct udphdr udph; /* UDP header */
+	u8 op;			/* 1=request, 2=reply */
+	u8 htype;		/* HW address type */
+	u8 hlen;		/* HW address length */
+	u8 hops;		/* Used only by gateways */
+	__be32 xid;		/* Transaction ID */
+	__be16 secs;		/* Seconds since we started */
+	__be16 flags;		/* Just what it says */
+	__be32 client_ip;		/* Client's IP address if known */
+	__be32 your_ip;		/* Assigned IP address */
+	__be32 server_ip;		/* (Next, e.g. NFS) Server's IP address */
+	__be32 relay_ip;		/* IP address of BOOTP relay */
+	u8 hw_addr[16];		/* Client's HW address */
+	u8 serv_name[64];	/* Server host name */
+	u8 boot_file[128];	/* Name of boot file */
+	u8 exten[312];		/* DHCP options / BOOTP vendor extensions */
+};
+
+
+struct dhcp_server {
+	int wlan_index; // -1 for unset item
+	u8 server_mac[6];
+	unsigned int server_addr;
+};
+
+/*
+ * black list and white list offer, we only need one for each interface
+ * so we got one for each interface index
+ */
+struct dhcp_server oplus_dhcp_drop_list[IFACE_COUNT];
+struct dhcp_server oplus_dhcp_expect_list[IFACE_COUNT];
+static bool do_notify[IFACE_COUNT] = {false};
+
+static DEFINE_MUTEX(oplus_dhcp_netlink_mutex);
+static struct ctl_table_header *oplus_dhcp_hooks_table_hrd;
+
+static rwlock_t dhcp_hooks_lock;
+
+static u32 dhcp_hooks_debug = 0;
+
+// user space pid
+static u32 oplus_dhcp_pid = 0;
+
+//kernel sock
+static struct sock *oplus_dhcp_sock;
+
+/* send to user space */
+static int oplus_dhcp_send_to_user(int msg_type, char *payload, int payload_len)
+{
+	int ret = 0;
+	struct sk_buff *skbuff;
+	struct nlmsghdr *nlh;
+
+	/*allocate new buffer cache */
+	skbuff = alloc_skb(NLMSG_SPACE(payload_len), GFP_ATOMIC);
+	if (skbuff == NULL) {
+		printk("oplus_nf_hooks_netlink: skbuff alloc_skb failed\n");
+		return -1;
+	}
+
+	/* fill in the data structure */
+	nlh = nlmsg_put(skbuff, 0, 0, msg_type, NLMSG_ALIGN(payload_len), 0);
+	if (nlh == NULL) {
+		printk("oplus_nf_hooks_netlink:nlmsg_put failaure\n");
+		nlmsg_free(skbuff);
+		return -1;
+
+	}
+
+	//compute nlmsg length
+	nlh->nlmsg_len = NLMSG_HDRLEN + NLMSG_ALIGN(payload_len);
+
+	if(NULL != payload){
+		memcpy((char *)NLMSG_DATA(nlh),payload,payload_len);
+	}
+
+	/* set control field,sender's pid */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
+	NETLINK_CB(skbuff).pid = 0;
+#else
+	NETLINK_CB(skbuff).portid = 0;
+#endif
+
+	NETLINK_CB(skbuff).dst_group = 0;
+
+	/* send data */
+	if(oplus_dhcp_pid){
+		ret = netlink_unicast(oplus_dhcp_sock, skbuff, oplus_dhcp_pid, MSG_DONTWAIT);
+	} else {
+		printk(KERN_ERR "oplus_dhcp_hooks_netlink: can not unicast skbuff, oplus_dhcp_pid=0\n");
+		kfree_skb(skbuff);
+	}
+	if(ret < 0){
+		printk(KERN_ERR "oplus_dhcp_hooks_netlink: can not unicast skbuff,ret = %d\n", ret);
+		return 1;
+	}
+
+	return 0;
+}
+
+struct notify_offer {
+	u32 index;
+	u32 server_addr;
+	char server_mac[ETH_ALEN];
+};
+
+static void send_dhcp_offer_packet_to_userspace(char *wlan_iface, __be32 server_addr, char *server_mac) {
+	struct notify_offer payload;
+	int index = MAIN_WLAN_INDEX;
+
+	debug("%s, %u.%u.%u.***, %02x:%02x:***:***:%02x:%02x\n", wlan_iface, IP_MASK(server_addr), MAC_MASK(server_mac));
+	if (wlan_iface != NULL) {
+		if (0 == memcmp(wlan_iface, MAIN_WLAN_IFACE,strlen(MAIN_WLAN_IFACE))) {
+			index = MAIN_WLAN_INDEX;
+		} else if (0 == memcmp(wlan_iface, SECOND_WLAN_IFACE, strlen(SECOND_WLAN_IFACE))) {
+			index = SECOND_WLAN_INDEX;
+		}
+	}
+	payload.index = index;
+	payload.server_addr = server_addr;
+	memcpy(payload.server_mac, server_mac, ETH_ALEN);
+	oplus_dhcp_send_to_user(OPLUS_DHCP_NOTIFY_DUP_OFFER_EVENT,(char *)&payload,sizeof(payload));
+}
+
+/*
+ * get wlan index, return -1 for not found
+ */
+static int get_iface_index(char *dev_name) {
+	if (0 == memcmp(dev_name, MAIN_WLAN_IFACE,strlen(MAIN_WLAN_IFACE))) {
+		return MAIN_WLAN_INDEX;
+	}
+	if (0 == memcmp(dev_name, SECOND_WLAN_IFACE, strlen(SECOND_WLAN_IFACE))) {
+		return SECOND_WLAN_INDEX;
+	}
+	return -1;  // not found
+}
+
+/*
+ * @return true, drop packet
+ * @return false, allow packet
+ */
+static bool blackwhite_list_match(struct net_device *dev, __be32 server_id) {
+	bool is_list_empty = true;
+	int wlan_index;
+
+	wlan_index = get_iface_index(dev->name);
+	// ignore all pkts come from interface which is not in our list
+	if (wlan_index < 0 || wlan_index >= IFACE_COUNT) {
+		return false;
+	}
+
+	read_lock_bh(&dhcp_hooks_lock);
+	// white list first
+	if (oplus_dhcp_expect_list[wlan_index].wlan_index >= 0) {
+		is_list_empty = false;
+		if (oplus_dhcp_expect_list[wlan_index].server_addr == server_id) {
+			debug("allow white address %u.%u.%u.*** on %s\n", IP_MASK(server_id), dev->name);
+			read_unlock_bh(&dhcp_hooks_lock);
+			return false;
+		}
+	}
+	// white list not empty, drop all pkts not matched
+	if (!is_list_empty) {
+		read_unlock_bh(&dhcp_hooks_lock);
+		return true;
+	}
+	// then blacklist, only drop ptks in it
+	if (oplus_dhcp_drop_list[wlan_index].wlan_index >= 0) {
+		if (oplus_dhcp_drop_list[wlan_index].server_addr == server_id) {
+			debug("drop black address %u.%u.%u.*** on %s\n", IP_MASK(server_id), dev->name);
+			read_unlock_bh(&dhcp_hooks_lock);
+			return true;
+		}
+	}
+	read_unlock_bh(&dhcp_hooks_lock);
+	return false;
+}
+static int handle_dhcp_packet(struct sock *sk, struct sk_buff *skb, struct net_device *dev, struct packet_type *pt) {
+	struct dhcp_pkt *b;
+	struct iphdr *iph;
+	int len, ext_len;
+
+	/*
+	 * To be more fast, We first ignore non-raw socket and
+	 * non-ETH_P_IP packet types, such as ipv6
+	 * Note: ETH_P_IP should be sync with raw socket in DhcpClient.java
+	 */
+	if (sk->sk_type != SOCK_RAW || pt->type != htons(ETH_P_IP))
+		goto ignore;
+
+	b = (struct dhcp_pkt *)skb_network_header(skb);
+	iph = &b->iph;
+	if (iph->ihl != 5 || iph->version != 4 || iph->protocol != IPPROTO_UDP)
+		goto ignore;
+
+	/* Fragments are not supported */
+	if (ip_is_fragment(iph)) {
+		net_err_ratelimited("DHCP/BOOTP: Ignoring fragmented reply\n");
+		goto ignore;
+	}
+
+	if (skb->len < ntohs(iph->tot_len))
+		goto ignore;
+
+	if (ip_fast_csum((char *) iph, iph->ihl))
+		goto ignore;
+
+	if (b->udph.source != htons(67) || b->udph.dest != htons(68))
+		goto ignore;
+
+	if (ntohs(iph->tot_len) < ntohs(b->udph.len) + sizeof(struct iphdr))
+		goto ignore;
+
+	len = ntohs(b->udph.len) - sizeof(struct udphdr);
+	ext_len = len - (sizeof(*b) -
+		sizeof(struct iphdr) -
+		sizeof(struct udphdr) -
+		sizeof(b->exten));
+	if (ext_len < 0)
+		goto ignore;
+
+	/* Ok the front looks good, make sure we can get at the rest.  */
+	if (!pskb_may_pull(skb, skb->len))
+		goto ignore;
+
+	b = (struct dhcp_pkt *)skb_network_header(skb);
+	iph = &b->iph;
+
+	if (b->op != BOOTP_REPLY) {
+		debug("handle_dhcp_packet: not A reply message");
+		goto ignore;
+	}
+
+	/* Parse extensions */
+	if (ext_len >= 4 ) {
+		u8 *end = (u8 *) b + ntohs(b->iph.tot_len);
+		u8 *ext;
+		__be32 server_id = NONE;
+		int mt = 0;
+
+		ext = &b->exten[4];
+		while (ext < end && *ext != 0xff) {
+			u8 *opt = ext++;
+			if (*opt == 0)	/* Padding */
+				continue;
+			ext += *ext + 1;
+			if (ext >= end)
+				break;
+			switch (*opt) {
+			case 53:	/* Message type */
+				if (opt[1])
+					mt = opt[2];
+				break;
+			case 54:	/* Server ID (IP address) */
+				if (opt[1] >= 4)
+					memcpy(&server_id, opt + 2, 4);
+				break;
+			}
+		}
+
+		switch (mt) {
+		case DHCPOFFER:
+		case DHCPNAK:
+		case DHCPACK:
+			if (memcmp(dev->dev_addr,b->hw_addr,dev->addr_len) != 0) {
+				debug("this packet is not for us");
+				goto ignore;
+			}
+
+			// notify offers
+			if (oplus_dhcp_get_notify_state(dev) && mt == DHCPOFFER) {
+				char server_mac[ETH_ALEN] = {0};
+
+				memcpy(server_mac, eth_hdr(skb)->h_source, ETH_ALEN);
+				send_dhcp_offer_packet_to_userspace(dev->name, server_id, server_mac);
+			}
+			if (blackwhite_list_match(dev, server_id)) {
+				return 1;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+ignore:
+	return 0;
+
+}
+
+/*
+ * record mode, ignore expected offer list and drop offer list
+ * just notify offers to user space
+ */
+static int oplus_dhcp_start_notify_offers(u32 if_index)
+{
+	if (if_index >= IFACE_COUNT)
+		return 0;
+
+	write_lock_bh(&dhcp_hooks_lock);
+	do_notify[if_index] = true;
+	write_unlock_bh(&dhcp_hooks_lock);
+	return 0;
+}
+
+static bool oplus_dhcp_get_notify_state(struct net_device *dev) {
+	int wlan_index;
+	bool state;
+
+	wlan_index = get_iface_index(dev->name);
+	// ignore all pkts come from interface which is not in our list
+	if (wlan_index < 0 || wlan_index >= IFACE_COUNT) {
+		return false;
+	}
+	read_lock_bh(&dhcp_hooks_lock);
+	state = do_notify[wlan_index];
+	read_unlock_bh(&dhcp_hooks_lock);
+	return state;
+}
+static int oplus_dhcp_stop_notify_offers(u32 if_index)
+{
+	if (if_index >= IFACE_COUNT)
+		return 0;
+
+	write_lock_bh(&dhcp_hooks_lock);
+	do_notify[if_index] = false;
+	write_unlock_bh(&dhcp_hooks_lock);
+	return 0;
+}
+
+/*
+ * @param clear: set if we need clear the list on interface @if_index
+ */
+static int oplus_dhcp_set_drop_offer(u32 if_index, __be32 offer, bool clear)
+{
+	struct dhcp_server *p, *n;
+
+	if (if_index >= IFACE_COUNT)
+		return 0;
+
+	write_lock_bh(&dhcp_hooks_lock);
+	if (clear) {
+		oplus_dhcp_drop_list[if_index].wlan_index = -1;
+		oplus_dhcp_drop_list[if_index].server_addr = 0;
+		write_unlock_bh(&dhcp_hooks_lock);
+		return 0;
+	}
+	oplus_dhcp_drop_list[if_index].wlan_index = if_index;
+	oplus_dhcp_drop_list[if_index].server_addr = offer;
+	write_unlock_bh(&dhcp_hooks_lock);
+	return 0;
+}
+
+
+static int oplus_dhcp_set_expect_offer(u32 if_index, __be32 offer, bool clear)
+{
+	struct dhcp_server *p, *n;
+
+	if (if_index >= IFACE_COUNT)
+		return 0;
+
+	write_lock_bh(&dhcp_hooks_lock);
+	if (clear) {
+		oplus_dhcp_expect_list[if_index].wlan_index = -1;
+		oplus_dhcp_expect_list[if_index].server_addr = 0;
+		write_unlock_bh(&dhcp_hooks_lock);
+		return 0;
+	}
+	oplus_dhcp_expect_list[if_index].wlan_index = if_index;
+	oplus_dhcp_expect_list[if_index].server_addr = offer;
+	write_unlock_bh(&dhcp_hooks_lock);
+	return 0;
+}
+
+
+static int oplus_dhcp_set_android_pid(struct sk_buff *skb)
+{
+	oplus_dhcp_pid = NETLINK_CB(skb).portid;
+	debug("oplus_dhcp_set_android_pid pid=%d\n", oplus_dhcp_pid);
+	return 0;
+}
+
+static int oplus_dhcp_l2connected_cmd(struct nlmsghdr *nlh)
+{
+	u32 *data = (u32 *)NLMSG_DATA(nlh);
+	u32 index = data[0];
+	u32 dup_dhcp = data[1];
+	__be32 server_addr = data[2];
+
+	debug("iface_index = %u, dup_dhcp = %u, server_addr=%u.%u.%u.***\n", index, dup_dhcp, IP_MASK(server_addr));
+	oplus_dhcp_start_notify_offers(index);
+	if (!dup_dhcp) {
+		oplus_dhcp_set_drop_offer(index, 0, true);
+		oplus_dhcp_set_expect_offer(index, 0, true);
+	} else {
+		oplus_dhcp_set_drop_offer(index, 0, true);
+		oplus_dhcp_set_expect_offer(index, server_addr, false);
+	}
+	return 0;
+}
+
+static int oplus_dhcp_internet_access_cmd(struct nlmsghdr *nlh)
+{
+	u32 *data = (u32 *)NLMSG_DATA(nlh);
+	u32 index = data[0];
+	u32 internet_access = data[1];
+	__be32 server_addr = data[2];
+
+	debug("iface_index = %u, internet_access = %u, server_addr=%u.%u.%u.***\n", index, internet_access, IP_MASK(server_addr));
+	// no internet access, so drop address
+	if (!internet_access) {
+		oplus_dhcp_start_notify_offers(index);
+		oplus_dhcp_set_expect_offer(index, 0, true);
+		oplus_dhcp_set_drop_offer(index, server_addr, false);
+	} else {
+		// we have internet access, stops everything
+		oplus_dhcp_stop_notify_offers(index);
+		oplus_dhcp_set_drop_offer(index, 0, true);
+		oplus_dhcp_set_expect_offer(index, 0, true);
+	}
+	return 0;
+}
+
+static int oplus_dhcp_l2disconnected_cmd(struct nlmsghdr *nlh)
+{
+	u32 *data = (u32 *)NLMSG_DATA(nlh);
+	u32 index = data[0];
+
+	oplus_dhcp_stop_notify_offers(index);
+	oplus_dhcp_set_drop_offer(index, 0, true);
+	oplus_dhcp_set_expect_offer(index, 0, true);
+
+	return 0;
+}
+
+static int oplus_dhcp_netlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+	u32 portid = NETLINK_CB(skb).portid;
+
+
+	if (nlh->nlmsg_type == OPLUS_DHCP_SET_ANDROID_PID) {
+		return oplus_dhcp_set_android_pid(skb);
+	}
+	// only recv msg from target pid
+	if (portid != oplus_dhcp_pid) {
+		return ret;
+	}
+	switch (nlh->nlmsg_type) {
+	case OPLUS_DHCP_L2CONNECTED_CMD:
+		ret = oplus_dhcp_l2connected_cmd(nlh);
+		break;
+	case OPLUS_DHCP_L2DISCONNECTED_CMD:
+		ret = oplus_dhcp_l2disconnected_cmd(nlh);
+		break;
+	case OPLUS_DHCP_INTERNET_ACCESS_CMD:
+		ret = oplus_dhcp_internet_access_cmd(nlh);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+static void oplus_dhcp_netlink_rcv(struct sk_buff *skb)
+{
+	mutex_lock(&oplus_dhcp_netlink_mutex);
+	netlink_rcv_skb(skb, &oplus_dhcp_netlink_rcv_msg);
+	mutex_unlock(&oplus_dhcp_netlink_mutex);
+}
+
+static int oplus_dhcp_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input	= oplus_dhcp_netlink_rcv,
+	};
+
+	oplus_dhcp_sock = netlink_kernel_create(&init_net, NETLINK_OPLUS_DHCP, &cfg);
+	return oplus_dhcp_sock == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_dhcp_netlink_exit(void)
+{
+	netlink_kernel_release(oplus_dhcp_sock);
+	oplus_dhcp_sock = NULL;
+}
+
+
+static struct ctl_table oplus_dhcp_hooks_sysctl_table[] = {
+	{
+		.procname	= "dhcp_hooks_debug",
+		.data		= &dhcp_hooks_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static int oplus_dhcp_hooks_sysctl_init(void)
+{
+	oplus_dhcp_hooks_table_hrd = register_net_sysctl(&init_net, "net/oplus_dhcp_hooks",
+												  oplus_dhcp_hooks_sysctl_table);
+	return oplus_dhcp_hooks_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_dhcp_hooks_sysctl_fini(void)
+{
+	if(oplus_dhcp_hooks_table_hrd){
+		unregister_net_sysctl_table(oplus_dhcp_hooks_table_hrd);
+		oplus_dhcp_hooks_table_hrd = NULL;
+	}
+}
+
+static int __init oplus_dhcp_init(void)
+{
+	int ret = 0;
+	int i;
+	rwlock_init(&dhcp_hooks_lock);
+
+	memset(oplus_dhcp_drop_list, 0, sizeof(struct dhcp_server) * IFACE_COUNT);
+	memset(oplus_dhcp_expect_list, 0, sizeof(struct dhcp_server) * IFACE_COUNT);
+	/* set wlan_index = -1 to init black white list */
+	for(i = 0; i < IFACE_COUNT; i++) {
+		oplus_dhcp_set_drop_offer(i, 0, true);
+		oplus_dhcp_set_expect_offer(i, 0, true);
+		oplus_dhcp_stop_notify_offers(i);
+	}
+
+	ret = oplus_dhcp_netlink_init();
+	if (ret < 0) {
+		debug("oplus_dhcp_init module failed to init netlink.\n");
+	}
+
+	ret = oplus_dhcp_hooks_sysctl_init();
+	if (ret < 0) {
+		debug("oplus_dhcp_init module failed to init sysctl.\n");
+	}
+
+	handle_dhcp = handle_dhcp_packet;
+
+	return ret;
+}
+
+static void __exit oplus_dhcp_fini(void)
+{
+	handle_dhcp = NULL;
+
+	oplus_dhcp_hooks_sysctl_fini();
+
+	oplus_dhcp_netlink_exit();
+}
+
+module_init(oplus_dhcp_init);
+module_exit(oplus_dhcp_fini);
+
diff --git a/net/oplus_kernel2user/Makefile b/net/oplus_kernel2user/Makefile
new file mode 100755
index 0000000..9e43057
--- /dev/null
+++ b/net/oplus_kernel2user/Makefile
@@ -0,0 +1,4 @@
+#
+# Add for kernel data info send to user space.
+#
+obj-y += oplus_kernel2user.o
\ No newline at end of file
diff --git a/net/oplus_kernel2user/oplus_kernel2user.c b/net/oplus_kernel2user/oplus_kernel2user.c
new file mode 100755
index 0000000..a3181ca
--- /dev/null
+++ b/net/oplus_kernel2user/oplus_kernel2user.c
@@ -0,0 +1,501 @@
+/***********************************************************
+** Copyright (C), 2008-2019, OPLUS Mobile Comm Corp., Ltd.
+** VENDOR_EDIT
+** File: oplus_kernel2user.c
+** Description: Add for kernel data info send to user space.
+**
+** Version: 1.0
+** Date : 2019/10/02
+** Author: PengHao@NETWORK.DATA.8124, 2020/05/08
+** TAG :   OPLUS_FEATURE_DATA_EVAL
+**
+** ------------------ Revision History:------------------------
+** <author> <data> <version > <desc>
+** PengHao 2019/10/02 1.0 build this module
+****************************************************************/
+
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/icmp.h>
+#include <linux/kernel.h>
+#include <linux/sysctl.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <linux/random.h>
+#include <net/dst.h>
+#include <linux/file.h>
+#include <net/tcp_states.h>
+#include <linux/netlink.h>
+#include <net/sch_generic.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+#include <linux/netfilter/xt_state.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_owner.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+#include <net/oplus/oplus_kernel2user.h>
+
+
+static DEFINE_MUTEX(kernel2user_netlink_mutex);
+static struct ctl_table_header *oplus_kernel2user_table_hrd;
+
+static u32 kernel2user_debug = 0;
+static u32 threshold_retansmit = 10;
+static u32 smooth_factor = 20;
+static u32 protect_score = 60;
+static u32 second_wifi_score = 101;
+static u32 second_cell_score = 101;
+static u32 background_score = 101;
+
+u32 oplus_mptcp_uid[MAX_MPTCP_APP_LEN] = {0};
+u32 oplus_mptcp_len = 0;
+EXPORT_SYMBOL(oplus_mptcp_uid);
+EXPORT_SYMBOL(oplus_mptcp_len);
+u32 oplus_foreground_uid = 1;
+/*kernel sock*/
+static struct sock *oplus_kernel2user_sock;
+
+static int link_score_param[MAX_LINK_LEN][2] = {0}	/* record count_retransmit and count_normal */;
+/*static int count_retransmit = 0;*/
+/*static int count_normal = 0;*/
+static int threshold_normal = 100;
+static int special_pid = 100;
+static int threshold_gap = 5;
+static int last_score = 0;
+static struct general_oplus_info notify_user_retransmit;
+
+#define MARK_MASK    0x0fff
+
+void send_score(int link_index, int score)
+{
+	printk("telluser score = %d, link_index=%d\n", score, link_index);
+
+	link_score_param[link_index][1] = 0;
+	link_score_param[link_index][0] = 0;
+
+	if (last_score != 0) {
+		score = (score * (100 - smooth_factor) + last_score * smooth_factor) / 100;
+	}
+
+	score = score % 101;
+
+	if (abs(score - last_score) < threshold_gap) {
+		return;
+	}
+
+	if (score < protect_score && last_score < protect_score) {
+		return;
+	}
+
+	last_score = score;
+	memset((void *)&notify_user_retransmit, 0x0, sizeof(notify_user_retransmit));
+	notify_user_retransmit.para_type = OPLUS_SEND_TCP_RETRANSMIT;
+	notify_user_retransmit.para_one = oplus_foreground_uid;
+	notify_user_retransmit.para_two = score;
+	oplus_kernel_send_to_user(OPLUS_SEND_TCP_RETRANSMIT,
+				  (char *)&notify_user_retransmit, sizeof(notify_user_retransmit));
+}
+
+void oplus_handle_retransmit(const struct sock *sk, int type)
+{
+	uid_t sk_uid;
+	int total = 0;
+	int score = 0;
+	int link_index = 0;
+	link_index = get_link_index_from_sock(sk);
+
+	sk_uid = get_uid_from_sock(sk);
+
+	if (kernel2user_debug) {
+		printk("oplus_kernel2user_netlink:uid = %u, type= %d, link_index = %d\n",
+		       sk_uid,
+		       type, link_index);
+	}
+
+	if (sk != NULL) {
+		if (kernel2user_debug) {
+			printk("oplus_kernel2user_netlink:sk->sk_rcv_saddr = %pI4, sk->sk_daddr=%d\n,",
+			       &sk->sk_rcv_saddr, sk->sk_daddr);
+		}
+
+		if (sk->sk_rcv_saddr == 0x100007f) {
+			return;
+		}
+	}
+
+	if (sk_uid != oplus_foreground_uid && link_index == 0) {
+		link_index = MAX_LINK_LEN - 1;
+	}
+
+	total = link_score_param[link_index][0] + link_score_param[link_index][1];
+
+	if (type == 0) {
+		link_score_param[link_index][1]++;
+
+		if (link_score_param[link_index][1] % threshold_normal == 0 && total > 10) {
+			score = 100 * link_score_param[link_index][1] / (total + 1);
+
+			if (link_index == 0) {
+				send_score(link_index, score);
+
+			} else if (link_index == 1) {
+				second_wifi_score = score;
+
+			} else if (link_index == 2) {
+				second_cell_score = score;
+
+			} else if (link_index == (MAX_LINK_LEN - 1)) {
+				background_score = score;
+			}
+		}
+
+	} else if (type == 1) {
+		link_score_param[link_index][0]++;
+
+		if (link_score_param[link_index][0] % threshold_retansmit == 0 && total > 10) {
+			score = 100 * link_score_param[link_index][1] / (total + 1);
+
+			if (link_index == 0) {
+				send_score(link_index, score);
+
+			} else if (link_index == 1) {
+				second_wifi_score = score;
+
+			} else if (link_index == 2) {
+				second_cell_score = score;
+
+			} else if (link_index == (MAX_LINK_LEN - 1)) {
+				background_score = score;
+			}
+		}
+
+	} else if (type == -1) {
+		link_score_param[link_index][1]--;
+	}
+
+	if (kernel2user_debug) {
+		printk("oplus_kernel2user_netlink:count_retransmit=%d,count_normal=%d\n",
+		       link_score_param[link_index][0], link_score_param[link_index][1]);
+	}
+}
+
+uid_t get_uid_from_sock(const struct sock *sk)
+{
+	uid_t sk_uid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
+	const struct file *filp = NULL;
+#endif
+
+	if (NULL == sk || !sk_fullsock(sk) || NULL == sk->sk_socket) {
+		return 0;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
+	filp = sk->sk_socket->file;
+
+	if (NULL == filp) {
+		return 0;
+	}
+
+	sk_uid = __kuid_val(filp->f_cred->fsuid);
+#else
+	sk_uid = __kuid_val(sk->sk_uid);
+#endif
+	return sk_uid;
+}
+
+#define WLAN1_MARK 0x200
+#define CELL_MARK  0x400
+
+/* 0 -> default, 1 -> wlan1, 2 -> cell(not default).*/
+int get_link_index_from_sock(const struct sock *sk)
+{
+	int result = 0;
+
+	if (NULL == sk || 0 == sk->oplus_sla_mark) {
+		return result;
+	}
+
+	if ((sk->oplus_sla_mark & MARK_MASK) == WLAN1_MARK) {
+		if (kernel2user_debug) {
+			printk("get_link_index_from_sock:WLAN1_MARK \n");
+		}
+
+		return 1;
+	}
+
+	if ((sk->oplus_sla_mark & MARK_MASK) == CELL_MARK) {
+		if (kernel2user_debug) {
+			printk("get_link_index_from_sock:CELL_MARK \n");
+		}
+
+		return 2;
+	}
+
+	return result;
+}
+
+
+/* send to user space */
+int oplus_kernel_send_to_user(int msg_type, char *payload, int payload_len)
+{
+	int ret = 0;
+	struct sk_buff *skbuff;
+	struct nlmsghdr *nlh;
+
+	/*allocate new buffer cache */
+	skbuff = alloc_skb(NLMSG_SPACE(payload_len), GFP_ATOMIC);
+
+	if (skbuff == NULL) {
+		printk("oplus_kernel2user_netlink: skbuff alloc_skb failed\n");
+		return -1;
+	}
+
+	/* fill in the data structure */
+	nlh = nlmsg_put(skbuff, 0, 0, msg_type, NLMSG_ALIGN(payload_len), 0);
+
+	if (nlh == NULL) {
+		printk("oplus_kernel2user_netlink:nlmsg_put failaure\n");
+		nlmsg_free(skbuff);
+		return -1;
+	}
+
+	/*compute nlmsg length*/
+	nlh->nlmsg_len = NLMSG_HDRLEN + NLMSG_ALIGN(payload_len);
+
+	if (NULL != payload) {
+		memcpy((char *)NLMSG_DATA(nlh), payload, payload_len);
+	}
+
+	/* set control field,sender's pid */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
+	NETLINK_CB(skbuff).pid = 0;
+#else
+	NETLINK_CB(skbuff).portid = 0;
+#endif
+
+	NETLINK_CB(skbuff).dst_group = 0;
+
+	/* send data */
+	if (oplus_foreground_uid) {
+		ret = netlink_unicast(oplus_kernel2user_sock, skbuff, special_pid,
+				      MSG_DONTWAIT);
+
+	} else {
+		printk(KERN_ERR
+		       "oplus_kernel2user_netlink: can not unicast skbuff, oplus_foreground_uid=0\n");
+	}
+
+	if (ret < 0) {
+		printk(KERN_ERR "oplus_kernel2user_netlink: can not unicast skbuff,ret = %d\n",
+		       ret);
+		return 1;
+	}
+
+	return 0;
+}
+
+static struct ctl_table oplus_kernel2user_sysctl_table[] = {
+	{
+		.procname	= "oplus_foreground_uid",
+		.data		= &oplus_foreground_uid,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "kernel2user_debug",
+		.data		= &kernel2user_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "threshold_retansmit",
+		.data		= &threshold_retansmit,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "threshold_normal",
+		.data		= &threshold_normal,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "threshold_gap",
+		.data		= &threshold_gap,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "smooth_factor",
+		.data		= &smooth_factor,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "protect_score",
+		.data		= &protect_score,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "second_wifi_score",
+		.data		= &second_wifi_score,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "second_cell_score",
+		.data		= &second_cell_score,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "background_score",
+		.data		= &background_score,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static int oplus_kernel2user_sysctl_init(void)
+{
+	oplus_kernel2user_table_hrd = register_net_sysctl(&init_net,
+				      "net/oplus_kernel2user",
+				      oplus_kernel2user_sysctl_table);
+	return oplus_kernel2user_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+static int oplus_kernel2user_set_foreground_uid(struct nlmsghdr *nlh)
+{
+	u32 *data;
+	data = (u32 *)NLMSG_DATA(nlh);
+	oplus_foreground_uid = *data;
+	link_score_param[0][0] = 0;
+	link_score_param[0][1] = 0;
+	printk("oplus_kernel2user_set_foreground_uid set uid=%d\n",
+	       oplus_foreground_uid);
+	return 0;
+}
+
+static int oplus_kernel2user_set_mptcp_uid(struct nlmsghdr *nlh)
+{
+	u32 *data;
+	int i = 0;
+
+	data = (u32 *)NLMSG_DATA(nlh);
+	memset(oplus_mptcp_uid, 0x0, MAX_MPTCP_APP_LEN * sizeof(u32));
+	oplus_mptcp_len = *data;
+
+	for (i = 0; i < oplus_mptcp_len; i++) {
+		oplus_mptcp_uid[i] = *(data + i + 1);
+		printk("oplus_kernel2user_set_mptcp_uid set uid=%d\n", oplus_mptcp_uid[i]);
+	}
+
+	return 0;
+}
+
+static int kernel2user_netlink_rcv_msg(struct sk_buff *skb,
+				       struct nlmsghdr *nlh, struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+	printk("kernel2user_netlink_rcv_msg type=%d.\n", nlh->nlmsg_type);
+
+	switch (nlh->nlmsg_type) {
+	case OPLUS_FOREGROUND_ANDROID_UID:
+		ret = oplus_kernel2user_set_foreground_uid(nlh);
+		break;
+
+	case OPLUS_MPTCP_UID:
+		ret = oplus_kernel2user_set_mptcp_uid(nlh);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+static void kernel2user_netlink_rcv(struct sk_buff *skb)
+{
+	printk("kernel2user_netlink_rcv.\n");
+	mutex_lock(&kernel2user_netlink_mutex);
+	netlink_rcv_skb(skb, &kernel2user_netlink_rcv_msg);
+	mutex_unlock(&kernel2user_netlink_mutex);
+}
+
+static int oplus_kernel2user_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input	= kernel2user_netlink_rcv,
+	};
+
+	oplus_kernel2user_sock = netlink_kernel_create(&init_net,
+				 NETLINK_OPLUS_KERNEL2USER, &cfg);
+	return oplus_kernel2user_sock == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_kernel2user_netlink_exit(void)
+{
+	netlink_kernel_release(oplus_kernel2user_sock);
+	oplus_kernel2user_sock = NULL;
+}
+
+static int __init oplus_kernel2user_init(void)
+{
+	int ret = 0;
+
+	ret = oplus_kernel2user_netlink_init();
+
+	if (ret < 0) {
+		printk("oplus_kernel2user_init module failed to init netlink.\n");
+
+	} else {
+		printk("oplus_kernel2user_init module init netlink successfully.\n");
+	}
+
+	ret |= oplus_kernel2user_sysctl_init();
+
+	if (ret < 0) {
+		printk("oplus_kernel2user_init module failed to register netfilter ops.\n");
+
+	} else {
+		printk("oplus_kernel2user_init module register netfilter ops successfully.\n");
+	}
+
+	return ret;
+}
+
+static void __exit oplus_kernel2user_fini(void)
+{
+	oplus_kernel2user_netlink_exit();
+
+	if (oplus_kernel2user_table_hrd) {
+		unregister_net_sysctl_table(oplus_kernel2user_table_hrd);
+	}
+}
+
+module_init(oplus_kernel2user_init);
+module_exit(oplus_kernel2user_fini);
diff --git a/net/oplus_nf_hooks/Makefile b/net/oplus_nf_hooks/Makefile
new file mode 100755
index 0000000..34864c3
--- /dev/null
+++ b/net/oplus_nf_hooks/Makefile
@@ -0,0 +1,24 @@
+#/************************************************************************************
+#** File: - Makefile
+#** VENDOR_EDIT
+#** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+#**
+#** Description:
+#**      1. Add for WeChat lucky money recognition
+#**
+#** Version: 1.0
+#** Date :   2020-03-20
+#** Author:  HuangYuan@CONNECTIVITY.WIFI.INTERNET
+#** TAG  :   OPLUS_FEATURE_WIFI_LUCKYMONEY
+#**
+#** ---------------------Revision History: ---------------------
+#**  <author>                      <data>     <version >   <desc>
+#** ---------------------------------------------------------------
+#**  HuangYuan@CONNECTIVITY.WIFI.INTERNET  2020/03/20  1.0          build this module
+#**
+#************************************************************************************/
+
+#
+# Makefile for the netfilter modules on top of IPv4.
+#
+obj-y += oplus_nf_hooks.o
diff --git a/net/oplus_nf_hooks/oplus_nf_hooks.c b/net/oplus_nf_hooks/oplus_nf_hooks.c
new file mode 100755
index 0000000..9aaf758
--- /dev/null
+++ b/net/oplus_nf_hooks/oplus_nf_hooks.c
@@ -0,0 +1,471 @@
+/************************************************************************************
+** File: - oplus_nf_hooks.c
+** VENDOR_EDIT
+** Copyright (C), 2008-2020, OPLUS Mobile Comm Corp., Ltd
+**
+** Description:
+**      1. Add for WeChat lucky money recognition
+**
+** Version: 1.0
+** Date :   2020-03-20
+** Author:  HuangYuan@CONNECTIVITY.WIFI.INTERNET
+** TAG  :   OPLUS_FEATURE_WIFI_LUCKYMONEY
+**
+** ---------------------Revision History: ---------------------
+**  <author>                      <data>     <version >   <desc>
+** ---------------------------------------------------------------
+**  HuangYuan@CONNECTIVITY.WIFI.INTERNET  2020/03/20  1.0          build this module
+**
+************************************************************************************/
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/icmp.h>
+#include <linux/sysctl.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <linux/random.h>
+#include <net/sock.h>
+#include <net/dst.h>
+#include <linux/file.h>
+#include <net/tcp_states.h>
+#include <linux/netlink.h>
+#include <net/sch_generic.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+#include <linux/netfilter/xt_state.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_owner.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+
+
+/*NLMSG_MIN_TYPE is 0x10,so we start at 0x11*/
+enum{
+    NF_HOOKS_ANDROID_PID    = 0x11,
+	NF_HOOKS_WECHAT_PARAM   = 0x12,
+	NF_HOOKS_LM_DETECTED    = 0x13,
+};
+
+#define MAX_FIXED_VALUE_LEN 20
+#define MAX_WECHAT_PARAMS 10
+
+struct wechat_pattern_info {
+    u32 max_tot_len;
+    u32 min_tot_len;
+    int offset;
+    u32 len;
+    u8 fixed_value[MAX_FIXED_VALUE_LEN];
+};
+
+struct wechat_pattern_info wechat_infos[MAX_WECHAT_PARAMS];
+
+
+static DEFINE_MUTEX(nf_hooks_netlink_mutex);
+static struct ctl_table_header *oplus_nf_hooks_table_hrd;
+
+static rwlock_t nf_hooks_lock;
+
+#define nf_hooks_read_lock() 			read_lock_bh(&nf_hooks_lock);
+#define nf_hooks_read_unlock() 			read_unlock_bh(&nf_hooks_lock);
+#define nf_hooks_write_lock() 			write_lock_bh(&nf_hooks_lock);
+#define nf_hooks_write_unlock()			write_unlock_bh(&nf_hooks_lock);
+
+static u32 wechat_uid;
+static u32 wechat_param_count;
+
+static u32 nf_hooks_debug = 0;
+
+//portid of android netlink socket
+static u32 oplus_nf_hooks_pid;
+//kernel sock
+static struct sock *oplus_nf_hooks_sock;
+
+
+/* send to user space */
+static int oplus_nf_hooks_send_to_user(int msg_type, char *payload, int payload_len)
+{
+	int ret = 0;
+	struct sk_buff *skbuff;
+	struct nlmsghdr *nlh;
+
+	/*allocate new buffer cache */
+	skbuff = alloc_skb(NLMSG_SPACE(payload_len), GFP_ATOMIC);
+	if (skbuff == NULL) {
+		printk("oplus_nf_hooks_netlink: skbuff alloc_skb failed\n");
+		return -1;
+	}
+
+	/* fill in the data structure */
+	nlh = nlmsg_put(skbuff, 0, 0, msg_type, NLMSG_ALIGN(payload_len), 0);
+	if (nlh == NULL) {
+		printk("oplus_nf_hooks_netlink:nlmsg_put failaure\n");
+		nlmsg_free(skbuff);
+		return -1;
+	}
+
+	//compute nlmsg length
+	nlh->nlmsg_len = NLMSG_HDRLEN + NLMSG_ALIGN(payload_len);
+
+	if(NULL != payload){
+		memcpy((char *)NLMSG_DATA(nlh),payload,payload_len);
+	}
+
+	/* set control field,sender's pid */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
+	NETLINK_CB(skbuff).pid = 0;
+#else
+	NETLINK_CB(skbuff).portid = 0;
+#endif
+
+	NETLINK_CB(skbuff).dst_group = 0;
+
+	/* send data */
+	if(oplus_nf_hooks_pid){
+		ret = netlink_unicast(oplus_nf_hooks_sock, skbuff, oplus_nf_hooks_pid, MSG_DONTWAIT);
+	} else {
+		printk(KERN_ERR "oplus_nf_hooks_netlink: can not unicast skbuff, oplus_nf_hooks_pid=0\n");
+		kfree_skb(skbuff);
+	}
+	if(ret < 0){
+		printk(KERN_ERR "oplus_nf_hooks_netlink: can not unicast skbuff,ret = %d\n", ret);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static bool is_wechat_skb(struct nf_conn *ct,struct sk_buff *skb)
+{
+	kuid_t k_wc_uid;
+	kuid_t k_wc_fs_uid;
+	kuid_t sk_uid;
+	struct sock *sk = NULL;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0))
+	const struct file *filp = NULL;
+#endif
+	u32 wechat_fs_uid = wechat_uid + 99900000;
+
+    if (ct->oplus_app_uid == -1 || wechat_uid == 0) {
+        return false;
+    } else if(ct->oplus_app_uid == 0) {
+
+		sk = skb_to_full_sk(skb);
+		if(NULL == sk || !sk_fullsock(sk) || NULL == sk->sk_socket){
+			return false;
+		}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0))
+		filp = sk->sk_socket->file;
+		if(NULL == filp){
+			return false;
+		}
+		sk_uid = filp->f_cred->fsuid;
+#else
+		sk_uid = sk->sk_uid;
+#endif
+
+		k_wc_uid = make_kuid(&init_user_ns, wechat_uid);
+		k_wc_fs_uid = make_kuid(&init_user_ns, wechat_fs_uid);
+		if(uid_eq(sk_uid, k_wc_uid)){
+		    ct->oplus_app_uid = wechat_uid;
+		    //if (nf_hooks_debug) printk("oplus_nf_hooks_lm:this is wechat skb...\n");
+		    return true;
+		} else if (uid_eq(sk_uid, k_wc_fs_uid)) {
+		    ct->oplus_app_uid = wechat_fs_uid;
+		    //if (nf_hooks_debug) printk("oplus_nf_hooks_lm:this is wechat fs skb...\n");
+		    return true;
+		} else {
+	        ct->oplus_app_uid = -1;
+	        //if (nf_hooks_debug) printk("oplus_nf_hooks_lm:this is NOT wechat skb!!!\n");
+	        return false;
+	    }
+	} else if(ct->oplus_app_uid == wechat_uid
+	        || ct->oplus_app_uid == wechat_fs_uid) {
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ *To detect incoming Lucky Money event.
+*/
+static unsigned int oplus_nf_hooks_lm_detect(void *priv,
+				      struct sk_buff *skb,
+				      const struct nf_hook_state *state)
+{
+    struct nf_conn *ct = NULL;
+    enum ip_conntrack_info ctinfo;
+	struct iphdr *iph = NULL;
+	struct tcphdr *tcph = NULL;
+	u32 header_len, i;
+	u8 *payload = NULL;
+	u16 tot_len;
+
+    ct = nf_ct_get(skb, &ctinfo);
+
+	if(NULL == ct){
+		return NF_ACCEPT;
+	}
+
+    if (is_wechat_skb(ct, skb)) {
+        if ((iph = ip_hdr(skb)) != NULL && iph->protocol == IPPROTO_TCP) {
+    	    tot_len = ntohs(iph->tot_len);
+    		if (unlikely(skb_linearize(skb))) {
+    		    return NF_ACCEPT;
+    		}
+    		iph = ip_hdr(skb);
+    		tcph = tcp_hdr(skb);
+    		header_len = iph->ihl * 4 + tcph->doff * 4;
+    		payload = (u8 *)(skb->data + header_len);
+    	    for (i = 0; i < wechat_param_count; i++) {
+    		    if (tot_len >= wechat_infos[i].min_tot_len && tot_len <= wechat_infos[i].max_tot_len) {
+    		        if (memcmp(payload + wechat_infos[i].offset, wechat_infos[i].fixed_value, wechat_infos[i].len) == 0) {
+    		            printk("oplus_nf_hooks_lm:i=%d received hong bao...\n", i);
+    		            oplus_nf_hooks_send_to_user(NF_HOOKS_LM_DETECTED, NULL, 0);
+    		            break;
+    		        } else {
+    		            if (nf_hooks_debug) printk("oplus_nf_hooks_lm:i=%d fixed value not match!!\n", i);
+    		        }
+    		    } else {
+    		        if (nf_hooks_debug) printk("oplus_nf_hooks_lm:i=%d incorrect tot_len=%d\n", i, tot_len);
+    		    }
+    		}
+    	}
+    }
+
+    return NF_ACCEPT;
+}
+
+/*
+ *To detect incoming Lucky Money event with IPv6.
+*/
+static unsigned int oplus_nf_hooks_v6_lm_detect(void *priv,
+				      struct sk_buff *skb,
+				      const struct nf_hook_state *state)
+{
+		struct nf_conn *ct = NULL;
+		enum ip_conntrack_info ctinfo;
+		struct ipv6hdr *ipv6h = NULL;
+		struct tcphdr *tcph = NULL;
+		u32 header_len, i;
+		__be16 fo = 0;
+		u8 ip_proto;
+		int ihl = 0;
+		u8 *payload = NULL;
+		u16 tot_len;
+
+		ct = nf_ct_get(skb, &ctinfo);
+
+		if (NULL == ct) {
+			return NF_ACCEPT;
+		}
+
+		if (is_wechat_skb(ct, skb)) {
+			if (skb->protocol == htons(ETH_P_IPV6) && (ipv6h = ipv6_hdr(skb)) != NULL && ipv6h->nexthdr== NEXTHDR_TCP) {
+				tot_len = ntohs(ipv6h->payload_len);
+				ip_proto = ipv6h->nexthdr;
+				if (unlikely(skb_linearize(skb))) {
+					return NF_ACCEPT;
+				}
+
+				ihl = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &ip_proto, &fo);    /* ipv6 header length */
+
+				tcph = tcp_hdr(skb);
+				if (NULL == tcph) {
+					return NF_ACCEPT;
+				}
+
+				header_len = ihl + tcph->doff * 4;  /* total length of ipv6 header and tcp header */
+				payload = (u8 *)(skb->data + header_len);   /* tcp payload buffer */
+				for (i = 0; i < wechat_param_count; i++) {
+					if (tot_len >= wechat_infos[i].min_tot_len && tot_len <= wechat_infos[i].max_tot_len) {
+						if (memcmp(payload + wechat_infos[i].offset, wechat_infos[i].fixed_value, wechat_infos[i].len) == 0) {
+							printk("oplus_nf_hooks_lm:i=%d received hong bao from ipv6...\n", i);
+							oplus_nf_hooks_send_to_user(NF_HOOKS_LM_DETECTED, NULL, 0);
+							break;
+						} else {
+							if (nf_hooks_debug) printk("oplus_nf_hooks_lm:i=%d fixed value not match from ipv6!!\n", i);
+						}
+					} else {
+						if (nf_hooks_debug) printk("oplus_nf_hooks_lm:i=%d incorrect tot_len=%d from ipv6\n", i, tot_len);
+					}
+				}
+			}
+		}
+		return NF_ACCEPT;
+}
+
+static struct nf_hook_ops oplus_nf_hooks_ops[] __read_mostly = {
+	{
+		.hook		= oplus_nf_hooks_lm_detect,
+		.pf		    = NFPROTO_IPV4,
+		.hooknum	= NF_INET_LOCAL_IN,
+		.priority	= NF_IP_PRI_FILTER + 1,
+	},
+	{
+		.hook		= oplus_nf_hooks_v6_lm_detect,
+		.pf		    = NFPROTO_IPV6,
+		.hooknum	= NF_INET_LOCAL_IN,
+		.priority	= NF_IP6_PRI_FILTER + 1,
+	},
+};
+
+static struct ctl_table oplus_nf_hooks_sysctl_table[] = {
+	{
+		.procname	= "wechat_uid",
+		.data		= &wechat_uid,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "nf_hooks_debug",
+		.data		= &nf_hooks_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static int oplus_nf_hooks_sysctl_init(void)
+{
+	oplus_nf_hooks_table_hrd = register_net_sysctl(&init_net, "net/oplus_nf_hooks",
+		                                          oplus_nf_hooks_sysctl_table);
+	return oplus_nf_hooks_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+static int oplus_nf_hooks_set_android_pid(struct sk_buff *skb)
+{
+    oplus_nf_hooks_pid = NETLINK_CB(skb).portid;
+    printk("oplus_nf_hooks_set_android_pid pid=%d\n",oplus_nf_hooks_pid);
+	return 0;
+}
+
+static int oplus_nf_hooks_set_wechat_param(struct nlmsghdr *nlh)
+{
+    int i, j;
+    u32 *data;
+    struct wechat_pattern_info * info = NULL;
+    data = (u32 *)NLMSG_DATA(nlh);
+    wechat_uid = *data;
+    wechat_param_count = *(data + 1);
+    if (nlh->nlmsg_len == NLMSG_HDRLEN + 2*sizeof(u32) + wechat_param_count*sizeof(struct wechat_pattern_info)) {
+        for (i = 0; i < wechat_param_count && i < MAX_WECHAT_PARAMS; i++) {
+            info = (struct wechat_pattern_info *)(data + 2) + i;
+            memset(&(wechat_infos[i]), 0, sizeof(struct wechat_pattern_info));
+            //wechat_infos[i].uid = info->uid;
+            wechat_infos[i].max_tot_len = info->max_tot_len;
+            wechat_infos[i].min_tot_len = info->min_tot_len;
+            wechat_infos[i].offset = info->offset;
+            wechat_infos[i].len = info->len;
+            memcpy(wechat_infos[i].fixed_value, info->fixed_value, info->len);
+            if (nf_hooks_debug) {
+                printk("oplus_nf_hooks_set_wechat_param i=%d uid=%d,max=%d,min=%d,offset=%d,len=%d,value=",
+                        i, wechat_uid, wechat_infos[i].max_tot_len, wechat_infos[i].min_tot_len,
+                        wechat_infos[i].offset, wechat_infos[i].len);
+                for (j = 0; j < wechat_infos[i].len; j++) {
+                    printk("%d -> %02x  ", j, wechat_infos[i].fixed_value[j]);
+                }
+                printk("\n");
+            }
+        }
+	    return 0;
+	} else {
+	    if (nf_hooks_debug) printk("oplus_nf_hooks_set_wechat_param invalid param!! nlmsg_len=%d\n", nlh->nlmsg_len);
+	    return -1;
+	}
+}
+
+static int nf_hooks_netlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+
+	switch (nlh->nlmsg_type) {
+    	case NF_HOOKS_ANDROID_PID:
+    		ret = oplus_nf_hooks_set_android_pid(skb);
+    		break;
+    	case NF_HOOKS_WECHAT_PARAM:
+    		ret = oplus_nf_hooks_set_wechat_param(nlh);
+    		break;
+    	default:
+    		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+static void nf_hooks_netlink_rcv(struct sk_buff *skb)
+{
+	mutex_lock(&nf_hooks_netlink_mutex);
+	netlink_rcv_skb(skb, &nf_hooks_netlink_rcv_msg);
+	mutex_unlock(&nf_hooks_netlink_mutex);
+}
+
+static int oplus_nf_hooks_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input	= nf_hooks_netlink_rcv,
+	};
+
+	oplus_nf_hooks_sock = netlink_kernel_create(&init_net, NETLINK_OPLUS_NF_HOOKS, &cfg);
+	return oplus_nf_hooks_sock == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_nf_hooks_netlink_exit(void)
+{
+	netlink_kernel_release(oplus_nf_hooks_sock);
+	oplus_nf_hooks_sock = NULL;
+}
+
+static int __init oplus_nf_hooks_init(void)
+{
+	int ret = 0;
+
+	ret = oplus_nf_hooks_netlink_init();
+	if (ret < 0) {
+		printk("oplus_nf_hooks_init module failed to init netlink.\n");
+	} else {
+		printk("oplus_nf_hooks_init module init netlink successfully.\n");
+	}
+
+	ret |= oplus_nf_hooks_sysctl_init();
+
+	ret |= nf_register_net_hooks(&init_net,oplus_nf_hooks_ops,ARRAY_SIZE(oplus_nf_hooks_ops));
+	if (ret < 0) {
+		printk("oplus_nf_hooks_init module failed to register netfilter ops.\n");
+	} else {
+		printk("oplus_nf_hooks_init module register netfilter ops successfully.\n");
+	}
+
+	return ret;
+}
+
+static void __exit oplus_nf_hooks_fini(void)
+{
+    rwlock_init(&nf_hooks_lock);
+
+	oplus_nf_hooks_netlink_exit();
+
+	if(oplus_nf_hooks_table_hrd){
+		unregister_net_sysctl_table(oplus_nf_hooks_table_hrd);
+	}
+
+	nf_unregister_net_hooks(&init_net,oplus_nf_hooks_ops, ARRAY_SIZE(oplus_nf_hooks_ops));
+}
+
+module_init(oplus_nf_hooks_init);
+module_exit(oplus_nf_hooks_fini);
diff --git a/net/oplus_sla/Makefile b/net/oplus_sla/Makefile
new file mode 100755
index 0000000..2a01594
--- /dev/null
+++ b/net/oplus_sla/Makefile
@@ -0,0 +1,4 @@
+#
+# Makefile for the netfilter modules on top of IPv4.
+#
+obj-y += oplus_sla.o
diff --git a/net/oplus_sla/oplus_sla.c b/net/oplus_sla/oplus_sla.c
new file mode 100755
index 0000000..03e20e1
--- /dev/null
+++ b/net/oplus_sla/oplus_sla.c
@@ -0,0 +1,4939 @@
+/******************************************************************************
+** Copyright (C), 2019-2029, OPLUS Mobile Comm Corp., Ltd
+** VENDOR_EDIT, All rights reserved.
+** File: - oplus_sla.c
+** Description: sla
+**
+** Version: 1.0
+** Date : 2018/04/03
+** Author: Junyuan.Huang@CONNECTIVITY.WIFI.INTERNET
+** TAG: OPLUS_FEATURE_WIFI_SLA
+** ------------------------------- Revision History: ----------------------------
+** <author>                                <data>        <version>       <desc>
+** ------------------------------------------------------------------------------
+**Junyuan.Huang@CONNECTIVITY.WIFI.INTERNET 2018/04/03     1.0      OPLUS_FEATURE_WIFI_SLA
+ *******************************************************************************/
+
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/icmp.h>
+#include <linux/sysctl.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <linux/random.h>
+#include <net/sock.h>
+#include <net/dst.h>
+#include <linux/file.h>
+#include <net/tcp_states.h>
+#include <linux/workqueue.h>
+#include <linux/netlink.h>
+#include <net/sch_generic.h>
+#include <net/pkt_sched.h>
+#include <net/netfilter/nf_queue.h>
+#include <linux/netfilter/xt_state.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_owner.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+#include <linux/netfilter_ipv4/ipt_REJECT.h>
+
+
+#ifdef OPLUS_FEATURE_APP_MONITOR
+#include <net/oplus/oplus_apps_monitor.h>
+#endif /* OPLUS_FEATURE_APP_MONITOR */
+
+
+#define MARK_MASK    0x0fff
+#define RETRAN_MASK  0xf000
+#define RTT_MASK     0xf000
+#define GAME_UNSPEC_MASK 0x8000
+
+#define WLAN_NUM        2
+#define WLAN0_INDEX     0
+#define WLAN1_INDEX     1
+#define CELL_INDEX      2
+#define DOWNLOAD_FLAG   5
+#define MAX_SYN_RETRANS 5
+#define RTT_NUM         5
+
+#define NORMAL_RTT      100
+#define BACK_OFF_RTT_1	200   //200ms
+#define BACK_OFF_RTT_2	300   //300ms
+#define SYN_RETRAN_RTT	300   //500ms
+#define MAX_RTT         500
+
+#define DNS_TIME            10
+#define CALC_DEV_SPEED_TIME 1
+#define DOWNLOAD_SPEED_TIME 2
+#define RECALC_WEIGHT_TIME  5    //5 seconds to recalc weight
+#define MAX_SYN_NEW_COUNT   10   //statitis new syn count max number
+#define LITTLE_FLOW_TIME    60   //small flow detect time internal
+
+#define ADJUST_SPEED_NUM    5
+#define DOWNLOAD_SPEED      200   // download speed level min
+#define VIDEO_SPEED         300
+#define DUAL_WLAN_MAX_DOWNLOAD_SPEED      2200   // 2MB/S
+
+#define MAX_CELLULAR_SPEED  500  //LTE CALC WEITHT MAX SPEED
+#define MAX_WLAN_SPEED      1000  //WIFI CALC WEITHT MAX SPEED
+#define LOW_RSSI_MAX_WLAN_SPEED 500
+
+
+#define CALC_WEIGHT_MIN_SPEED_1 10 //10KB/s
+#define CALC_WEIGHT_MIN_SPEED_2 50 //50KB/s
+#define CALC_WEIGHT_MIN_SPEED_3 100 //100KB/s
+
+#define GAME_NUM 7
+#define IFACE_NUM 3
+#define IFACE_LEN 16
+#define WHITE_APP_BASE    100
+#define DUAL_STA_APP_BASE 200
+#define WHITE_APP_NUM     64
+#define DUAL_STA_APP_NUM  256
+#define MAX_GAME_RTT      300
+#define MAX_DETECT_PKTS  100
+#define UDP_RX_WIN_SIZE   20
+#define TCP_RX_WIN_SIZE   5
+#define TCP_DOWNLOAD_THRESHOLD  (100*1024)    //100KB/s
+#define SLA_TIMER_EXPIRES HZ
+#define MINUTE_LITTE_RATE  60     //60Kbit/s
+#define INIT_APP_TYPE      0
+#define UNKNOW_APP_TYPE    -1
+#define WLAN_SCORE_BAD_NUM 5
+#define GAME_SKB_TIME_OUT  120  //120s
+#define WLAN_SCORE_GOOD    75
+#define WLAN_SCORE_BAD      55
+#define DUAL_WLAN_SCORE_BAD 55
+#define DNS_MAX_NUM         10
+#define WLAN_NETWORK_INVALID 10
+
+#define MIN_GAME_RTT       10 //ms
+#define ENABLE_TO_USER_TIMEOUT 25 //second
+
+#define MAX_FIXED_VALUE_LEN     20
+
+
+/* dev info struct
+  * if we need to consider wifi RSSI ?if we need consider screen state?
+*/
+struct oplus_dev_info{
+	bool need_up;
+	bool need_disable;
+	int max_speed;    //KB/S
+	int download_speed;    //KB/S
+	int dl_mx_speed;
+	int download_num;
+	int little_speed_num;
+	int tmp_little_speed;
+	int dl_little_speed; //for detect little speed
+	int dual_wifi_download;
+	int current_speed;
+	int left_speed;
+	int minute_speed; //kbit/s
+	int download_flag;
+	int congestion_flag;
+	int if_up;
+	int syn_retran;
+	int wlan_score;
+	int wlan_score_bad_count;
+	int weight;
+	int weight_state;
+	int rtt_index;
+	u32 mark;
+	u32 avg_rtt;
+	u32 sum_rtt;     //ms
+	u32 sla_rtt_num;     //ms
+	u32 sla_sum_rtt;     //ms
+	u32 sla_avg_rtt;     //ms
+	u64 total_bytes;
+	u64 minute_rx_bytes;
+	u64 dl_total_bytes;
+	char dev_name[IFACE_LEN];
+};
+
+struct oplus_speed_calc{
+	int speed;
+	int speed_done;
+	int ms_speed_flag;
+	u64	rx_bytes;
+	u64 bytes_time;
+	u64 first_time;
+	u64 last_time;
+	u64 sum_bytes;
+};
+
+struct oplus_sla_game_info{
+	u32 game_type;
+	u32 uid;
+	u32 rtt;
+	u32 mark;
+	u32 switch_time;
+	u32 rtt_150_num;
+	u32 rtt_200_num;
+	u32 rtt_250_num;
+	u64 rtt_normal_num;
+	u64 cell_bytes;
+};
+
+
+struct oplus_white_app_info{
+    u32 count;
+    u32 uid[WHITE_APP_NUM];
+	u64 cell_bytes[WHITE_APP_NUM];
+	u64 cell_bytes_normal[WHITE_APP_NUM];
+};
+
+struct oplus_dual_sta_info{
+    u32 count;
+    u32 uid[DUAL_STA_APP_NUM];
+};
+
+
+struct oplus_game_online{
+	bool game_online;
+	struct timeval last_game_skb_tv;
+	u32 udp_rx_pkt_count;   //count of all received game udp packets
+	u64 tcp_rx_byte_count;  //count of all received game tcp bytes
+};
+
+struct game_traffic_info{
+	bool game_in_front;
+	u32 udp_rx_packet[UDP_RX_WIN_SIZE]; //udp packets received per second
+	u64 tcp_rx_byte[TCP_RX_WIN_SIZE];   //tcp bytes received per second
+	u32 window_index;
+	u32 udp_rx_min; //min rx udp packets as valid game udp rx data
+	u32 udp_rx_low_thr; //udp rx packet count low threshold
+	u32 in_game_true_thr;  //greater than this -> inGame==true
+	u32 in_game_false_thr;  //less than this -> inGame==false
+	u32 rx_bad_thr; //greater than this -> game_rx_bad==true
+};
+
+struct oplus_syn_retran_statistic{
+	u32 syn_retran_num;
+	u32 syn_total_num;
+};
+
+struct sla_dns_statistic{
+    bool in_timer;
+	u32 send_num;
+    struct timeval last_tv;
+};
+
+struct oplus_rate_limit_info{
+	int front_uid;
+	int rate_limit_enable; //oplus_rate_limit enable or not
+	int disable_rtt_num;
+	int disable_rtt_sum;
+	int disable_rtt;  //oplus_rate_limit disable front avg rtt
+	int enable_rtt_num;
+	int enable_rtt_sum;
+	int enable_rtt;  //oplus_rate_limit enable front avg rtt
+	struct timeval last_tv;
+};
+
+struct oplus_sla_rom_update_info{
+	u32 sla_speed;        //sla speed threshold
+	u32 cell_speed;       //cell max speed threshold
+	u32 wlan_speed;       //wlan max speed threshold;
+	u32 wlan_little_score_speed; //wlan little score speed threshold;
+	u32 sla_rtt;          //sla rtt threshold
+	u32 wzry_rtt;         //wzry rtt threshold
+	u32 cjzc_rtt;         //cjzc rtt  threshold
+	u32 wlan_bad_score;   //wifi bad score threshold
+	u32 wlan_good_score;  //wifi good socre threshold
+	u32 second_wlan_speed;       //wlan max speed threshold
+	u32 dual_wlan_download_speed;   //dual wifi download max speed
+	u32 dual_wifi_rtt;          //sla dual wifi rtt threshold
+	u32 dual_wlan_bad_score;   //dual wifi bad score threshold
+};
+
+struct oplus_sla_game_rtt_params {
+	int game_index;
+	int tx_offset;
+	int tx_len;
+	u8  tx_fixed_value[MAX_FIXED_VALUE_LEN];
+	int rx_offset;
+	int rx_len;
+	u8  rx_fixed_value[MAX_FIXED_VALUE_LEN];
+};
+
+struct oplus_smart_bw_rom_update_info {
+	u32 feature_enable;
+	u32 debug_level;
+	u32 ll_com_score_thre;
+	u32 acs_weight_thre;
+	u32 mov_avg_beta;
+	u32 thre_tune_dist;
+	u32 sample_interval;
+	u32 good_mcs;
+	u32 bad_mcs;
+};
+
+enum{
+	SLA_SKB_ACCEPT,
+	SLA_SKB_CONTINUE,
+	SLA_SKB_MARKED,
+	SLA_SKB_REMARK,
+	SLA_SKB_DROP,
+};
+
+enum{
+	SLA_WEIGHT_NORMAL,
+	SLA_WEIGHT_RECOVERY,
+};
+
+enum{
+	WEIGHT_STATE_NORMAL,
+	WEIGHT_STATE_USELESS,
+	WEIGHT_STATE_RECOVERY,
+	WEIGHT_STATE_SCORE_INVALID,
+};
+
+enum{
+	CONGESTION_LEVEL_NORMAL,
+	CONGESTION_LEVEL_MIDDLE,
+	CONGESTION_LEVEL_HIGH,
+};
+
+enum{
+	WLAN_SCORE_LOW,
+	WLAN_SCORE_HIGH,
+};
+
+
+enum{
+
+	WLAN0_MARK_BIT = 8,            //WLAN mark value,mask 0x0fff
+	WLAN0_MARK = (1 << WLAN0_MARK_BIT),
+
+	WLAN1_MARK_BIT = 9,            //WLAN mark value,mask 0x0fff
+	WLAN1_MARK = (1 << WLAN1_MARK_BIT),
+
+	CELL_MARK_BIT = 10,       //cellular mark value  mask 0x0fff
+	CELL_MARK = (1 << CELL_MARK_BIT),
+
+	RETRAN_BIT = 12,             //first retran mark value,  mask 0xf000
+	RETRAN_MARK = (1 << RETRAN_BIT),
+
+	RETRAN_SECOND_BIT = 13,     //second retran mark value, mask 0xf000
+	RETRAN_SECOND_MARK = (1 << RETRAN_SECOND_BIT),
+
+	RTT_MARK_BIT = 14,          //one ct only statitisc once rtt,mask 0xf000
+	RTT_MARK = (1 << RTT_MARK_BIT),
+
+	GAME_UNSPEC_MARK_BIT = 15,          //mark game skb when game not start
+	GAME_UNSPEC_MARK = (1 << GAME_UNSPEC_MARK_BIT),
+};
+
+
+/*NLMSG_MIN_TYPE is 0x10,so we start at 0x11*/
+enum{
+	SLA_NOTIFY_WIFI_SCORE = 0x11,
+	SLA_NOTIFY_PID = 0x12,
+	SLA_ENABLE = 0x13,
+	SLA_DISABLE = 0x14,
+	SLA_IFACE_CHANGED = 0x15,
+	SLA_NOTIFY_APP_UID = 0x1A,
+	SLA_NOTIFY_GAME_RTT = 0x1B,
+	SLA_NOTIFY_WHITE_LIST_APP = 0x1C,
+	SLA_ENABLED = 0x1D,
+	SLA_DISABLED = 0x1E,
+	SLA_ENABLE_GAME_RTT = 0x1F,
+	SLA_DISABLE_GAME_RTT = 0x20,
+	SLA_NOTIFY_SWITCH_STATE = 0x21,
+	SLA_NOTIFY_SPEED_RTT = 0x22,
+	SLA_SWITCH_GAME_NETWORK  = 0x23,
+	SLA_NOTIFY_SCREEN_STATE	= 0x24,
+	SLA_NOTIFY_CELL_QUALITY	= 0x25,
+	SLA_SHOW_DIALOG_NOW = 0x26,
+	SLA_NOTIFY_SHOW_DIALOG = 0x27,
+	SLA_SEND_WHITE_LIST_APP_TRAFFIC = 0x28,
+	SLA_SEND_GAME_APP_STATISTIC = 0x29,
+	SLA_GET_SYN_RETRAN_INFO = 0x2A,
+	SLA_GET_SPEED_UP_APP = 0x2B,
+	SLA_SET_DEBUG = 0x2C,
+	SLA_NOTIFY_DEFAULT_NETWORK = 0x2D,
+	SLA_NOTIFY_PARAMS = 0x2E,
+	SLA_NOTIFY_GAME_STATE = 0x2F,
+	SLA_NOTIFY_GAME_PARAMS = 0x30,
+	SLA_NOTIFY_GAME_RX_PKT = 0x31,
+	SLA_NOTIFY_GAME_IN_FRONT = 0x32,
+	SLA_NOTIFY_PRIMARY_WIFI = 0x33,
+	SLA_NOTIFY_DUAL_STA_APP = 0x34,
+
+    //Add for WLAN Assistant Four Issues
+	SLA_WEIGHT_BY_WLAN_ASSIST = 0x35,
+    //end add
+	SLA_NOTIFY_VPN_CONNECTED = 0x36,
+	SLA_NOTIFY_DOWNLOAD_APP = 0x37,
+	SLA_NOTIFY_VEDIO_APP = 0x38,
+	SLA_LIMIT_SPEED_ENABLE = 0x39,
+	SLA_LIMIT_SPEED_DISABLE = 0x40,
+	SLA_LIMIT_SPEED_FRONT_UID = 0x41,
+	SMART_BW_SET_PARAMS = 0x42,
+};
+
+
+enum{
+	GAME_SKB_DETECTING = 0,
+	GAME_SKB_COUNT_ENOUGH = 1,
+	GAME_RTT_STREAM = 2,
+	GAME_VOICE_STREAM = 4,
+};
+
+enum{
+	GAME_UNSPEC = 0,
+	GAME_WZRY = 1,
+	GAME_CJZC,
+	GAME_QJCJ,
+	GAME_HYXD_NM,
+	GAME_HYXD,
+	GAME_HYXD_ALI,
+};
+
+enum{
+	SLA_MODE_INIT = 0,
+	SLA_MODE_DUAL_WIFI = 1,
+
+	/*if the dual wifi is enable,please do not send
+	disable msg to kernel when rcv SLA_MODE_WIFI_CELL msg*/
+	SLA_MODE_WIFI_CELL = 2,
+	SLA_MODE_DUAL_WIFI_CELL = 3,
+
+	SLA_MODE_FINISH = 4,
+};
+
+
+enum{
+	DISABLE_DUAL_WIFI = 1,
+	DISABLE_WIFI_CELL = 2,
+};
+
+//add for dual sta DCS
+enum{
+	INIT_ACTIVE_TYPE,
+	LOW_SPEED_HIGH_RTT,
+	LOW_WLAN_SCORE,
+	LOW_DL_SPEED,
+	WLAN_DOWNLOAD,
+};
+
+static bool enable_cell_to_user = 0;
+static bool enable_second_wifi_to_user = 0;
+static int oplus_sla_vpn_connected = 0;
+static int game_mark = 0;
+static bool inGame = false;
+static bool game_cell_to_wifi = false;
+static bool game_rx_bad = false;
+static int udp_rx_show_toast = 0;
+static int game_rtt_show_toast = 0;
+int tee_use_src = 0;
+static int oplus_sla_enable;
+static int oplus_sla_debug = 0;
+static int oplus_sla_calc_speed;
+static int oplus_sla_def_net = 0;    //WLAN0->0 WLAN1->1 CELL->2
+static int send_show_dailog_msg = 0;
+static int game_start_state[GAME_NUM];
+static int MAIN_WLAN = WLAN0_INDEX;
+static int SECOND_WLAN = WLAN1_INDEX;
+static int MAIN_WLAN_MARK = WLAN0_MARK;
+static int SECOND_WLAN_MARK = WLAN1_MARK;
+static int main_wlan_download = 1;
+//add for android Q statictis tcp tx and tx
+static u64 wlan0_tcp_tx = 0;
+static u64 wlan0_tcp_rx = 0;
+static u64 wlan1_tcp_tx = 0;
+static u64 wlan1_tcp_rx = 0;
+
+static int sla_work_mode = SLA_MODE_INIT;
+static int sla_detect_mode = SLA_MODE_DUAL_WIFI;
+
+static int init_weight_delay_count = 0;
+static int dual_wifi_active_type = 0;
+
+static bool dual_wifi_switch_enable = true;
+static bool sla_switch_enable = false;
+static bool sla_screen_on = true;
+static bool cell_quality_good = true;
+static bool need_show_dailog = true;
+
+static volatile u32 oplus_sla_pid;
+static struct sock *oplus_sla_sock;
+static struct timer_list sla_timer;
+
+static struct timeval last_speed_tv;
+static struct timeval last_weight_tv;
+static struct timeval last_minute_speed_tv;
+static struct timeval last_download_speed_tv;
+static struct timeval last_enable_cellular_tv;
+static struct timeval calc_wlan_rtt_tv;
+static struct timeval last_enable_second_wifi_tv;
+static struct timeval last_enable_cell_tv;
+
+static struct timeval last_show_daillog_msg_tv;
+static struct timeval last_calc_small_speed_tv;
+
+static struct sla_dns_statistic dns_info[IFACE_NUM];
+static struct oplus_rate_limit_info rate_limit_info;
+static struct oplus_game_online game_online_info;
+static struct oplus_white_app_info white_app_list;
+static struct oplus_dual_sta_info dual_wifi_app_list;
+static struct oplus_dual_sta_info download_app_list;
+static struct oplus_dual_sta_info vedio_app_list;
+static struct oplus_sla_game_info game_uid[GAME_NUM];
+static struct oplus_dev_info oplus_sla_info[IFACE_NUM];
+static struct oplus_speed_calc oplus_speed_info[IFACE_NUM];
+static struct oplus_syn_retran_statistic syn_retran_statistic;
+
+static struct work_struct oplus_sla_work;
+static struct workqueue_struct *workqueue_sla;
+
+static DEFINE_MUTEX(sla_netlink_mutex);
+static struct ctl_table_header *oplus_sla_table_hrd;
+
+/*we statistic rtt when tcp state is TCP_ESTABLISHED,for somtimes(when the network has qos to let syn pass first)
+  * the three handshark (syn-synack) rtt is  good but the network is worse.
+*/
+extern void (*statistic_dev_rtt)(struct sock *sk,long rtt);
+
+/*sometimes when skb reject by iptables,
+*it will retran syn which may make the rtt much high
+*so just mark the stream(ct) with mark IPTABLE_REJECT_MARK when this happens
+*/
+extern void (*mark_streams_for_iptables_reject)(struct sk_buff *skb,enum ipt_reject_with);
+
+
+static rwlock_t sla_lock;
+static rwlock_t sla_rtt_lock;
+static rwlock_t sla_game_lock;
+
+
+#define sla_read_lock() 			read_lock_bh(&sla_lock);
+#define sla_read_unlock() 			read_unlock_bh(&sla_lock);
+#define sla_write_lock() 			write_lock_bh(&sla_lock);
+#define sla_write_unlock()			write_unlock_bh(&sla_lock);
+
+#define sla_rtt_write_lock() 		write_lock_bh(&sla_rtt_lock);
+#define sla_rtt_write_unlock()		write_unlock_bh(&sla_rtt_lock);
+
+#define sla_game_write_lock() 		write_lock_bh(&sla_game_lock);
+#define sla_game_write_unlock()		write_unlock_bh(&sla_game_lock);
+
+
+static struct oplus_sla_rom_update_info rom_update_info ={
+	.sla_speed = 200,
+	.cell_speed = MAX_CELLULAR_SPEED,
+	.wlan_speed = MAX_WLAN_SPEED,
+	.wlan_little_score_speed = LOW_RSSI_MAX_WLAN_SPEED,
+	.sla_rtt = 230, /*test with 230ms*/
+	.wzry_rtt = 200,
+	.cjzc_rtt = 220,
+	.wlan_bad_score = WLAN_SCORE_BAD,
+	.wlan_good_score = WLAN_SCORE_GOOD,
+	.second_wlan_speed = (2 * MAX_WLAN_SPEED),
+	.dual_wlan_download_speed = DUAL_WLAN_MAX_DOWNLOAD_SPEED,
+	.dual_wifi_rtt = 200,
+	.dual_wlan_bad_score = DUAL_WLAN_SCORE_BAD,
+};
+
+static struct oplus_sla_game_rtt_params game_params[GAME_NUM];
+
+static struct game_traffic_info default_traffic_info = {
+	.game_in_front = 0,
+	//.udp_rx_packet[UDP_RX_WIN_SIZE];
+	//.tcp_rx_byte[TCP_RX_WIN_SIZE];
+	.window_index = 0,
+	.udp_rx_min = 3,
+	.udp_rx_low_thr = 12,
+	.in_game_true_thr = 15,
+	.in_game_false_thr = 10,
+	.rx_bad_thr = 4,
+};
+
+static struct game_traffic_info wzry_traffic_info = {
+	.game_in_front = 0,
+	//.udp_rx_packet[UDP_RX_WIN_SIZE];
+	//.tcp_rx_byte[TCP_RX_WIN_SIZE];
+	.window_index = 0,
+	.udp_rx_min = 3,
+	.udp_rx_low_thr = 12,
+	.in_game_true_thr = 15,
+	.in_game_false_thr = 10,
+	.rx_bad_thr = 4,
+};
+
+static struct game_traffic_info cjzc_traffic_info = {
+	.game_in_front = 0,
+	//.udp_rx_packet[UDP_RX_WIN_SIZE];
+	//.tcp_rx_byte[TCP_RX_WIN_SIZE];
+	.window_index = 0,
+	.udp_rx_min = 3,
+	.udp_rx_low_thr = 14,
+	.in_game_true_thr = 15,
+	.in_game_false_thr = 10,
+	.rx_bad_thr = 4,
+};
+
+/* for Smart BW RUS related */
+static struct oplus_smart_bw_rom_update_info smart_bw_rom_update_info;
+static bool get_smartbw_romupdate = false;
+static int oplus_smart_bw_set_params(struct nlmsghdr *nlh)
+{
+	u32* params = (u32 *)NLMSG_DATA(nlh);
+	u32 count = (nlh)->nlmsg_len - NLMSG_HDRLEN; /* this is in fact the payload length which already aligned */
+	if (1) {
+	        printk("oplus_smart_bw_set_params: (nlh)->nlmsg_len = %u, NLMSG_HDRLEN=%d,"
+	                "NLMSG_PAYLOAD(nlh, NLMSG_HDRLEN) = %u, sizeof(oplus_smart_bw_rom) = %lu",
+	                (nlh)->nlmsg_len, NLMSG_HDRLEN, count, sizeof(struct oplus_smart_bw_rom_update_info));
+	}
+#if 1
+	if (count == sizeof(struct oplus_smart_bw_rom_update_info)) {
+#endif
+		get_smartbw_romupdate = true;
+		smart_bw_rom_update_info.feature_enable = params[0];
+		smart_bw_rom_update_info.debug_level = params[1];
+		smart_bw_rom_update_info.ll_com_score_thre = params[2];
+		smart_bw_rom_update_info.acs_weight_thre = params[3];
+		smart_bw_rom_update_info.mov_avg_beta = params[4];
+		smart_bw_rom_update_info.thre_tune_dist = params[5];
+		smart_bw_rom_update_info.sample_interval = params[6];
+		smart_bw_rom_update_info.good_mcs = params[7];
+		smart_bw_rom_update_info.bad_mcs = params[8];
+		if (smart_bw_rom_update_info.debug_level == 2 && oplus_sla_debug) {
+				printk("oplus_smart_bw_set_params:set params count=%d params[0] = %d, params[1] = %d, params[2] = %d, params[3] = %d,"
+						"params[4] = %d, params[5] = %d, params[6] = %d, params[7] = %d, params[8] = %d",
+						count, params[0], params[1], params[2], params[3], params[4],
+						params[5], params[6], params[7], params[8]);
+		}
+#if 1
+	} else {
+		printk("oplus_smart_bw_set_params:set params invalid param count:%d", count);
+	}
+#endif
+	return	0;
+}
+
+/* Get RUS rom update which comes from FWK, true: success */
+bool get_smart_bw_rom_update(int payload[], int len)
+{
+	if (len < sizeof(struct oplus_smart_bw_rom_update_info) / sizeof(int) || !get_smartbw_romupdate) {
+	        if (1) printk("%s target payload len not match or hasn't got ROM update from FWK !\n", __func__);
+	        return false;
+	}
+
+	if (1) printk("%s enter!\n", __func__);
+	memcpy(payload, &smart_bw_rom_update_info, sizeof(struct oplus_smart_bw_rom_update_info));
+
+	if (1) printk("%s exit!\n", __func__);
+	return  true;
+}
+
+EXPORT_SYMBOL(get_smart_bw_rom_update);
+/* send to user space */
+static int oplus_sla_send_to_user(int msg_type,char *payload,int payload_len)
+{
+	int ret = 0;
+	struct sk_buff *skbuff;
+	struct nlmsghdr *nlh;
+
+    if (!oplus_sla_pid) {
+		printk("oplus_sla_netlink: oplus_sla_pid == 0!!\n");
+		return -1;
+	}
+
+	/*allocate new buffer cache */
+	skbuff = alloc_skb(NLMSG_SPACE(payload_len), GFP_ATOMIC);
+	if (skbuff == NULL) {
+		printk("oplus_sla_netlink: skbuff alloc_skb failed\n");
+		return -1;
+	}
+
+	/* fill in the data structure */
+	nlh = nlmsg_put(skbuff, 0, 0, msg_type, NLMSG_ALIGN(payload_len), 0);
+	if (nlh == NULL) {
+		printk("oplus_sla_netlink:nlmsg_put failaure\n");
+		nlmsg_free(skbuff);
+		return -1;
+	}
+
+	//compute nlmsg length
+	nlh->nlmsg_len = NLMSG_HDRLEN + NLMSG_ALIGN(payload_len);
+
+	if(NULL != payload){
+		memcpy((char *)NLMSG_DATA(nlh),payload,payload_len);
+	}
+
+	/* set control field,sender's pid */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0))
+	NETLINK_CB(skbuff).pid = 0;
+#else
+	NETLINK_CB(skbuff).portid = 0;
+#endif
+
+	NETLINK_CB(skbuff).dst_group = 0;
+
+	/* send data */
+	ret = netlink_unicast(oplus_sla_sock, skbuff, oplus_sla_pid, MSG_DONTWAIT);
+	if(ret < 0){
+		printk(KERN_ERR "oplus_sla_netlink: can not unicast skbuff,ret = %d\n",ret);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void calc_network_congestion(void)
+{
+	int i = 0;
+	int avg_rtt = 0;
+	int rtt_num = 2;
+
+	if(oplus_sla_info[MAIN_WLAN].wlan_score <= rom_update_info.wlan_bad_score){
+		rtt_num = 1;
+	}
+
+	sla_rtt_write_lock();
+	for(i = 0; i < IFACE_NUM; i++){
+		if(oplus_sla_info[i].if_up){
+
+			if(oplus_sla_info[i].sla_rtt_num >= rtt_num){
+				avg_rtt = 0;
+				if(oplus_sla_info[i].download_flag < DOWNLOAD_FLAG){
+					avg_rtt = oplus_sla_info[i].sla_sum_rtt / oplus_sla_info[i].sla_rtt_num;
+					oplus_sla_info[i].sla_avg_rtt = avg_rtt;
+				}
+
+				if(oplus_sla_debug){
+				        printk("oplus_sla_rtt: sla rtt ,num = %d,sum = %d,avg rtt[%d] = %d\n",
+					 		oplus_sla_info[i].sla_rtt_num,oplus_sla_info[i].sla_sum_rtt,i,avg_rtt);
+				}
+
+				oplus_sla_info[i].sla_rtt_num = 0;
+				oplus_sla_info[i].sla_sum_rtt = 0;
+
+				if(avg_rtt >= BACK_OFF_RTT_2){
+
+					oplus_sla_info[i].congestion_flag = CONGESTION_LEVEL_HIGH;
+					oplus_sla_info[i].max_speed /= 2;
+					oplus_sla_info[i].download_speed /= 2;
+				}
+				else if(avg_rtt >= BACK_OFF_RTT_1){
+
+					oplus_sla_info[i].congestion_flag = CONGESTION_LEVEL_MIDDLE;
+					oplus_sla_info[i].max_speed /= 2;
+					oplus_sla_info[i].download_speed /= 2;
+				}
+				else{
+					if(WEIGHT_STATE_NORMAL == oplus_sla_info[i].weight_state){
+						oplus_sla_info[i].congestion_flag = CONGESTION_LEVEL_NORMAL;
+					}
+				}
+			}
+		}
+	}
+	sla_rtt_write_unlock();
+
+	return;
+}
+
+static void init_dual_wifi_weight(void)
+{
+	init_weight_delay_count = 5;
+	if (INIT_ACTIVE_TYPE != dual_wifi_active_type &&
+		(oplus_sla_info[MAIN_WLAN].sla_avg_rtt >= BACK_OFF_RTT_2 ||
+		oplus_sla_info[MAIN_WLAN].max_speed <= CALC_WEIGHT_MIN_SPEED_2)){
+		oplus_sla_info[MAIN_WLAN].weight = 0;
+		oplus_sla_info[SECOND_WLAN].weight = 100;
+	} else if (LOW_SPEED_HIGH_RTT == dual_wifi_active_type ||
+		LOW_WLAN_SCORE == dual_wifi_active_type ||
+		LOW_DL_SPEED == dual_wifi_active_type){
+		oplus_sla_info[MAIN_WLAN].weight = 30;
+		oplus_sla_info[SECOND_WLAN].weight = 100;
+	} else if (WLAN_DOWNLOAD == dual_wifi_active_type){
+	    // for download active
+		oplus_sla_info[MAIN_WLAN].weight = 50;
+		oplus_sla_info[SECOND_WLAN].weight = 100;
+	} else {
+	    // for manual active or networkReuqest
+		init_weight_delay_count = 0;
+		oplus_sla_info[MAIN_WLAN].weight = 100;
+		oplus_sla_info[SECOND_WLAN].weight = 0;
+	}
+	printk("oplus_sla_weight:init_dual_wifi_weight [%d] [%d]",
+		oplus_sla_info[MAIN_WLAN].weight,oplus_sla_info[SECOND_WLAN].weight);
+}
+
+static void init_wifi_cell_weight(void)
+{
+	init_weight_delay_count = 10;
+	oplus_sla_info[MAIN_WLAN].weight = 0;
+	oplus_sla_info[CELL_INDEX].weight = 100;
+	printk("oplus_sla_weight:init_wifi_cell_weight [%d] [%d]",
+		oplus_sla_info[MAIN_WLAN].weight,oplus_sla_info[CELL_INDEX].weight);
+}
+
+static void init_dual_wifi_cell_weight(void)
+{
+	if (oplus_sla_info[MAIN_WLAN].sla_avg_rtt >= BACK_OFF_RTT_2){
+		oplus_sla_info[MAIN_WLAN].weight = 0;
+
+		if (oplus_sla_info[SECOND_WLAN].sla_avg_rtt >= BACK_OFF_RTT_2) {
+			oplus_sla_info[SECOND_WLAN].weight = 0;
+		}
+		else {
+			oplus_sla_info[SECOND_WLAN].weight = 30;
+		}
+
+		oplus_sla_info[CELL_INDEX].weight = 100;
+	} else {
+
+		if (oplus_sla_info[SECOND_WLAN].sla_avg_rtt >= BACK_OFF_RTT_2) {
+			oplus_sla_info[MAIN_WLAN].weight = 30;
+			oplus_sla_info[SECOND_WLAN].weight = 0;
+		}
+		else {
+			oplus_sla_info[MAIN_WLAN].weight = 15;
+			oplus_sla_info[SECOND_WLAN].weight = 30;
+		}
+		oplus_sla_info[CELL_INDEX].weight = 100;
+	}
+}
+
+static void init_oplus_sla_weight(struct timeval tv,int work_mode)
+{
+	last_weight_tv = tv;
+
+	if (SLA_MODE_DUAL_WIFI == work_mode) {
+		init_dual_wifi_weight();
+	}
+	else if (SLA_MODE_WIFI_CELL == work_mode) {
+		init_wifi_cell_weight();
+	}
+	else if (SLA_MODE_DUAL_WIFI_CELL == work_mode) {
+		init_dual_wifi_cell_weight();
+	}
+}
+
+static void send_enable_to_framework(int enable_mode,int active_type)
+{
+	int payload[2];
+	if (SLA_MODE_DUAL_WIFI == enable_mode) {
+		enable_second_wifi_to_user = true;
+		do_gettimeofday(&last_enable_second_wifi_tv);
+	}
+	else if (SLA_MODE_WIFI_CELL == enable_mode) {
+		enable_cell_to_user = true;
+		do_gettimeofday(&last_enable_cell_tv);
+	}
+
+	if(oplus_sla_info[MAIN_WLAN].need_up){
+		oplus_sla_info[MAIN_WLAN].if_up = 1;
+	}
+
+	if(oplus_sla_info[SECOND_WLAN].need_up){
+		oplus_sla_info[SECOND_WLAN].if_up = 1;
+	}
+
+	payload[0] = enable_mode;
+	payload[1] = active_type;
+	oplus_sla_send_to_user(SLA_ENABLE,(char *)payload,sizeof(payload));
+	printk("oplus_sla_netlink:mode[%d] [%d] send SLA_ENABLE to user\n",enable_mode, active_type);
+}
+
+static int enable_oplus_sla_module(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+	int enable_type = data[0];
+	struct timeval tv;
+
+	sla_write_lock();
+
+	do_gettimeofday(&tv);
+	last_enable_cellular_tv = tv;
+	init_oplus_sla_weight(tv,enable_type);
+
+	oplus_sla_enable = 1;
+	sla_work_mode = enable_type;
+	if (SLA_MODE_DUAL_WIFI == enable_type) {
+		sla_detect_mode = SLA_MODE_WIFI_CELL;
+	}
+	else if (SLA_MODE_WIFI_CELL == enable_type) {
+		sla_detect_mode = SLA_MODE_FINISH;
+	}
+
+	printk("oplus_sla_netlink: enable type = %d\n",enable_type);
+	oplus_sla_send_to_user(SLA_ENABLED, (char *)&enable_type, sizeof(int));
+
+	sla_write_unlock();
+	return 0;
+}
+
+static int enable_oplus_limit_speed()
+{
+	sla_write_lock();
+	rate_limit_info.rate_limit_enable = 1;
+	printk("enable_oplus_limit_speed ");
+	sla_write_unlock();
+	return 0;
+}
+
+static int disable_oplus_limit_speed()
+{
+	sla_write_lock();
+	rate_limit_info.rate_limit_enable = 0;
+	printk("disable_oplus_limit_speed ");
+	sla_write_unlock();
+	return 0;
+}
+
+static int oplus_limit_uid_changed(struct nlmsghdr *nlh)
+{
+	int uid = -1;
+	int *data = (int *)NLMSG_DATA(nlh);
+	uid = data[0];
+	printk("oplus_limit_uid_changed uid:%d\n", uid);
+	sla_write_lock();
+	rate_limit_info.front_uid = uid;
+	sla_write_unlock();
+
+	return 0;
+}
+
+//add for rate limit function to statistics front uid rtt
+static void statistics_front_uid_rtt(int rtt,struct sock *sk)
+{
+	kuid_t uid;
+	const struct file *filp = NULL;
+	if(sk && sk_fullsock(sk)){
+
+		if(NULL == sk->sk_socket){
+			return;
+		}
+
+		filp = sk->sk_socket->file;
+		if(NULL == filp){
+			return;
+		}
+
+		if(rate_limit_info.front_uid){
+			uid = make_kuid(&init_user_ns, rate_limit_info.front_uid);
+			if(uid_eq(filp->f_cred->fsuid, uid)){
+				if(rate_limit_info.rate_limit_enable){
+					rate_limit_info.enable_rtt_num++;
+					rate_limit_info.enable_rtt_sum += rtt;
+				} else{
+					rate_limit_info.disable_rtt_num++;
+					rate_limit_info.disable_rtt_sum += rtt;
+				}
+			}
+		}
+	}
+	return;
+}
+
+static void calc_rtt_by_dev_index(int index, int tmp_rtt, struct sock *sk)
+{
+
+	/*do not calc rtt when the screen is off which may make the rtt too big
+	*/
+	if(!sla_screen_on){
+	   return;
+	}
+
+	if(tmp_rtt < 30) {
+		return;
+	}
+
+	if(tmp_rtt > MAX_RTT){
+		tmp_rtt = MAX_RTT;
+	}
+
+	sla_rtt_write_lock();
+
+	statistics_front_uid_rtt(tmp_rtt,sk);
+
+	if(!rate_limit_info.rate_limit_enable){
+		oplus_sla_info[index].rtt_index++;
+		oplus_sla_info[index].sum_rtt += tmp_rtt;
+	}
+
+	sla_rtt_write_unlock();
+	return;
+
+}
+
+
+static int find_dev_index_by_mark(__u32 mark)
+{
+	int i;
+
+	for(i = 0; i < IFACE_NUM; i++){
+		if(oplus_sla_info[i].if_up &&
+			mark == oplus_sla_info[i].mark){
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int calc_retran_syn_rtt(struct sk_buff *skb, struct nf_conn *ct)
+{
+	int index = -1;
+	int ret = SLA_SKB_CONTINUE;
+	int tmp_mark = ct->mark & MARK_MASK;
+	int rtt_mark = ct->mark & RTT_MASK;
+
+	if(rtt_mark & RTT_MARK){
+		skb->mark = ct->mark;
+		return SLA_SKB_MARKED;
+	}
+
+	index = find_dev_index_by_mark(tmp_mark);
+
+	if(-1 != index) {
+
+		calc_rtt_by_dev_index(index, SYN_RETRAN_RTT, NULL);
+
+		//oplus_sla_info[index].syn_retran++;
+		syn_retran_statistic.syn_retran_num++;
+
+		ct->mark |= RTT_MARK;
+		skb->mark = ct->mark;
+
+		ret = SLA_SKB_MARKED;
+	}
+
+	syn_retran_statistic.syn_total_num++;
+
+	return ret;
+}
+
+/*
+LAN IP:
+A:10.0.0.0-10.255.255.255
+B:172.16.0.0-172.31.255.255
+C:192.168.0.0-192.168.255.255
+*/
+static bool dst_is_lan_ip(struct sk_buff *skb)
+{
+	struct iphdr *iph = NULL;
+	unsigned char *dstip = NULL;
+
+	iph = ip_hdr(skb);
+	if (NULL != iph) {
+		dstip = (unsigned char *)&iph->daddr;
+		if ((10 == dstip[0]) ||
+			(192 == dstip[0] && 168 == dstip[1]) ||
+			(172 == dstip[0] && dstip[1] >= 16 && dstip[1] <= 31)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/*icsk_syn_retries*/
+static int syn_retransmits_packet_do_specail(struct sock *sk,
+				struct nf_conn *ct,
+				struct sk_buff *skb)
+{
+
+	int ret = SLA_SKB_CONTINUE;
+	struct iphdr *iph;
+	struct tcphdr *th = NULL;
+
+	if((iph = ip_hdr(skb)) != NULL &&
+		iph->protocol == IPPROTO_TCP){
+
+		th = tcp_hdr(skb);
+		//only statictis SYN retran packet, sometimes some RST packets also arrive here
+		if(NULL != th && th->syn &&
+		   !th->rst && !th->ack && !th->fin){
+
+			ret = calc_retran_syn_rtt(skb, ct);
+		}
+	}
+
+	return ret;
+}
+
+
+static bool is_download_app(kuid_t app_uid)
+{
+	int i = 0;
+	kuid_t uid;
+
+	for(i = 0;i < download_app_list.count;i++){
+		if(download_app_list.uid[i]){
+			uid = make_kuid(&init_user_ns,download_app_list.uid[i]);
+			if(uid_eq(app_uid, uid)){
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+static int mark_download_app(struct sock *sk,
+				kuid_t app_uid,
+				struct nf_conn *ct,
+				struct sk_buff *skb)
+{
+	int choose_mark = 0;
+	int ret = SLA_SKB_CONTINUE;
+
+	if (SLA_MODE_DUAL_WIFI == sla_work_mode &&
+		is_download_app(app_uid)) {
+		// for manual active
+		if (INIT_ACTIVE_TYPE == dual_wifi_active_type) {
+			if ((oplus_sla_info[MAIN_WLAN].max_speed < CALC_WEIGHT_MIN_SPEED_3 &&
+				oplus_sla_info[SECOND_WLAN].max_speed < CALC_WEIGHT_MIN_SPEED_3 &&
+				oplus_sla_info[MAIN_WLAN].sla_avg_rtt < NORMAL_RTT) ||
+				(oplus_sla_info[MAIN_WLAN].download_flag < DOWNLOAD_FLAG &&
+				oplus_sla_info[MAIN_WLAN].download_speed >= DUAL_WLAN_MAX_DOWNLOAD_SPEED)) {
+
+				choose_mark= MAIN_WLAN_MARK;
+
+			} else if (100 == oplus_sla_info[MAIN_WLAN].weight &&
+				oplus_sla_info[MAIN_WLAN].download_flag >= DOWNLOAD_FLAG &&
+				oplus_sla_info[SECOND_WLAN].download_flag < DOWNLOAD_FLAG) {
+				choose_mark = SECOND_WLAN_MARK;
+			}
+		} else {
+			if ((init_weight_delay_count > 0 &&
+				oplus_sla_info[SECOND_WLAN].download_flag < DOWNLOAD_FLAG) ||
+				(oplus_sla_info[MAIN_WLAN].download_flag < DOWNLOAD_FLAG &&
+				 oplus_sla_info[SECOND_WLAN].download_flag < DOWNLOAD_FLAG &&
+				 oplus_sla_info[MAIN_WLAN].download_speed >= MAX_WLAN_SPEED &&
+				 oplus_sla_info[SECOND_WLAN].download_speed >= MAX_WLAN_SPEED)) {
+				if (main_wlan_download) {
+					main_wlan_download = 0;
+					choose_mark = MAIN_WLAN_MARK;
+				} else if (!main_wlan_download) {
+					main_wlan_download = 1;
+					choose_mark = SECOND_WLAN_MARK;
+				}
+			}
+		}
+	}
+
+	if (choose_mark) {
+		skb->mark = choose_mark;
+		ct->mark = skb->mark;
+		sk->oplus_sla_mark = skb->mark;
+		//sk->sk_mark = sk->oplus_sla_mark;
+		return SLA_SKB_MARKED;
+	}
+
+	return ret;
+}
+
+static bool is_vedio_app(kuid_t app_uid)
+{
+	int i = 0;
+	kuid_t uid;
+
+	for(i = 0;i < vedio_app_list.count;i++){
+		if(vedio_app_list.uid[i]){
+			uid = make_kuid(&init_user_ns,vedio_app_list.uid[i]);
+			if(uid_eq(app_uid, uid)){
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+static int mark_video_app(struct sock *sk,
+				kuid_t app_uid,
+				struct nf_conn *ct,
+				struct sk_buff *skb)
+{
+	int choose_mark = 0;
+	int ret = SLA_SKB_CONTINUE;
+
+	if (SLA_MODE_DUAL_WIFI == sla_work_mode &&
+		is_vedio_app(app_uid)) {
+		if (oplus_sla_info[MAIN_WLAN].download_speed >= MAX_WLAN_SPEED) {
+
+			choose_mark = MAIN_WLAN_MARK;
+
+		} else if (oplus_sla_info[SECOND_WLAN].download_speed > MAX_WLAN_SPEED ||
+			     (oplus_sla_info[MAIN_WLAN].download_speed <= VIDEO_SPEED &&
+			 ((init_weight_delay_count > 0 && oplus_sla_info[MAIN_WLAN].dl_little_speed < DOWNLOAD_SPEED) ||
+			(oplus_sla_info[SECOND_WLAN].download_speed > VIDEO_SPEED && oplus_sla_info[SECOND_WLAN].sla_avg_rtt <= 150)))) {
+
+			choose_mark= SECOND_WLAN_MARK;
+		}
+	}
+
+	if (choose_mark) {
+		skb->mark = choose_mark;
+		ct->mark = skb->mark;
+		sk->oplus_sla_mark = skb->mark;
+		//sk->sk_mark = sk->oplus_sla_mark;
+		return SLA_SKB_MARKED;
+	}
+
+	return ret;
+}
+
+
+static void is_http_get(struct nf_conn *ct,struct sk_buff *skb,
+				struct tcphdr *tcph,int header_len)
+{
+
+	u32 *payload = NULL;
+	payload =(u32 *)(skb->data + header_len);
+
+	if(0 == ct->oplus_http_flag && (80 == ntohs(tcph->dest))){
+
+		if(	*payload == 0x20544547){//http get
+
+			ct->oplus_http_flag = 1;
+			ct->oplus_skb_count = 1;
+		}
+	}
+
+	return;
+}
+
+static struct tcphdr * is_valid_http_packet(struct sk_buff *skb, int *header_len)
+{
+	int datalen = 0;
+	int tmp_len = 0;
+	struct tcphdr *tcph = NULL;
+	struct iphdr *iph;
+
+	if((iph = ip_hdr(skb)) != NULL &&
+		iph->protocol == IPPROTO_TCP){
+
+		tcph = tcp_hdr(skb);
+		datalen = ntohs(iph->tot_len);
+		tmp_len = iph->ihl * 4 + tcph->doff * 4;
+
+		if((datalen - tmp_len) > 64){
+			*header_len = tmp_len;
+			return tcph;
+		}
+	}
+	return NULL;
+}
+
+static u32 get_skb_mark_by_weight(void)
+{
+	int i = 0;
+	u32 sla_random = prandom_u32() & 0x7FFFFFFF;
+
+	/*0x147AE15 = 0x7FFFFFFF /100 + 1; for we let the weight * 100 to void
+	  *decimal point operation at linux kernel
+	  */
+	for (i = 0; i < IFACE_NUM; i++) {
+		if (oplus_sla_info[i].if_up &&
+			oplus_sla_info[i].weight) {
+			if (sla_random < (0x147AE15 * oplus_sla_info[i].weight)) {
+				return oplus_sla_info[i].mark;
+			}
+		}
+	}
+
+	return oplus_sla_info[MAIN_WLAN].mark;
+}
+
+static void reset_oplus_sla_calc_speed(struct timeval tv)
+{
+	int time_interval = 0;
+	time_interval = tv.tv_sec - last_calc_small_speed_tv.tv_sec;
+
+	if(time_interval >= 60 &&
+		oplus_speed_info[MAIN_WLAN].speed_done){
+
+		oplus_sla_calc_speed = 0;
+		oplus_speed_info[MAIN_WLAN].speed_done = 0;
+
+	}
+}
+
+static int wlan_get_speed_prepare(struct sk_buff *skb)
+{
+
+	int header_len = 0;
+	struct tcphdr *tcph = NULL;
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	ct = nf_ct_get(skb, &ctinfo);
+
+	if(NULL == ct){
+		return NF_ACCEPT;
+	}
+
+	if(ctinfo == IP_CT_ESTABLISHED){
+		tcph = is_valid_http_packet(skb,&header_len);
+		if(tcph){
+			is_http_get(ct,skb,tcph,header_len);
+		}
+	}
+	return NF_ACCEPT;
+}
+
+
+static int get_wlan_syn_retran(struct sk_buff *skb)
+{
+	int tmp_mark;
+	int rtt_mark;
+	struct iphdr *iph;
+	struct sock *sk = NULL;
+	struct nf_conn *ct = NULL;
+	struct tcphdr *th = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	ct = nf_ct_get(skb, &ctinfo);
+
+	if(NULL == ct){
+		return NF_ACCEPT;
+	}
+
+	if(ctinfo == IP_CT_NEW &&
+		(iph = ip_hdr(skb)) != NULL &&
+		iph->protocol == IPPROTO_TCP){
+
+		th = tcp_hdr(skb);
+		/*only statictis syn retran packet,
+		 * sometimes some rst packet also will be here
+		 */
+		if(NULL != th && th->syn &&
+		   !th->rst && !th->ack && !th->fin){
+
+			/*Some third-party apps will send TCP syn
+			*messages of the Intranet, resulting in retransmission
+			*/
+			if (dst_is_lan_ip(skb)) {
+				ct->mark |= RTT_MARK;
+				return NF_ACCEPT;
+			}
+
+			rtt_mark = ct->mark & RTT_MASK;
+			tmp_mark = ct->mark & MARK_MASK;
+
+			if(rtt_mark & RTT_MARK){
+				return NF_ACCEPT;
+			}
+
+			if(tmp_mark != MAIN_WLAN_MARK) {
+				struct net_device *dev = NULL;
+				dev = skb_dst(skb)->dev;
+
+				if (dev && !memcmp(dev->name,oplus_sla_info[MAIN_WLAN].dev_name,strlen(dev->name))) {
+					if (oplus_sla_debug) {
+						printk("oplus_dev_info: dev name = %s\n",dev->name);
+					}
+
+					ct->mark = MAIN_WLAN_MARK;
+
+					sk = skb_to_full_sk(skb);
+					if(sk) {
+						sk->oplus_sla_mark = MAIN_WLAN_MARK;
+						//sk->sk_mark = sk->oplus_sla_mark;
+					}
+
+					syn_retran_statistic.syn_total_num++;
+				}
+				return NF_ACCEPT;
+			}
+
+			syn_retran_statistic.syn_retran_num++;
+			calc_rtt_by_dev_index(MAIN_WLAN, SYN_RETRAN_RTT, sk);
+
+			ct->mark |= RTT_MARK;
+		}
+	}
+	return NF_ACCEPT;
+}
+
+static void game_rtt_estimator(int game_type, u32 rtt)
+{
+	long m = rtt; /* RTT */
+	int shift = 3;
+	u32 srtt = 0;
+
+	if(game_type &&
+		game_type < GAME_NUM){
+
+		srtt = game_uid[game_type].rtt;
+		if(GAME_WZRY == game_type) {
+			shift = 2;
+		}
+
+		if (srtt != 0) {
+
+			m -= (srtt >> shift);
+			srtt += m;		/* rtt = 7/8 rtt + 1/8 new */
+
+		} else {
+		    //void first time the rtt bigger than 200ms which will switch game network
+		    m = m >> 2;
+			srtt = m << shift;
+
+		}
+		game_uid[game_type].rtt = srtt;
+
+		if(rtt >= 250){
+			game_uid[game_type].rtt_250_num++;
+		}
+		else if(rtt >= 200){
+			game_uid[game_type].rtt_200_num++;
+		}
+		else if(rtt >= 150){
+			game_uid[game_type].rtt_150_num++;
+		}
+		else {
+			game_uid[game_type].rtt_normal_num++;
+		}
+	}
+	return;
+}
+
+static void game_app_switch_network(u32 game_type)
+{
+	int index = -1;
+	u32 game_rtt = 0;
+	u32 uid	= 0;
+	int shift = 3;
+	u32 time_now = 0;
+	int max_rtt = MAX_GAME_RTT;
+	int game_bp_info[4];
+	bool wlan_bad = false;
+
+	if(!oplus_sla_enable){
+		return;
+	}
+
+	if(GAME_WZRY !=	game_type &&
+	   GAME_CJZC != game_type){
+		return;
+	}
+
+	if(oplus_sla_info[MAIN_WLAN].wlan_score_bad_count >= WLAN_SCORE_BAD_NUM){
+		wlan_bad = true;
+	}
+
+	index = game_type;
+	uid = game_uid[game_type].uid;
+
+	if(!game_start_state[index] && !inGame){
+		return;
+	}
+
+	if(GAME_WZRY == game_type) {
+		shift = 2;
+		max_rtt = rom_update_info.wzry_rtt;
+	}
+	else if(GAME_CJZC == game_type){
+		max_rtt = rom_update_info.cjzc_rtt;
+	}
+
+	time_now = ktime_get_ns() / 1000000;
+	game_rtt = game_uid[game_type].rtt >> shift;
+
+	if(cell_quality_good &&
+	   !game_cell_to_wifi &&
+	   (wlan_bad || game_rx_bad || game_rtt >= max_rtt) &&
+	   game_uid[index].mark == MAIN_WLAN_MARK){
+	   if(!game_uid[index].switch_time ||
+	   	 (time_now - game_uid[index].switch_time) > 60000){
+
+		    game_uid[game_type].rtt = 0;
+			game_uid[index].switch_time = time_now;
+			game_uid[index].mark = CELL_MARK;
+
+			memset(game_bp_info,0x0,sizeof(game_bp_info));
+			game_bp_info[0] = game_type;
+			game_bp_info[1] = CELL_MARK;
+			game_bp_info[2] = wlan_bad;
+			game_bp_info[3] = cell_quality_good;
+			oplus_sla_send_to_user(SLA_SWITCH_GAME_NETWORK,(char *)game_bp_info,sizeof(game_bp_info));
+			printk("oplus_sla_game_rtt:uid = %u,game rtt = %u,wlan_bad = %d,game_rx_bad = %d,changing to cellular...\n",
+					uid,game_rtt,wlan_bad,game_rx_bad);
+			return;
+	   }
+	}
+
+	if(!wlan_bad &&
+	   game_uid[index].mark == CELL_MARK && game_rx_bad){
+
+		if(!game_uid[index].switch_time ||
+	   	 (time_now - game_uid[index].switch_time) > 60000){
+
+		    game_uid[game_type].rtt = 0;
+			game_uid[index].switch_time = time_now;
+			game_uid[index].mark = MAIN_WLAN_MARK;
+			game_cell_to_wifi = true;
+
+			memset(game_bp_info,0x0,sizeof(game_bp_info));
+			game_bp_info[0] = game_type;
+			game_bp_info[1] = MAIN_WLAN_MARK;
+			game_bp_info[2] = wlan_bad;
+			game_bp_info[3] = cell_quality_good;
+			oplus_sla_send_to_user(SLA_SWITCH_GAME_NETWORK,(char *)game_bp_info,sizeof(game_bp_info));
+			printk("oplus_sla_game_rtt:uid = %u,game rtt = %u,wlan_bad = %d,game_rx_bad = %d,changing to wlan...\n",
+					uid,game_rtt,wlan_bad,game_rx_bad);
+			return;
+	   }
+	}
+	return;
+}
+
+static bool is_game_rtt_skb(struct nf_conn *ct, struct sk_buff *skb, bool isTx)
+{
+	struct iphdr *iph = NULL;
+	struct udphdr *udph = NULL;
+	u32 header_len;
+	u8 *payload = NULL;
+	u32 gameType = ct->oplus_app_type;
+
+	if (gameType <= 0 || gameType >= GAME_NUM || game_params[gameType].game_index == 0 ||
+		(iph = ip_hdr(skb)) == NULL || iph->protocol != IPPROTO_UDP) {
+		//printk("oplus_sla_game_rtt_detect: not game skb.");
+		return false;
+	}
+
+	if ((isTx && ct->oplus_game_up_count >= MAX_DETECT_PKTS) ||
+		(!isTx && ct->oplus_game_down_count >= MAX_DETECT_PKTS)) {
+		ct->oplus_game_detect_status = GAME_SKB_COUNT_ENOUGH;
+		return false;
+	}
+
+	if (unlikely(skb_linearize(skb))) {
+		return false;
+	}
+	iph = ip_hdr(skb);
+	udph = udp_hdr(skb);
+	header_len = iph->ihl * 4 + sizeof(struct udphdr);
+	payload =(u8 *)(skb->data + header_len);
+	if (isTx) {
+		int tx_offset = game_params[gameType].tx_offset;
+		int tx_len = game_params[gameType].tx_len;
+		//u8  tx_fixed_value[MAX_FIXED_VALUE_LEN];
+		//memcpy(tx_fixed_value, game_params[gameType].tx_fixed_value, MAX_FIXED_VALUE_LEN);
+		if (udph->len >= (tx_offset + tx_len) &&
+			memcmp(payload + tx_offset, game_params[gameType].tx_fixed_value, tx_len) == 0) {
+			if (oplus_sla_debug) {
+				printk("oplus_sla_game_rtt_detect:srcport[%d] this is game RTT Tx skb.\n",ntohs(udph->source));
+			}
+			ct->oplus_game_detect_status |= GAME_RTT_STREAM;
+			return true;
+		}
+	} else {
+		int rx_offset = game_params[gameType].rx_offset;
+		int rx_len = game_params[gameType].rx_len;
+		//u8  rx_fixed_value[MAX_FIXED_VALUE_LEN];
+		//memcpy(rx_fixed_value, game_params[gameType].rx_fixed_value, MAX_FIXED_VALUE_LEN);
+		if (udph->len >= (rx_offset + rx_len) &&
+			memcmp(payload + rx_offset, game_params[gameType].rx_fixed_value, rx_len) == 0) {
+			if (oplus_sla_debug) {
+				printk("oplus_sla_game_rtt_detect: this is game RTT Rx skb.\n");
+			}
+			ct->oplus_game_detect_status |= GAME_RTT_STREAM;
+			return true;
+		}
+	}
+	return false;
+}
+
+static int mark_game_app_skb(struct nf_conn *ct,struct sk_buff *skb,enum ip_conntrack_info ctinfo)
+{
+	int game_index = -1;
+	struct iphdr *iph = NULL;
+	u32 ct_mark = 0;
+	int ret = SLA_SKB_CONTINUE;
+
+	if(ct->oplus_app_type > 0 && ct->oplus_app_type < GAME_NUM){
+		ret = SLA_SKB_ACCEPT;
+		game_index = ct->oplus_app_type;
+
+		if(GAME_WZRY != game_index &&
+		   GAME_CJZC != game_index){
+			return ret;
+		}
+
+		ct_mark = GAME_UNSPEC_MASK & ct->mark;
+		if(!game_start_state[game_index] && !inGame &&
+		   (GAME_UNSPEC_MARK & ct_mark)){
+
+			return SLA_SKB_ACCEPT;
+		}
+
+		iph = ip_hdr(skb);
+		if(iph &&
+		   (IPPROTO_UDP == iph->protocol ||
+		    IPPROTO_TCP == iph->protocol)){
+
+			//WZRY can not switch tcp packets
+			if(GAME_WZRY == game_index &&
+			   IPPROTO_TCP == iph->protocol) {
+				return SLA_SKB_ACCEPT;
+			}
+
+			ct_mark	= ct->mark & MARK_MASK;
+
+			if(GAME_CJZC == game_index &&
+			    IPPROTO_TCP == iph->protocol &&
+			   ((XT_STATE_BIT(ctinfo) & XT_STATE_BIT(IP_CT_ESTABLISHED)) ||
+			    (XT_STATE_BIT(ctinfo) & XT_STATE_BIT(IP_CT_RELATED)))) {
+				if(MAIN_WLAN_MARK == ct_mark && oplus_sla_info[MAIN_WLAN].wlan_score > 40){
+					return SLA_SKB_ACCEPT;
+				}
+				else if(CELL_MARK == ct_mark){
+					skb->mark = CELL_MARK;
+					return SLA_SKB_MARKED;
+				}
+			}
+
+			if (game_mark) {
+			    skb->mark = game_mark;
+			} else {
+			    skb->mark = game_uid[game_index].mark;
+			}
+
+			if(ct_mark && skb->mark &&
+			   ct_mark != skb->mark){
+
+			   printk("oplus_sla_game_rtt:reset game ct proto= %u,srcport = %d,"
+					  "ct dying = %d,ct confirmed = %d,game type = %d,ct mark = %x,skb mark = %x\n",
+					  iph->protocol,ntohs(udp_hdr(skb)->source),
+					  nf_ct_is_dying(ct),nf_ct_is_confirmed(ct),game_index,ct_mark,skb->mark);
+
+			   game_uid[game_index].rtt = 0;
+
+			   if(!nf_ct_is_dying(ct) &&
+				  nf_ct_is_confirmed(ct)){
+					nf_ct_kill(ct);
+					return SLA_SKB_DROP;
+			   }
+			   else{
+					skb->mark = ct_mark;
+					ret = SLA_SKB_MARKED;
+			   }
+			}
+
+			if(!ct_mark){
+				ct->mark = (ct->mark & RTT_MASK) | game_uid[game_index].mark;
+			}
+			ret = SLA_SKB_MARKED;
+		}
+	}
+
+	return ret;
+}
+
+static bool is_game_app_skb(struct nf_conn *ct,struct sk_buff *skb,enum ip_conntrack_info ctinfo)
+{
+	int i = 0;
+	kuid_t uid;
+	struct sock *sk = NULL;
+	struct iphdr *iph = NULL;
+	const struct file *filp = NULL;
+
+	if(INIT_APP_TYPE == ct->oplus_app_type){
+
+		sk = skb_to_full_sk(skb);
+		if(NULL == sk || NULL == sk->sk_socket){
+			return false;
+		}
+
+		filp = sk->sk_socket->file;
+		if(NULL == filp){
+			return false;
+		}
+
+        iph = ip_hdr(skb);
+
+		for(i = 1;i < GAME_NUM;i++){
+			if(game_uid[i].uid){
+				uid = make_kuid(&init_user_ns,game_uid[i].uid);
+				if(uid_eq(filp->f_cred->fsuid, uid)){
+					ct->oplus_app_type = i;
+					if(oplus_sla_enable &&
+					   CELL_MARK == game_uid[i].mark){
+						game_uid[i].cell_bytes += skb->len;
+					}
+					//ct->mark = (ct->mark & RTT_MASK) | game_uid[i].mark;
+					if(!game_start_state[i] && !inGame &&
+						iph && IPPROTO_TCP == iph->protocol){
+						ct->mark = (ct->mark & RTT_MASK) | MAIN_WLAN_MARK;
+						ct->mark |= GAME_UNSPEC_MARK;
+					} else{
+						if (game_mark) {
+						    ct->mark = (ct->mark & RTT_MASK) | game_mark;
+						} else {
+						    ct->mark = (ct->mark & RTT_MASK) | game_uid[i].mark;
+						}
+					}
+					return true;
+				}
+			}
+		}
+	}
+	else if(ct->oplus_app_type > 0 &&
+		ct->oplus_app_type < GAME_NUM){
+		i = ct->oplus_app_type;
+		if(oplus_sla_enable &&
+		   (oplus_sla_def_net == MAIN_WLAN || oplus_sla_def_net == SECOND_WLAN) &&
+		   CELL_MARK == game_uid[i].mark){
+			game_uid[i].cell_bytes += skb->len;
+		}
+		return true;
+	}
+
+	return false;
+
+}
+
+static int detect_game_up_skb(struct sk_buff *skb)
+{
+	struct timeval tv;
+	struct iphdr *iph = NULL;
+	struct nf_conn *ct = NULL;
+	int ret = SLA_SKB_ACCEPT;
+	enum ip_conntrack_info ctinfo;
+
+	if(oplus_sla_vpn_connected){
+		return SLA_SKB_CONTINUE;
+	}
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if(NULL == ct){
+		return SLA_SKB_ACCEPT;
+	}
+
+	if(!is_game_app_skb(ct,skb,ctinfo)){
+		return SLA_SKB_CONTINUE;
+	}
+
+	do_gettimeofday(&tv);
+	game_online_info.game_online = true;
+	game_online_info.last_game_skb_tv = tv;
+
+	//TCP and udp need to switch network
+	ret = SLA_SKB_CONTINUE;
+	iph = ip_hdr(skb);
+	if(iph && IPPROTO_UDP == iph->protocol){
+		if (ct->oplus_game_up_count < MAX_DETECT_PKTS &&
+		        ct->oplus_game_detect_status == GAME_SKB_DETECTING) {
+		        ct->oplus_game_up_count++;
+		}
+		//only udp packet can trigger switching network to avoid updating game with cell.
+		sla_game_write_lock();
+		game_app_switch_network(ct->oplus_app_type);
+		sla_game_write_unlock();
+
+		if (is_game_rtt_skb(ct, skb, true)) {
+			s64 time_now = ktime_get_ns() / 1000000;
+			if (ct->oplus_game_timestamp && time_now - ct->oplus_game_timestamp > 200) {
+				//Tx done and no Rx, we've lost a response pkt
+				ct->oplus_game_lost_count++;
+				sla_game_write_lock();
+				game_rtt_estimator(ct->oplus_app_type, MAX_GAME_RTT);
+				sla_game_write_unlock();
+
+				if(game_rtt_show_toast) {
+					u32 game_rtt = MAX_GAME_RTT;
+					oplus_sla_send_to_user(SLA_NOTIFY_GAME_RTT,(char *)&game_rtt,sizeof(game_rtt));
+				}
+				if(oplus_sla_debug) {
+					u32 shift = 3;
+					if(GAME_WZRY == ct->oplus_app_type) {
+					        shift = 2;
+					}
+					printk("oplus_sla_game_rtt: lost packet!! game_rtt=%u, srtt=%u\n",
+					        MAX_GAME_RTT, game_uid[ct->oplus_app_type].rtt >> shift);
+				}
+			}
+			ct->oplus_game_timestamp = time_now;
+		}
+	}
+
+	return ret;
+}
+
+static bool is_game_voice_packet(struct nf_conn *ct, struct sk_buff *skb)
+{
+	struct iphdr *iph = NULL;
+	struct udphdr *udph = NULL;
+	u32 header_len;
+	u8 *payload = NULL;
+	u8 wzry_fixed_value[2] = {0x55, 0xf4};
+	u32 wzry_offset = 9;
+	u32 wzry_len = 2;
+	u8 cjzc_fixed_value[3] = {0x10, 0x01, 0x01};
+	u32 cjzc_offset = 4;
+	u32 cjzc_len = 3;
+	int game_type = ct->oplus_app_type;
+	//u16 tot_len;
+
+	if (ct->oplus_game_down_count >= MAX_DETECT_PKTS) {
+		ct->oplus_game_detect_status = GAME_SKB_COUNT_ENOUGH;
+		return false;
+	}
+
+	if ((iph = ip_hdr(skb)) != NULL && iph->protocol == IPPROTO_UDP) {
+		if (unlikely(skb_linearize(skb))) {
+			return false;
+		}
+		iph = ip_hdr(skb);
+		udph = udp_hdr(skb);
+		header_len = iph->ihl * 4 + sizeof(struct udphdr);
+		payload =(u8 *)(skb->data + header_len);
+		if (game_type == GAME_WZRY) {
+			if (udph->len >= (wzry_offset + wzry_len) &&
+				memcmp(payload + wzry_offset, wzry_fixed_value, wzry_len) == 0) {	//for cjzc voice pkt
+				//printk("oplus_sla_game_rx_voice:this is voice skb!\n");
+				ct->oplus_game_detect_status |= GAME_VOICE_STREAM;
+				return true;
+			} else {
+				//memcpy(fixed_value, payload + 4, 3);
+				//printk("oplus_sla_game_rx_voice:this is NOT voice skb, value=%02x%02x%02x\n",
+				//        fixed_value[0], fixed_value[1], fixed_value[2]);
+				return false;
+			}
+		} else if (game_type == GAME_CJZC) {
+			if (udph->len >= (cjzc_offset + cjzc_len) &&
+				memcmp(payload + cjzc_offset, cjzc_fixed_value, cjzc_len) == 0) {	//for cjzc voice pkt
+				//printk("oplus_sla_game_rx_voice:this is voice skb!\n");
+				ct->oplus_game_detect_status |= GAME_VOICE_STREAM;
+				return true;
+			} else {
+				//memcpy(fixed_value, payload + 4, 3);
+				//printk("oplus_sla_game_rx_voice:this is NOT voice skb, value=%02x%02x%02x\n",
+				//        fixed_value[0], fixed_value[1], fixed_value[2]);
+				return false;
+			}
+		}
+	}
+	return false;
+}
+
+static void record_sla_app_cell_bytes(struct nf_conn *ct, struct sk_buff *skb)
+{
+	int index = 0;
+	u32 ct_mark = 0x0;
+	//calc game or white list app cell bytes
+	if(oplus_sla_enable &&
+		(oplus_sla_def_net == MAIN_WLAN || oplus_sla_def_net == SECOND_WLAN)){
+		if(ct->oplus_app_type > 0 &&
+			ct->oplus_app_type < GAME_NUM){
+			index = ct->oplus_app_type;
+			if(CELL_MARK == game_uid[index].mark){
+				game_uid[index].cell_bytes += skb->len;
+			}
+		} else if(ct->oplus_app_type >= WHITE_APP_BASE &&
+					ct->oplus_app_type < DUAL_STA_APP_BASE){
+			ct_mark = ct->mark & MARK_MASK;
+			if(CELL_MARK == ct_mark){
+				index = ct->oplus_app_type - WHITE_APP_BASE;
+				if(index < WHITE_APP_NUM){
+					white_app_list.cell_bytes[index] += skb->len;
+				}
+			}
+		}
+	}
+
+	//calc white app cell bytes when sla is not enable
+	if(oplus_sla_info[CELL_INDEX].if_up){
+
+		if(!oplus_sla_info[MAIN_WLAN].if_up || oplus_sla_def_net == CELL_INDEX){
+			if(ct->oplus_app_type >= WHITE_APP_BASE &&
+				ct->oplus_app_type < DUAL_STA_APP_BASE){
+				index = ct->oplus_app_type - WHITE_APP_BASE;
+				if(index < WHITE_APP_NUM){
+					white_app_list.cell_bytes_normal[index] += skb->len;
+				}
+			}
+		}
+	}
+}
+
+//add for android Q statictis tcp tx and tx
+static void statistics_wlan_tcp_tx_rx(const struct nf_hook_state *state,struct sk_buff *skb)
+{
+	struct iphdr *iph;
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+	struct net_device *dev = NULL;
+	unsigned int hook = state->hook;
+
+	if((oplus_sla_info[MAIN_WLAN].if_up || oplus_sla_info[MAIN_WLAN].need_up) &&
+		(iph = ip_hdr(skb)) != NULL && iph->protocol == IPPROTO_TCP){
+
+		ct = nf_ct_get(skb, &ctinfo);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+		if(NULL == ct || (0 == ct->mark)){
+#else
+		if(NULL == ct || nf_ct_is_untracked(ct) || (0 == ct->mark)){
+#endif
+			if (NF_INET_LOCAL_OUT == hook) {
+				dev = skb_dst(skb)->dev;
+			} else if (NF_INET_LOCAL_IN == hook){
+				dev = state->in;
+			}
+
+			if (dev && !memcmp(dev->name,oplus_sla_info[MAIN_WLAN].dev_name,strlen(dev->name))) {
+				if (NF_INET_LOCAL_OUT == hook) {
+					wlan0_tcp_tx++;
+				} else if (NF_INET_LOCAL_IN == hook) {
+					wlan0_tcp_rx++;
+				}
+			} else if (dev && !memcmp(dev->name,oplus_sla_info[SECOND_WLAN].dev_name,strlen(dev->name))) {
+				if (NF_INET_LOCAL_OUT == hook) {
+					wlan1_tcp_tx++;
+				} else if (NF_INET_LOCAL_IN == hook) {
+					wlan1_tcp_rx++;
+				}
+			}
+		} else if (MAIN_WLAN_MARK == (ct->mark & MARK_MASK)) {
+			if (NF_INET_LOCAL_OUT == hook) {
+				wlan0_tcp_tx++;
+			} else if (NF_INET_LOCAL_IN == hook) {
+				wlan0_tcp_rx++;
+			}
+		} else if (SECOND_WLAN_MARK == (ct->mark & MARK_MASK)) {
+			if (NF_INET_LOCAL_OUT == hook) {
+				wlan1_tcp_tx++;
+			} else if (NF_INET_LOCAL_IN == hook) {
+				wlan1_tcp_rx++;
+			}
+		}
+	}
+}
+
+static unsigned int oplus_sla_game_rtt_calc(struct sk_buff *skb)
+{
+	int shift = 3;
+	s64 time_now;
+	u32 game_rtt = 0;
+	struct iphdr *iph = NULL;
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	if(oplus_sla_vpn_connected){
+		return NF_ACCEPT;
+	}
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if(NULL == ct){
+		return NF_ACCEPT;
+	}
+
+	iph = ip_hdr(skb);
+
+
+	//calc game or white list app cell bytes
+	record_sla_app_cell_bytes(ct,skb);
+
+	//calc game app udp packet count(except for voice packets) and tcp bytes
+	if (ct->oplus_app_type > 0 && ct->oplus_app_type < GAME_NUM) {
+		if (iph && IPPROTO_UDP == iph->protocol) {
+			if (ct->oplus_game_down_count < MAX_DETECT_PKTS &&
+				ct->oplus_game_detect_status == GAME_SKB_DETECTING) {
+				ct->oplus_game_down_count++;
+			}
+			if (!is_game_voice_packet(ct, skb)) {
+				game_online_info.udp_rx_pkt_count++;
+			}
+		} else if (iph && IPPROTO_TCP == iph->protocol) {
+			game_online_info.tcp_rx_byte_count += skb->len;
+		}
+	}
+
+	if (is_game_rtt_skb(ct, skb, false)) {
+		time_now = ktime_get_ns() / 1000000;
+		if(ct->oplus_game_timestamp && time_now > ct->oplus_game_timestamp){
+
+			game_rtt = (u32)(time_now - ct->oplus_game_timestamp);
+			if (game_rtt < MIN_GAME_RTT) {
+				if(oplus_sla_debug){
+					printk("oplus_sla_game_rtt:invalid RTT %dms\n", game_rtt);
+				}
+				ct->oplus_game_timestamp = 0;
+				return NF_ACCEPT;
+			}
+
+			ct->oplus_game_timestamp = 0;
+
+			if(game_rtt > MAX_GAME_RTT){
+				game_rtt = MAX_GAME_RTT;
+			}
+
+			if(!enable_cell_to_user &&
+			   !oplus_sla_enable &&
+			   sla_switch_enable &&
+			   cell_quality_good){
+				send_enable_to_framework(SLA_MODE_WIFI_CELL,INIT_ACTIVE_TYPE);
+				printk("oplus_sla_netlink: game app send enable sla to user\n");
+			}
+			if(game_rtt_show_toast) {
+				oplus_sla_send_to_user(SLA_NOTIFY_GAME_RTT,(char *)&game_rtt,sizeof(game_rtt));
+			}
+			ct->oplus_game_lost_count = 0;
+
+			sla_game_write_lock();
+			game_rtt_estimator(ct->oplus_app_type,game_rtt);
+			sla_game_write_unlock();
+
+			if(oplus_sla_debug){
+				if(GAME_WZRY == ct->oplus_app_type) {
+					shift = 2;
+				}
+				printk("oplus_sla_game_rtt: game_rtt=%u, srtt=%u\n", game_rtt, game_uid[ct->oplus_app_type].rtt >> shift);
+			}
+		}
+	}
+
+	return NF_ACCEPT;
+}
+
+
+static bool is_skb_pre_bound(struct sk_buff *skb)
+{
+	u32 pre_mark = skb->mark & 0x10000;
+
+	if(0x10000 == pre_mark){
+		return true;
+	}
+
+	return false;
+}
+
+static bool is_sla_white_or_game_app(struct nf_conn *ct,struct sk_buff *skb)
+{
+
+	if(ct->oplus_app_type > 0 &&
+		ct->oplus_app_type < DUAL_STA_APP_BASE){//game app skb
+		return true;
+	}
+
+	return false;
+}
+
+
+static int sla_skb_reroute(struct sk_buff *skb,struct nf_conn *ct,const struct nf_hook_state *state)
+{
+	int err;
+
+	err = ip_route_me_harder(state->net, skb, RTN_UNSPEC);
+	if (err < 0){
+		return NF_DROP_ERR(err);
+	}
+
+	return NF_ACCEPT;
+}
+
+static void statistic_dns_send_info(int index)
+{
+	struct timeval tv;
+
+	if (dns_info[index].send_num < DNS_MAX_NUM) {
+		dns_info[index].send_num++;
+	}
+	else {
+		do_gettimeofday(&tv);
+		dns_info[index].last_tv = tv;
+		dns_info[index].in_timer = true;
+	}
+	return;
+}
+
+static bool is_need_change_dns_network(int index)
+{
+	bool ret = false;
+
+	if (oplus_sla_info[index].weight &&
+		WEIGHT_STATE_USELESS != oplus_sla_info[index].weight_state &&
+		WEIGHT_STATE_SCORE_INVALID != oplus_sla_info[index].weight_state) {
+
+		if (0 == oplus_sla_info[MAIN_WLAN].weight ||
+			WEIGHT_STATE_USELESS == oplus_sla_info[MAIN_WLAN].weight_state ||
+			WEIGHT_STATE_SCORE_INVALID == oplus_sla_info[MAIN_WLAN].weight_state ||
+			(oplus_sla_info[index].max_speed >= 100 &&
+			 oplus_sla_info[MAIN_WLAN].wlan_score_bad_count >= WLAN_SCORE_BAD_NUM)) {
+
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
+static int dns_skb_need_sla(struct nf_conn *ct,struct sk_buff *skb)
+{
+	int ret = SLA_SKB_CONTINUE;
+	struct iphdr *iph = NULL;
+        int dns_iface = MAIN_WLAN;
+        u_int32_t dns_ct_mark = MAIN_WLAN_MARK;
+
+	iph = ip_hdr(skb);
+	if(NULL != iph &&
+	   (iph->protocol == IPPROTO_TCP || iph->protocol == IPPROTO_UDP) &&
+		53 == ntohs(udp_hdr(skb)->dest)){
+
+		ret = SLA_SKB_ACCEPT;
+
+	    if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+			if (is_need_change_dns_network(SECOND_WLAN)) {
+                //for  the dns packet will do DNAT at iptables,if do DNAT,the packet
+                //will be reroute,so here just mark and accept it
+				dns_iface = SECOND_WLAN;
+				dns_ct_mark = SECOND_WLAN_MARK;
+				skb->mark = SECOND_WLAN_MARK;
+			}
+	    } else if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+			if (is_need_change_dns_network(CELL_INDEX)) {
+
+				dns_iface = CELL_INDEX;
+				dns_ct_mark = CELL_MARK;
+				skb->mark = CELL_MARK;
+			}
+		}
+
+		ct->mark = dns_ct_mark;
+		statistic_dns_send_info(dns_iface);
+	}
+	return ret;
+}
+
+
+static void dns_respond_statistics(struct sk_buff *skb)
+{
+	int index = -1;
+	int tmp_mark = 0;
+	struct iphdr *iph = NULL;
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	if (!oplus_sla_enable) {
+		return;
+	}
+
+	ct = nf_ct_get(skb, &ctinfo);
+
+	if(NULL == ct){
+		return;
+	}
+
+	iph = ip_hdr(skb);
+	if(NULL != iph &&
+		(iph->protocol == IPPROTO_TCP || iph->protocol == IPPROTO_UDP) &&
+		53 == ntohs(udp_hdr(skb)->source)){
+
+		tmp_mark = ct->mark & MARK_MASK;
+		index = find_dev_index_by_mark(tmp_mark);
+
+		if (-1 != index) {
+			if (dns_info[index].send_num) {
+
+			    dns_info[index].send_num = 0;
+				dns_info[index].in_timer = false;
+			}
+		}
+	}
+	return;
+}
+
+static void detect_white_list_app_skb(struct sk_buff *skb)
+{
+	int i = 0;
+	int index = -1;
+	kuid_t uid;
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+	struct sock *sk = NULL;
+	const struct file *filp = NULL;
+
+	ct = nf_ct_get(skb, &ctinfo);
+
+	if(NULL == ct){
+		return;
+	}
+
+	/*when the app type is dual sta app,but the work mode is not
+	   SLA_MODE_DUAL_WIFI, we should detect it is WIFI+CELL white
+	   list app again
+	*/
+	if (SLA_MODE_DUAL_WIFI != sla_work_mode &&
+		ct->oplus_app_type >= DUAL_STA_APP_BASE) {
+		ct->oplus_app_type = INIT_APP_TYPE;
+	}
+
+	if(INIT_APP_TYPE == ct->oplus_app_type){
+		sk = skb_to_full_sk(skb);
+		if(NULL == sk || NULL == sk->sk_socket){
+			return;
+		}
+
+		filp = sk->sk_socket->file;
+		if(NULL == filp){
+			return;
+		}
+
+		for(i = 0;i < white_app_list.count;i++){
+			if(white_app_list.uid[i]){
+				uid = make_kuid(&init_user_ns,white_app_list.uid[i]);
+				if(uid_eq(filp->f_cred->fsuid, uid)){
+					ct->oplus_app_type = i + WHITE_APP_BASE;
+					return;
+				}
+			}
+		}
+
+		//we need to detect the whether it is dual sta white list app
+		if (SLA_MODE_DUAL_WIFI != sla_work_mode) {
+			ct->oplus_app_type = UNKNOW_APP_TYPE;
+		}
+	}
+	else if(ct->oplus_app_type >= WHITE_APP_BASE &&
+			ct->oplus_app_type < DUAL_STA_APP_BASE){
+		/*calc white app cell bytes when sla is not enable,
+		    when the default network is change to cell,we should
+		    disable dual sta from framework
+		*/
+		if(oplus_sla_info[CELL_INDEX].if_up){
+			if(!oplus_sla_info[MAIN_WLAN].if_up ||
+				oplus_sla_def_net == CELL_INDEX){
+				index = ct->oplus_app_type - WHITE_APP_BASE;
+				if(index < WHITE_APP_NUM){
+                    white_app_list.cell_bytes_normal[index] += skb->len;
+				}
+			}
+		}
+	}
+	return;
+}
+
+static bool is_dual_sta_white_app(struct nf_conn *ct,struct sk_buff *skb,kuid_t *app_uid)
+{
+	int i = 0;
+	int last_type = UNKNOW_APP_TYPE;
+	kuid_t uid;
+	struct sock *sk = NULL;
+	const struct file *filp = NULL;
+
+	if (ct->oplus_app_type >= DUAL_STA_APP_BASE) {
+		return true;
+	}
+
+	if(UNKNOW_APP_TYPE != ct->oplus_app_type){
+
+		last_type = ct->oplus_app_type;
+
+		sk = skb_to_full_sk(skb);
+		if(NULL == sk || NULL == sk->sk_socket){
+			return false;
+		}
+
+		filp = sk->sk_socket->file;
+		if(NULL == filp){
+			return false;
+		}
+
+		*app_uid = filp->f_cred->fsuid;
+		for(i = 0;i < dual_wifi_app_list.count;i++){
+			if(dual_wifi_app_list.uid[i]){
+				uid = make_kuid(&init_user_ns,dual_wifi_app_list.uid[i]);
+				if(uid_eq(filp->f_cred->fsuid, uid)){
+					ct->oplus_app_type = i + DUAL_STA_APP_BASE;
+					return true;
+				}
+			}
+		}
+		ct->oplus_app_type = last_type;
+	}
+
+	return false;
+}
+
+static void print_stream_info(struct sk_buff *skb)
+{
+	u32 uid = 0;
+	int srcport = 0;
+	int dstport = 0;
+	unsigned char *dstip;
+
+	struct sock *sk = NULL;
+	struct iphdr *iph = NULL;
+	struct nf_conn *ct = NULL;
+	struct net_device *dev = NULL;
+	enum ip_conntrack_info ctinfo;
+	const struct file *filp = NULL;
+
+	if (oplus_sla_debug) {
+		ct = nf_ct_get(skb, &ctinfo);
+		if(NULL == ct){
+			return;
+		}
+
+		if (ctinfo == IP_CT_NEW) {
+			sk = skb_to_full_sk(skb);
+			if(sk && sk_fullsock(sk)){
+				if(NULL == sk->sk_socket){
+					return;
+				}
+
+				filp = sk->sk_socket->file;
+				if(NULL == filp){
+					return;
+				}
+
+				iph = ip_hdr(skb);
+				if (NULL != iph &&
+		   		   (iph->protocol == IPPROTO_TCP || iph->protocol == IPPROTO_UDP)) {
+
+					dev = skb_dst(skb)->dev;
+					uid = filp->f_cred->fsuid.val;
+					dstport = ntohs(udp_hdr(skb)->dest);
+					srcport = ntohs(udp_hdr(skb)->source);
+					dstip = (unsigned char *)&iph->daddr;
+
+					printk("oplus_sla_stream: screen_on[%d] uid[%u]"
+							" proto[%d] srcport[%d] dstport[%d] dstip[%d.%d.%d.%d] dev[%s] mark[%x]\n",
+							sla_screen_on,uid,iph->protocol,srcport,dstport,
+							dstip[0],dstip[1],dstip[2],dstip[3],dev?dev->name:"null",skb->mark);
+				}
+			}
+		}
+	}
+	return;
+}
+
+static int sla_mark_skb(struct sk_buff *skb, const struct nf_hook_state *state)
+{
+	int index = 0;
+	kuid_t app_uid = {0};
+	u32 ct_mark = 0x0;
+	struct sock *sk = NULL;
+	struct nf_conn *ct = NULL;
+	int ret = SLA_SKB_CONTINUE;
+	enum ip_conntrack_info ctinfo;
+
+	//if wlan assistant has change network to cell,do not mark SKB
+	if(oplus_sla_def_net == CELL_INDEX){
+		return NF_ACCEPT;
+	}
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if(NULL == ct){
+		return NF_ACCEPT;
+	}
+
+	/*
+	  * when the wifi is poor,the dns request allways can not rcv respones,
+	  * so please let the dns packet with the cell network mark.
+	  */
+	ret = dns_skb_need_sla(ct,skb);
+	if(SLA_SKB_ACCEPT == ret) {
+		return NF_ACCEPT;
+	}
+
+	if(is_skb_pre_bound(skb) || dst_is_lan_ip(skb)){
+		return NF_ACCEPT;
+	}
+
+	if(SLA_MODE_WIFI_CELL == sla_work_mode &&
+		!is_sla_white_or_game_app(ct,skb)){
+		return NF_ACCEPT;
+	}
+
+	if (SLA_MODE_DUAL_WIFI == sla_work_mode &&
+		!is_dual_sta_white_app(ct,skb,&app_uid)) {
+		return NF_ACCEPT;
+	}
+
+	ret = mark_game_app_skb(ct,skb,ctinfo);
+	if(SLA_SKB_MARKED == ret){
+		goto sla_reroute;
+	}
+	else if(SLA_SKB_ACCEPT == ret){
+		return NF_ACCEPT;
+	}
+	else if(SLA_SKB_DROP ==	ret){
+		return NF_DROP;
+	}
+
+	if(ctinfo == IP_CT_NEW){
+		sk = skb_to_full_sk(skb);
+		if(NULL != sk){
+			ret = syn_retransmits_packet_do_specail(sk,ct,skb);
+			if(SLA_SKB_MARKED == ret){
+				goto sla_reroute;
+			}
+			else if(SLA_SKB_REMARK == ret){
+				return NF_DROP;
+			}
+			else if(SLA_SKB_ACCEPT == ret){
+				return NF_ACCEPT;
+			}
+
+			// add for download app stream
+			ret = mark_download_app(sk,app_uid,ct,skb);
+			if (SLA_SKB_MARKED == ret) {
+				goto sla_reroute;
+			}
+
+			// add for vedio app stream
+			ret = mark_video_app(sk,app_uid,ct,skb);
+			if (SLA_SKB_MARKED == ret) {
+				goto sla_reroute;
+			}
+
+			sla_read_lock();
+			skb->mark = get_skb_mark_by_weight();
+			sla_read_unlock();
+
+			ct->mark = skb->mark;
+			sk->oplus_sla_mark = skb->mark;
+			//sk->sk_mark = sk->oplus_sla_mark;
+		}
+	}
+	else if((XT_STATE_BIT(ctinfo) &	XT_STATE_BIT(IP_CT_ESTABLISHED)) ||
+			(XT_STATE_BIT(ctinfo) &	XT_STATE_BIT(IP_CT_RELATED))){
+
+		skb->mark = ct->mark & MARK_MASK;
+	}
+
+	//If the mark value of the packet is equal to WLAN0_MARK, no re routing is required
+	if (MAIN_WLAN_MARK == skb->mark) {
+		return NF_ACCEPT;
+	}
+
+	//calc white list app cell bytes
+	if(ct->oplus_app_type >= WHITE_APP_BASE &&
+		ct->oplus_app_type < DUAL_STA_APP_BASE){
+		ct_mark = ct->mark & MARK_MASK;
+		if(CELL_MARK == ct_mark){
+			index = ct->oplus_app_type - WHITE_APP_BASE;
+			if(index < WHITE_APP_NUM){
+				white_app_list.cell_bytes[index] += skb->len;
+			}
+		}
+	}
+
+sla_reroute:
+	ret = sla_skb_reroute(skb,ct,state);
+	return ret;
+
+}
+
+/*
+  * so how can we calc speed when app connect server with 443 dport(https)
+  */
+static void get_content_lenght(struct nf_conn *ct,struct sk_buff *skb,int header_len,int index){
+
+	char *p = (char *)skb->data + header_len;
+
+	char *start = NULL;
+	char *end = NULL;
+	int temp_len = 0;
+	u64 tmp_time;
+	u32 content_len = 0;
+	char data_buf[256];
+	char data_len[11];
+	memset(data_len,0x0,sizeof(data_len));
+	memset(data_buf,0x0,sizeof(data_buf));
+
+	if(ct->oplus_http_flag != 1 || ct->oplus_skb_count > 3){
+		return;
+	}
+	ct->oplus_skb_count++;
+
+	temp_len = (char *)skb_tail_pointer(skb) - p;
+	if(temp_len < 25){//HTTP/1.1 200 OK + Content-Length
+		return;
+	}
+
+	p += 25;
+
+	temp_len = (char *)skb_tail_pointer(skb) - p;
+	if(temp_len){
+		if(temp_len > (sizeof(data_buf)-1)){
+
+			temp_len = (sizeof(data_buf)-1);
+		}
+		memcpy(data_buf,p,temp_len);
+		start = strstr(data_buf,"Content-Length");
+		if(start != NULL){
+			ct->oplus_http_flag = 2;
+			start += 16; //add Content-Length:
+
+			end = strchr(start,0x0d);//get '\r\n'
+
+			if(NULL != end){
+				if((end - start) < 11){
+					memcpy(data_len,start,end - start);
+					sscanf(data_len,"%u",&content_len);
+					//printk("oplus_sla_speed:content = %u\n",content_len);
+				}
+				else{
+					content_len = 0x7FFFFFFF;
+				}
+
+				tmp_time = ktime_get_ns();
+				oplus_speed_info[index].sum_bytes += content_len;
+				if(0 == oplus_speed_info[index].bytes_time){
+					oplus_speed_info[index].bytes_time = tmp_time;
+				} else {
+					if(oplus_speed_info[index].sum_bytes >= 20000 ||
+						(tmp_time - oplus_speed_info[index].bytes_time) > 5000000000){
+						oplus_speed_info[index].bytes_time = tmp_time;
+						if(oplus_speed_info[index].sum_bytes >= 20000){
+							oplus_speed_info[index].ms_speed_flag = 1;
+						}
+						oplus_speed_info[index].sum_bytes = 0;
+					}
+				}
+			}
+		}
+	}
+}
+
+/*only work for wifi +lte mode*/
+static unsigned int oplus_sla_speed_calc(struct sk_buff *skb)
+{
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct = NULL;
+	int index = -1;
+	int tmp_speed = 0;
+	u64 time_now = 0;
+	u64 tmp_time = 0;
+	struct iphdr *iph;
+	struct tcphdr *tcph;
+	int datalen = 0;
+	int header_len = 0;
+
+	if(!sla_switch_enable || oplus_sla_enable){
+		return NF_ACCEPT;
+	}
+
+	//only calc wlan speed
+	if(oplus_sla_info[MAIN_WLAN].if_up &&
+	   !oplus_sla_info[CELL_INDEX].if_up){
+		index = MAIN_WLAN;
+	} else {
+		return NF_ACCEPT;
+	}
+
+	if(!enable_cell_to_user &&
+		oplus_sla_calc_speed &&
+		!oplus_speed_info[index].speed_done){
+
+		ct = nf_ct_get(skb, &ctinfo);
+
+		if(NULL == ct){
+			return NF_ACCEPT;
+
+		}
+
+		if(XT_STATE_BIT(ctinfo) & XT_STATE_BIT(IP_CT_ESTABLISHED)){
+			if((iph = ip_hdr(skb)) != NULL &&
+					iph->protocol == IPPROTO_TCP){
+
+				tcph = tcp_hdr(skb);
+				datalen = ntohs(iph->tot_len);
+				header_len = iph->ihl * 4 + tcph->doff * 4;
+
+				if((datalen - header_len) >= 64){//ip->len > tcphdrlen
+
+					if(!oplus_speed_info[index].ms_speed_flag){
+						get_content_lenght(ct,skb,header_len,index);
+					}
+
+					if(oplus_speed_info[index].ms_speed_flag){
+
+						time_now = ktime_get_ns();
+						if(0 == oplus_speed_info[index].last_time &&
+							0 == oplus_speed_info[index].first_time){
+							oplus_speed_info[index].last_time = time_now;
+							oplus_speed_info[index].first_time = time_now;
+							oplus_speed_info[index].rx_bytes = skb->len;
+							return NF_ACCEPT;
+						}
+
+						tmp_time = time_now - oplus_speed_info[index].first_time;
+						oplus_speed_info[index].rx_bytes += skb->len;
+						oplus_speed_info[index].last_time = time_now;
+						if(tmp_time > 500000000){
+							oplus_speed_info[index].ms_speed_flag = 0;
+							tmp_time = oplus_speed_info[index].last_time - oplus_speed_info[index].first_time;
+							tmp_speed = (1000 *1000*oplus_speed_info[index].rx_bytes) / (tmp_time);//kB/s
+
+							oplus_speed_info[index].speed_done = 1;
+							do_gettimeofday(&last_calc_small_speed_tv);
+
+							if(cell_quality_good &&
+								!rate_limit_info.rate_limit_enable &&
+								tmp_speed > CALC_WEIGHT_MIN_SPEED_1 &&
+								tmp_speed < CALC_WEIGHT_MIN_SPEED_3 &&
+								oplus_sla_info[index].max_speed < 100){
+
+								send_enable_to_framework(SLA_MODE_WIFI_CELL,INIT_ACTIVE_TYPE);
+								printk("oplus_sla_netlink: calc speed is small,send enable sla to user\n");
+							}
+
+							printk("oplus_sla_speed: speed[%d] = %d\n",index,tmp_speed);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return NF_ACCEPT;
+}
+
+/* oplus sla hook function, mark skb and rerout skb
+*/
+static unsigned int oplus_sla_output_hook(void *priv,
+				      struct sk_buff *skb,
+				      const struct nf_hook_state *state)
+{
+	int ret = NF_ACCEPT;
+	int game_ret = NF_ACCEPT;
+
+	game_ret = detect_game_up_skb(skb);
+	if(SLA_SKB_ACCEPT == game_ret){
+		goto end_sla_output;
+	}
+
+	//we need to calc white list app cell bytes when sla not enabled
+	detect_white_list_app_skb(skb);
+
+    if(oplus_sla_enable){
+
+		ret = sla_mark_skb(skb,state);
+    }
+	else{
+
+		if(!sla_screen_on){
+			goto end_sla_output;
+		}
+
+		if(oplus_sla_info[MAIN_WLAN].if_up){
+
+			ret = get_wlan_syn_retran(skb);
+
+			if(oplus_sla_calc_speed &&
+				!oplus_speed_info[MAIN_WLAN].speed_done){
+				ret = wlan_get_speed_prepare(skb);
+			}
+		}
+	}
+end_sla_output:
+	//add for android Q statictis tcp tx and tx
+	statistics_wlan_tcp_tx_rx(state,skb);
+	print_stream_info(skb);
+	return ret;
+}
+
+static unsigned int oplus_sla_input_hook(void *priv,
+				      struct sk_buff *skb,
+				      const struct nf_hook_state *state)
+{
+	//add for android Q statictis tcp tx and tx
+	statistics_wlan_tcp_tx_rx(state,skb);
+    dns_respond_statistics(skb);
+	oplus_sla_speed_calc(skb);
+	oplus_sla_game_rtt_calc(skb);
+
+	return NF_ACCEPT;
+}
+
+static void oplus_statistic_dev_rtt(struct sock *sk,long rtt)
+{
+	int index = -1;
+	int tmp_rtt = rtt / 1000; //us -> ms
+	u32 mark = sk->oplus_sla_mark & MARK_MASK;
+
+	if(oplus_sla_def_net == CELL_INDEX){
+		index  = CELL_INDEX;
+	}else if(!oplus_sla_enable) {
+		if (oplus_sla_info[MAIN_WLAN].if_up){
+		    index = MAIN_WLAN;
+		} else if (oplus_sla_info[CELL_INDEX].if_up){
+		    index = CELL_INDEX;
+		}
+	} else {
+		index = find_dev_index_by_mark(mark);
+    }
+
+	if(-1 != index){
+		calc_rtt_by_dev_index(index, tmp_rtt, sk);
+		#ifdef OPLUS_FEATURE_APP_MONITOR
+		/* Add for apps network monitors */
+		statistics_monitor_apps_rtt_via_uid(index, tmp_rtt, sk);
+		#endif /* OPLUS_FEATURE_APP_MONITOR */
+	}
+}
+
+/*sometimes when skb reject by iptables,
+*it will retran syn which may make the rtt much high
+*so just mark the stream(ct) with mark IPTABLE_REJECT_MARK when this happens
+*/
+static void sla_mark_streams_for_iptables_reject(struct sk_buff *skb,enum ipt_reject_with reject_type)
+{
+	struct nf_conn *ct = NULL;
+	enum ip_conntrack_info ctinfo;
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if(NULL == ct){
+		return;
+	}
+	ct->mark |= RTT_MARK;
+
+	if (oplus_sla_debug) {
+		if(ctinfo == IP_CT_NEW){
+			struct sock *sk = skb_to_full_sk(skb);
+			const struct file *filp = NULL;
+			if(sk && sk_fullsock(sk)){
+				if(NULL == sk->sk_socket){
+					return;
+				}
+
+				filp = sk->sk_socket->file;
+				if(NULL == filp){
+					return;
+				}
+				printk("oplus_sla_iptables:uid = %u,reject type = %u\n",filp->f_cred->fsuid.val,reject_type);
+			}
+		}
+	}
+
+	return;
+}
+
+static void is_need_calc_wlan_small_speed(int speed)
+{
+	if(sla_screen_on &&
+		!enable_cell_to_user &&
+		!oplus_sla_enable &&
+		!oplus_sla_calc_speed &&
+		!rate_limit_info.rate_limit_enable){
+
+		if(speed <= 100 &&
+			speed > CALC_WEIGHT_MIN_SPEED_1 &&
+			oplus_sla_info[MAIN_WLAN].minute_speed > MINUTE_LITTE_RATE){
+
+			printk("oplus_sla_speed: detect speed is little\n");
+			oplus_sla_calc_speed = 1;
+			memset(&oplus_speed_info[MAIN_WLAN],0x0,sizeof(struct oplus_speed_calc));
+		}
+	}
+}
+
+static bool is_wlan_speed_good(int index)
+{
+	int i = index;
+	bool ret = false;
+
+	if(oplus_sla_info[i].max_speed >= 300 &&
+	   oplus_sla_info[i].sla_avg_rtt < 150 &&
+	   oplus_sla_info[i].wlan_score >= 60 &&
+	   oplus_sla_info[i].download_flag < DOWNLOAD_FLAG){
+		ret = true;
+	}
+	return ret;
+}
+
+static void auto_disable_sla_for_good_wlan(void)
+{
+	int work_mode = SLA_MODE_WIFI_CELL;
+	int time_interval;
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	time_interval = tv.tv_sec - last_enable_cellular_tv.tv_sec;
+
+	if(oplus_sla_enable &&
+	   time_interval >= 300 &&
+	   !game_online_info.game_online &&
+	   SLA_MODE_WIFI_CELL == sla_work_mode &&
+	   oplus_sla_info[MAIN_WLAN].sla_avg_rtt < 150 &&
+	   oplus_sla_info[MAIN_WLAN].max_speed >= 300){
+
+	   enable_cell_to_user = false;
+	   oplus_sla_send_to_user(SLA_DISABLE,(char *)&work_mode,sizeof(int));
+
+	   sla_write_lock();
+	   oplus_sla_info[MAIN_WLAN].weight = 100;
+	   oplus_sla_info[CELL_INDEX].weight = 0;
+	   sla_write_unlock();
+
+	   printk("oplus_sla_netlink:speed good,disable sla\n");
+	}
+}
+
+static void auto_disable_dual_wifi(void)
+{
+	int work_mode = SLA_MODE_DUAL_WIFI;
+	int time_interval;
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	time_interval = tv.tv_sec - last_enable_cellular_tv.tv_sec;
+
+	if(oplus_sla_enable &&
+	   time_interval >= 300 &&
+	   !game_online_info.game_online &&
+	   SLA_MODE_DUAL_WIFI == sla_work_mode &&
+	   is_wlan_speed_good(MAIN_WLAN) &&
+	   oplus_sla_info[SECOND_WLAN].minute_speed < MINUTE_LITTE_RATE){
+
+	   enable_second_wifi_to_user = false;
+	   oplus_sla_send_to_user(SLA_DISABLE,(char *)&work_mode,sizeof(int));
+
+	   sla_write_lock();
+	   oplus_sla_info[MAIN_WLAN].weight = 100;
+	   oplus_sla_info[SECOND_WLAN].weight = 0;
+	   sla_write_unlock();
+
+	   printk("oplus_sla_netlink:speed good,disable dual wifi\n");
+	}
+}
+
+static void detect_wlan_state_with_speed(void)
+{
+	auto_disable_dual_wifi();
+	auto_disable_sla_for_good_wlan();
+	is_need_calc_wlan_small_speed(oplus_sla_info[MAIN_WLAN].max_speed);
+}
+
+static void reset_network_state_by_speed(int index,int speed)
+{
+	int i = index;
+	if(speed > 400) {
+		if (oplus_sla_info[i].avg_rtt > 150) {
+		    oplus_sla_info[i].avg_rtt -= 50;
+		}
+		if (oplus_sla_info[i].sla_avg_rtt > 150) {
+			oplus_sla_info[i].sla_avg_rtt -=50;
+		}
+		oplus_sla_info[i].congestion_flag = CONGESTION_LEVEL_NORMAL;
+	}
+
+	//when the network speed is bigger than 50KB/s,we shoud reset the weight_state
+	if (speed >= 50 &&
+		WEIGHT_STATE_USELESS == oplus_sla_info[i].weight_state) {
+		oplus_sla_info[i].weight_state = WEIGHT_STATE_NORMAL;
+	}
+
+	return;
+}
+static void detect_dl_little_speed(int index,int speed)
+{
+	int i = index;
+
+	if(speed >= CALC_WEIGHT_MIN_SPEED_2){
+		if (oplus_sla_info[i].little_speed_num < ADJUST_SPEED_NUM) {
+			oplus_sla_info[i].little_speed_num++;
+			if (speed > oplus_sla_info[i].tmp_little_speed) {
+				oplus_sla_info[i].tmp_little_speed = speed;
+			}
+
+			if (ADJUST_SPEED_NUM == oplus_sla_info[i].little_speed_num) {
+				oplus_sla_info[i].dl_little_speed = oplus_sla_info[i].tmp_little_speed;
+			}
+		}
+	} else {
+		oplus_sla_info[i].tmp_little_speed = 0;
+		oplus_sla_info[i].little_speed_num = 0;
+	}
+}
+
+static void detect_network_download(int index,int speed)
+{
+	int i = index;
+
+	if(speed > DOWNLOAD_SPEED){
+		if (oplus_sla_info[i].download_num < ADJUST_SPEED_NUM) {
+			oplus_sla_info[i].download_num++;
+			if (speed > oplus_sla_info[i].dl_mx_speed) {
+				oplus_sla_info[i].dl_mx_speed = speed;
+			}
+		}
+
+		//Adjust the speed to prevent speed burst leading to high speed
+		if (ADJUST_SPEED_NUM == oplus_sla_info[i].download_num) {
+
+			if (oplus_sla_info[i].download_speed > oplus_sla_info[i].dl_mx_speed) {
+				oplus_sla_info[i].download_speed += oplus_sla_info[i].dl_mx_speed;
+				oplus_sla_info[i].download_speed /= 2;
+			}
+			else {
+				oplus_sla_info[i].download_speed = oplus_sla_info[i].dl_mx_speed;
+			}
+
+			if (oplus_sla_info[i].max_speed > oplus_sla_info[i].download_speed) {
+				oplus_sla_info[i].max_speed = oplus_sla_info[i].download_speed;
+			}
+
+			oplus_sla_info[i].download_num = 0;
+			oplus_sla_info[i].dl_mx_speed = 0;
+			if (oplus_sla_debug) {
+				printk("oplus_sla_speed: adjust download speed = %d\n",oplus_sla_info[i].download_speed);
+			}
+		}
+
+		if (speed > (oplus_sla_info[i].download_speed / 2)) {
+			if (speed < rom_update_info.dual_wlan_download_speed &&
+				oplus_sla_info[i].download_speed < rom_update_info.dual_wlan_download_speed &&
+				oplus_sla_info[i].dual_wifi_download < (2 * DOWNLOAD_FLAG)) {
+
+				oplus_sla_info[i].dual_wifi_download++;
+			} else if (speed >= rom_update_info.dual_wlan_download_speed ||
+				oplus_sla_info[i].download_speed >= rom_update_info.dual_wlan_download_speed){
+
+				if(oplus_sla_info[i].dual_wifi_download >= 2){
+					oplus_sla_info[i].dual_wifi_download -= 2;
+				}
+				else if(oplus_sla_info[i].dual_wifi_download){
+					oplus_sla_info[i].dual_wifi_download--;
+				}
+			}
+
+			if(oplus_sla_info[i].download_flag < (2 * DOWNLOAD_FLAG)){
+				oplus_sla_info[i].download_flag++;
+			}
+		}
+	}
+	else {
+		oplus_sla_info[i].download_num = 0;
+		oplus_sla_info[i].dl_mx_speed = 0;
+	}
+
+	if(speed < (oplus_sla_info[i].download_speed / 3)){
+
+		if(oplus_sla_info[i].download_flag >= 2){
+			oplus_sla_info[i].download_flag -= 2;
+		}
+		else if(oplus_sla_info[i].download_flag){
+			oplus_sla_info[i].download_flag--;
+		}
+
+		if(oplus_sla_info[i].dual_wifi_download >= 2){
+			oplus_sla_info[i].dual_wifi_download -= 2;
+		}
+		else if(oplus_sla_info[i].dual_wifi_download){
+			oplus_sla_info[i].dual_wifi_download--;
+		}
+	}
+	return;
+}
+
+static void adjust_speed_with_romupdate_param(int index)
+{
+	int i = index;
+
+	if(CELL_INDEX == i &&
+		oplus_sla_info[i].max_speed > rom_update_info.cell_speed){
+
+		oplus_sla_info[i].max_speed = rom_update_info.cell_speed;
+	}
+
+	if(MAIN_WLAN == i || SECOND_WLAN == i){
+		if(oplus_sla_info[i].wlan_score <= rom_update_info.wlan_bad_score &&
+		   oplus_sla_info[i].max_speed > rom_update_info.wlan_little_score_speed){
+			oplus_sla_info[i].max_speed = rom_update_info.wlan_little_score_speed;
+		}
+		else if(MAIN_WLAN == i &&
+			oplus_sla_info[i].max_speed > rom_update_info.wlan_speed){
+			oplus_sla_info[i].max_speed = rom_update_info.wlan_speed;
+		}
+		else if (SECOND_WLAN == i &&
+			oplus_sla_info[i].max_speed > rom_update_info.second_wlan_speed) {
+			oplus_sla_info[i].max_speed = rom_update_info.second_wlan_speed;
+		}
+	}
+	return;
+}
+
+static void calc_download_speed(int index,u64 total_bytes,int time)
+{
+	int i = index;
+	int dl_speed = 0;
+	u64 bytes = 0;
+
+	if (time >= DOWNLOAD_SPEED_TIME ) {
+		if (0 == oplus_sla_info[i].dl_total_bytes ||
+			oplus_sla_info[i].dl_total_bytes > total_bytes) {
+
+			oplus_sla_info[i].dl_total_bytes = total_bytes;
+		}
+		else {
+			bytes = total_bytes - oplus_sla_info[i].dl_total_bytes;
+			dl_speed = bytes / time;
+			dl_speed = dl_speed / 1000;
+			oplus_sla_info[i].dl_total_bytes = total_bytes;
+
+			detect_dl_little_speed(i,dl_speed);
+			detect_network_download(i,dl_speed);
+
+			if (dl_speed > oplus_sla_info[i].download_speed) {
+				oplus_sla_info[i].left_speed = dl_speed - oplus_sla_info[i].download_speed;
+			}
+			else {
+				oplus_sla_info[i].left_speed = oplus_sla_info[i].download_speed - dl_speed;
+			}
+
+			if (oplus_sla_debug) {
+				printk("oplus_sla: cur download speed[%d] = %d\n",i,dl_speed);
+			}
+		}
+	}
+}
+
+static inline int dev_isalive(const struct net_device *dev)
+{
+	return dev->reg_state <= NETREG_REGISTERED;
+}
+
+static void statistic_dev_speed(struct timeval tv,int time_interval)
+{
+	int i=0;
+	int temp_speed;
+	u64	temp_bytes;
+	u64 total_bytes = 0;
+	int tmp_minute_time;
+	int tmp_minute_speed;
+	int download_time = 0;
+	int do_calc_minute_speed = 0;
+	struct net_device *dev;
+	const struct rtnl_link_stats64 *stats;
+	struct rtnl_link_stats64 temp;
+
+	tmp_minute_time = tv.tv_sec - last_minute_speed_tv.tv_sec;
+	if(tmp_minute_time >= LITTLE_FLOW_TIME){
+		last_minute_speed_tv = tv;
+		do_calc_minute_speed = 1;
+	}
+
+	download_time = tv.tv_sec - last_download_speed_tv.tv_sec;
+	if (download_time >= DOWNLOAD_SPEED_TIME) {
+		last_download_speed_tv = tv;
+	}
+
+	for(i = 0; i < IFACE_NUM; i++){
+		if(oplus_sla_info[i].if_up || oplus_sla_info[i].need_up){
+			dev = dev_get_by_name(&init_net, oplus_sla_info[i].dev_name);
+			if(dev) {
+				if (dev_isalive(dev) &&
+					(NULL != dev->netdev_ops) &&
+					(stats = dev_get_stats(dev, &temp))){
+					//first time have no value,and  maybe oplus_sla_info[i].rx_bytes will more than stats->rx_bytes
+					total_bytes = stats->rx_bytes + stats->tx_bytes;
+					if(0 == oplus_sla_info[i].total_bytes ||
+						oplus_sla_info[i].total_bytes > total_bytes){
+
+						oplus_sla_info[i].total_bytes = total_bytes;
+						oplus_sla_info[i].minute_rx_bytes = total_bytes;
+					}
+					else{
+
+						if(do_calc_minute_speed){
+
+							temp_bytes = total_bytes - oplus_sla_info[i].minute_rx_bytes;
+							oplus_sla_info[i].minute_rx_bytes = total_bytes;
+							tmp_minute_speed = (8 * temp_bytes) / tmp_minute_time; //kbit/s
+							oplus_sla_info[i].minute_speed = tmp_minute_speed / 1000;
+
+							if(MAIN_WLAN == i){
+								detect_wlan_state_with_speed();
+							}
+						}
+
+						temp_bytes = total_bytes - oplus_sla_info[i].total_bytes;
+						oplus_sla_info[i].total_bytes = total_bytes;
+
+						temp_speed = temp_bytes / time_interval;
+						temp_speed = temp_speed / 1000;//kB/s
+						oplus_sla_info[i].current_speed = temp_speed;
+
+						if(temp_speed > oplus_sla_info[i].max_speed){
+							oplus_sla_info[i].max_speed = temp_speed;
+						}
+
+						if (temp_speed > oplus_sla_info[i].download_speed) {
+							oplus_sla_info[i].download_speed = temp_speed;
+						}
+
+						calc_download_speed(i,total_bytes,download_time);
+						reset_network_state_by_speed(i,temp_speed);
+						adjust_speed_with_romupdate_param(i);
+
+					}
+				}
+				dev_put(dev);
+			}
+
+			if(oplus_sla_debug /*&& net_ratelimit()*/){
+				printk("oplus_sla: dev_name = %s,if_up = %d,max_speed = %d,"
+						"current_speed = %d,avg_rtt = %d,congestion = %d,"
+						"is_download = %d,syn_retran = %d,minute_speed = %d,"
+						"weight_state = %d,download_speed = %d,dual_wifi_download = %d,dl_little_speed = %d\n",
+						oplus_sla_info[i].dev_name,oplus_sla_info[i].if_up,
+						oplus_sla_info[i].max_speed,oplus_sla_info[i].current_speed,
+						oplus_sla_info[i].sla_avg_rtt,oplus_sla_info[i].congestion_flag,
+						oplus_sla_info[i].download_flag,oplus_sla_info[i].syn_retran,
+						oplus_sla_info[i].minute_speed,oplus_sla_info[i].weight_state,
+						oplus_sla_info[i].download_speed,oplus_sla_info[i].dual_wifi_download,oplus_sla_info[i].dl_little_speed);
+			}
+
+		}
+	}
+}
+
+
+static void reset_invalid_network_info(struct oplus_dev_info *node)
+{
+	struct timeval tv;
+
+	//to avoid when weight_state change WEIGHT_STATE_USELESS now ,
+	//but the next moment change to WEIGHT_STATE_RECOVERY
+	//because of minute_speed is little than MINUTE_LITTE_RATE;
+	do_gettimeofday(&tv);
+	last_minute_speed_tv = tv;
+	node->minute_speed = MINUTE_LITTE_RATE;
+
+	sla_rtt_write_lock();
+	node->rtt_index = 0;
+	node->sum_rtt= 0;
+	node->avg_rtt = 0;
+	node->sla_avg_rtt = 0;
+	node->sla_rtt_num = 0;
+	node->sla_sum_rtt = 0;
+	sla_rtt_write_unlock();
+
+	node->max_speed = 0;
+	node->left_speed = 0;
+	node->current_speed = 0;
+	node->syn_retran = 0;
+	node->download_flag = 0;
+	node->download_speed = 0;
+	node->dual_wifi_download = 0;
+	node->weight_state = WEIGHT_STATE_USELESS;
+
+	if(oplus_sla_debug){
+		printk("oplus_sla: reset_invalid_network_info,dev_name = %s\n",node->dev_name);
+	}
+}
+
+static bool calc_weight_with_wlan_state(void)
+{
+	bool ret = false;
+
+	if(is_wlan_speed_good(MAIN_WLAN)){
+		ret = true;
+		oplus_sla_info[MAIN_WLAN].weight = 100;
+		if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+			oplus_sla_info[CELL_INDEX].weight = 0;
+		} else if (SLA_MODE_DUAL_WIFI == sla_work_mode){
+			oplus_sla_info[SECOND_WLAN].weight = 0;
+		}
+	}
+	return ret;
+}
+
+static int calc_weight_with_speed(int speed_1,int speed_2)
+{
+	int tmp_weight;
+	int sum_speed = speed_1 + speed_2;
+
+	tmp_weight = (100 * speed_1) / sum_speed;
+
+	return tmp_weight;
+}
+
+/*network_1 must be the main wifi */
+static int calc_weight_with_left_speed(int network_1,int network_2)
+{
+	int speed1;
+	int speed2;
+	int index1 = network_1;
+	int index2 = network_2;
+
+	if((oplus_sla_info[index1].download_flag >= DOWNLOAD_FLAG ||
+		oplus_sla_info[index2].download_flag >= DOWNLOAD_FLAG) &&
+		(oplus_sla_info[index1].max_speed > CALC_WEIGHT_MIN_SPEED_2 &&
+		  oplus_sla_info[index2].max_speed > CALC_WEIGHT_MIN_SPEED_2)){
+
+		if (oplus_sla_info[index1].download_flag >= DOWNLOAD_FLAG) {
+			if (is_wlan_speed_good(index2) &&
+				oplus_sla_info[index1].download_speed <= MAX_WLAN_SPEED){
+				if (oplus_sla_debug) {
+					printk("oplus_sla_weight:network1 is download and network2 is much better\n");
+				}
+				oplus_sla_info[index1].weight = 0;
+				oplus_sla_info[index2].weight = 100;
+				return 1;
+			}
+
+			if (oplus_sla_info[index2].max_speed <= CALC_WEIGHT_MIN_SPEED_3) {
+				if (oplus_sla_info[index2].avg_rtt >= rom_update_info.sla_rtt) {
+					if (oplus_sla_debug) {
+						printk("oplus_sla_weight:network1 is download but network1 is very bad\n");
+					}
+					oplus_sla_info[index1].weight = 100;
+					oplus_sla_info[index2].weight = 0;
+					return 1;
+				}
+				speed1 = oplus_sla_info[index1].max_speed;
+			} else {
+				speed1 = oplus_sla_info[index1].left_speed;
+			}
+		}
+		else {
+			speed1 = oplus_sla_info[index1].max_speed;
+		}
+
+		if (oplus_sla_info[index2].download_flag >= DOWNLOAD_FLAG) {
+			if (is_wlan_speed_good(index1) &&
+				oplus_sla_info[index2].download_speed <= MAX_WLAN_SPEED){
+				if (oplus_sla_debug) {
+					printk("oplus_sla_weight:network2 is download and network1 is much better\n");
+				}
+				oplus_sla_info[index1].weight = 100;
+				oplus_sla_info[index2].weight = 0;
+				return 1;
+			}
+
+			if (oplus_sla_info[index1].max_speed <= CALC_WEIGHT_MIN_SPEED_3) {
+				if (oplus_sla_info[index1].avg_rtt >= rom_update_info.sla_rtt) {
+					if (oplus_sla_debug) {
+						printk("oplus_sla_weight:network2 is download but network1 is very bad\n");
+					}
+					oplus_sla_info[index1].weight = 0;
+					oplus_sla_info[index2].weight = 100;
+					return 1;
+				}
+				speed2 = oplus_sla_info[index2].max_speed;
+			} else {
+				speed2 = oplus_sla_info[index2].left_speed;
+			}
+		}
+		else {
+			speed2 = oplus_sla_info[index2].max_speed;
+		}
+
+		oplus_sla_info[index1].weight = calc_weight_with_speed(speed1,speed2);
+		oplus_sla_info[index2].weight = 100;
+		if (oplus_sla_debug) {
+			printk("oplus_sla_weight: calc weight with download speed\n");
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static int calc_weight_with_weight_state(int network_1,int network_2)
+{
+	int index1 = network_1;
+	int index2 = network_2;
+
+	if ((WEIGHT_STATE_USELESS == oplus_sla_info[index1].weight_state ||
+		WEIGHT_STATE_SCORE_INVALID == oplus_sla_info[index1].weight_state) &&
+		(WEIGHT_STATE_USELESS != oplus_sla_info[index2].weight_state &&
+		 WEIGHT_STATE_SCORE_INVALID != oplus_sla_info[index2].weight_state)) {
+
+		oplus_sla_info[index1].weight = 0;
+		oplus_sla_info[index2].weight = 100;
+		if (oplus_sla_debug) {
+			printk("oplus_sla_weight: [%d] calc weight with WEIGHT_STATE_USELESS \n",index1);
+		}
+		return 1;
+	}
+	else if ((WEIGHT_STATE_USELESS != oplus_sla_info[index1].weight_state &&
+		  WEIGHT_STATE_SCORE_INVALID != oplus_sla_info[index1].weight_state) &&
+		 (WEIGHT_STATE_USELESS == oplus_sla_info[index2].weight_state ||
+		  WEIGHT_STATE_SCORE_INVALID == oplus_sla_info[index2].weight_state)) {
+
+		oplus_sla_info[index2].weight = 0;
+		oplus_sla_info[index1].weight = 100;
+		if (oplus_sla_debug) {
+			printk("oplus_sla_weight: [%d]calc weight with WEIGHT_STATE_USELESS \n",index2);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+static int calc_weight_with_little_speed(int network_1,int network_2)
+{
+	int index1 = network_1;
+	int index2 = network_2;
+
+	if((is_wlan_speed_good(index2) &&
+	   oplus_sla_info[index1].max_speed <= CALC_WEIGHT_MIN_SPEED_2) ||
+	   (oplus_sla_info[index1].max_speed < CALC_WEIGHT_MIN_SPEED_1 &&
+		CONGESTION_LEVEL_HIGH == oplus_sla_info[index1].congestion_flag)){
+
+		oplus_sla_info[index1].weight = 0;
+		oplus_sla_info[index2].weight = 100;
+		if (oplus_sla_debug) {
+			printk("oplus_sla_weight:calc weight with little speed \n");
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static bool is_main_wlan_poor(void)
+{
+	int index = MAIN_WLAN;
+	int score = 10 + rom_update_info.dual_wlan_bad_score;
+
+	if(oplus_sla_info[index].wlan_score > 10 &&
+		oplus_sla_info[index].wlan_score <= score) {
+		return true;
+	}
+
+	if (oplus_sla_info[index].download_flag >= DOWNLOAD_FLAG) {
+		return true;
+	}
+
+	if (oplus_sla_info[index].max_speed <= rom_update_info.sla_speed &&
+		oplus_sla_info[index].sla_avg_rtt >= rom_update_info.dual_wifi_rtt) {
+		return true;
+	}
+
+	if (oplus_sla_info[index].dl_little_speed < rom_update_info.sla_speed &&
+		oplus_sla_info[index].download_speed < VIDEO_SPEED) {
+		return true;
+	}
+
+	return false;
+}
+
+/*network_1 must be the main wifi */
+static void recalc_two_network_weight(int network_1,int network_2)
+{
+	int index1 = network_1;
+	int index2 = network_2;
+
+	int speed1 = oplus_sla_info[index1].max_speed;
+	int speed2 = oplus_sla_info[index2].max_speed;
+
+	if(oplus_sla_info[index1].if_up &&
+		oplus_sla_info[index2].if_up){
+
+		if(calc_weight_with_wlan_state() ||
+		   calc_weight_with_weight_state (index1, index2) ||
+		   calc_weight_with_left_speed(index1, index2) ||
+		   calc_weight_with_little_speed(index1, index2)){
+			goto calc_weight_finish;
+		}
+
+		if((speed1 >= CALC_WEIGHT_MIN_SPEED_2 &&
+			speed2 >= CALC_WEIGHT_MIN_SPEED_2) ||
+		   (CONGESTION_LEVEL_HIGH == oplus_sla_info[index1].congestion_flag ||
+			CONGESTION_LEVEL_HIGH == oplus_sla_info[index2].congestion_flag) ||
+			((CONGESTION_LEVEL_MIDDLE == oplus_sla_info[index1].congestion_flag ||
+			  CONGESTION_LEVEL_MIDDLE == oplus_sla_info[index2].congestion_flag) &&
+			 (speed1 >= CALC_WEIGHT_MIN_SPEED_1 && speed2 >= CALC_WEIGHT_MIN_SPEED_1))){
+
+			oplus_sla_info[index1].weight = calc_weight_with_speed(speed1,speed2);
+		}
+		else{
+			if (SLA_MODE_DUAL_WIFI == sla_work_mode &&
+				INIT_ACTIVE_TYPE == dual_wifi_active_type &&
+				!is_main_wlan_poor()) {
+
+				//for maul active or NetworRequest
+				oplus_sla_info[index1].weight = 100;
+				oplus_sla_info[index2].weight = 0;
+			} else if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+				oplus_sla_info[index1].weight = 30;
+				oplus_sla_info[index2].weight = 100;
+			} else if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+				oplus_sla_info[index1].weight = 15;
+				oplus_sla_info[index2].weight = 100;
+			}
+			goto calc_weight_finish;
+		}
+	}
+	else if(oplus_sla_info[index1].if_up){
+		oplus_sla_info[index1].weight = 100;
+	}
+	oplus_sla_info[index2].weight = 100;
+
+calc_weight_finish:
+
+	if(oplus_sla_debug){
+		printk("oplus_sla_weight: work_mode = %d,weight[%d] = %d,weight[%d] = %d\n",
+				sla_work_mode,index1,oplus_sla_info[index1].weight,index2,oplus_sla_info[index2].weight);
+	}
+	return;
+}
+
+static void recalc_dual_wifi_weight(void)
+{
+	recalc_two_network_weight(MAIN_WLAN,SECOND_WLAN);
+	return;
+}
+
+static void recalc_wifi_cell_weight(void)
+{
+	recalc_two_network_weight(MAIN_WLAN,CELL_INDEX);
+	oplus_sla_info[SECOND_WLAN].weight = 0;
+	return;
+}
+
+
+static void recalc_dual_wifi_cell_weight(void)
+{
+	int i = 0;
+	int sum_speed = 0;
+	int speed1 = oplus_sla_info[0].max_speed;
+	int speed2 = oplus_sla_info[1].max_speed;
+	int speed3 = oplus_sla_info[2].max_speed;
+
+	for (i = 0; i < IFACE_NUM; i++) {
+		if (!oplus_sla_info[i].if_up) {
+			return;
+		}
+	}
+
+	if (is_wlan_speed_good(MAIN_WLAN) ||
+		is_wlan_speed_good(SECOND_WLAN) ||
+		oplus_sla_info[MAIN_WLAN].download_flag >= DOWNLOAD_FLAG ||
+		oplus_sla_info[SECOND_WLAN].download_flag >= DOWNLOAD_FLAG) {
+		recalc_two_network_weight(MAIN_WLAN,SECOND_WLAN);
+		goto finish_calc;
+	}
+
+	if ((speed1 >= CALC_WEIGHT_MIN_SPEED_2 &&
+		 speed2 >= CALC_WEIGHT_MIN_SPEED_2 &&
+		 speed2 >= CALC_WEIGHT_MIN_SPEED_2) ||
+		(oplus_sla_info[0].congestion_flag > CONGESTION_LEVEL_NORMAL &&
+		 oplus_sla_info[1].congestion_flag > CONGESTION_LEVEL_NORMAL &&
+		 oplus_sla_info[2].congestion_flag > CONGESTION_LEVEL_NORMAL)) {
+
+		sum_speed = speed1 + speed2 + speed3;
+		oplus_sla_info[0].weight = (100 * speed1) / sum_speed;
+		oplus_sla_info[1].weight = (100 * (speed1 + speed2)) / sum_speed;
+		oplus_sla_info[2].weight = 100;
+		goto finish_calc;
+	}
+
+	/*INIT dual wifi cell weight*/
+	init_dual_wifi_cell_weight();
+finish_calc:
+	if(oplus_sla_debug){
+		printk("oplus_sla_weight: work_mode = %d,weight[0] = %d,weight[1] = %d,weight[2] = %d\n",
+				sla_work_mode,oplus_sla_info[0].weight,oplus_sla_info[1].weight,oplus_sla_info[2].weight);
+	}
+	return;
+}
+
+static void recalc_sla_weight(void)
+{
+	if(!oplus_sla_enable){
+		return;
+	}
+
+	sla_write_lock();
+	if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+		recalc_dual_wifi_weight();
+	}
+	else if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+		recalc_wifi_cell_weight();
+	}
+	else if (SLA_MODE_DUAL_WIFI_CELL  == sla_work_mode) {
+		recalc_dual_wifi_cell_weight();
+	}
+	sla_write_unlock();
+
+	return;
+}
+
+
+/*for when wlan up,but cell down,this will affect the rtt calc at wlan network(will calc big)*/
+static void up_wlan_iface_by_timer(struct timeval tv)
+{
+	int i = 0;
+	int time = 10;
+	for (i = 0; i < WLAN_NUM; i++) {
+		if(oplus_sla_info[i].need_up) {
+			if (SECOND_WLAN == i) {
+				time = 5;
+			}
+
+			if ((tv.tv_sec - calc_wlan_rtt_tv.tv_sec) >= time){
+
+				oplus_sla_info[i].if_up = 1;
+				oplus_sla_info[i].need_up = false;
+
+				printk("oplus_sla:wlan[%d]time[%d] up wlan iface actually\n",i, time);
+			}
+		}
+	}
+}
+
+static void enable_to_user_time_out(struct timeval tv)
+{
+	if(enable_cell_to_user &&
+		(tv.tv_sec - last_enable_cell_tv.tv_sec) >= ENABLE_TO_USER_TIMEOUT){
+		enable_cell_to_user = false;
+	}
+
+	if(enable_second_wifi_to_user &&
+		(tv.tv_sec - last_enable_second_wifi_tv.tv_sec) >= ENABLE_TO_USER_TIMEOUT){
+		enable_second_wifi_to_user = false;
+	}
+
+	return;
+}
+
+static void send_speed_and_rtt_to_user(void)
+{
+	int ret = 0;
+	if (oplus_sla_info[MAIN_WLAN].if_up || oplus_sla_info[MAIN_WLAN].need_up ||
+	    oplus_sla_info[CELL_INDEX].if_up) {
+	    int payload[8];
+	    //add for android Q statictis tcp tx and tx
+	    u64 tcp_tx_rx[4];
+	    char total_payload[64] = {0};
+
+	    payload[0] = oplus_sla_info[MAIN_WLAN].max_speed;
+	    payload[1] = oplus_sla_info[MAIN_WLAN].avg_rtt;
+
+	    payload[2] = oplus_sla_info[SECOND_WLAN].max_speed;
+	    payload[3] = oplus_sla_info[SECOND_WLAN].avg_rtt;
+
+	    payload[4] = oplus_sla_info[CELL_INDEX].max_speed;
+	    payload[5] = oplus_sla_info[CELL_INDEX].avg_rtt;
+
+	    payload[6] = sla_work_mode;
+		payload[7] = oplus_sla_info[MAIN_WLAN].download_speed;
+
+	    tcp_tx_rx[0] = wlan0_tcp_rx;
+	    tcp_tx_rx[1] = wlan0_tcp_tx;
+	    tcp_tx_rx[2] = wlan1_tcp_rx;
+	    tcp_tx_rx[3] = wlan1_tcp_tx;
+
+	    memcpy(total_payload,payload,sizeof(payload));
+	    memcpy(total_payload + sizeof(payload),tcp_tx_rx,sizeof(tcp_tx_rx));
+
+	    ret = oplus_sla_send_to_user(SLA_NOTIFY_SPEED_RTT, (char *) total_payload, sizeof(total_payload));
+	    if (oplus_sla_debug) {
+	        printk("oplus_sla:send_speed_and_rtt_to_user wlan0:max_speed=%d, avg_rtt=%d  "
+	                "wlan1:max_speed=%d, avg_rtt=%d  "
+	                "cell:max_speed=%d, avg_rtt=%d, sla_work_mode=%d, wlan0_max_speed=%dKB/s,  "
+	                "wlan0_tcp_rx = %llu, wlan0_tcp_tx = %llu, wlan1_tcp_rx = %llu, wlan1_tcp_tx = %llu\n",
+	               payload[0], payload[1], payload[2], payload[3], payload[4], payload[5], payload[6], payload[7],
+	               tcp_tx_rx[0],tcp_tx_rx[1], tcp_tx_rx[2],tcp_tx_rx[3]);
+	    }
+	}
+	return;
+}
+
+static int wlan_can_enable_second_wifi(int index)
+{
+	int active_type = 0;
+
+	/*if game is in front, do not active dual wifi by kernel*/
+	if (wzry_traffic_info.game_in_front ||
+		cjzc_traffic_info.game_in_front) {
+		return active_type;
+	}
+
+	if (oplus_sla_info[index].if_up ||
+		oplus_sla_info[index].need_up) {
+		int score = 10 + rom_update_info.dual_wlan_bad_score;
+
+		if (oplus_sla_info[index].max_speed <= rom_update_info.sla_speed &&
+			oplus_sla_info[index].sla_avg_rtt >= rom_update_info.dual_wifi_rtt) {
+			active_type = LOW_SPEED_HIGH_RTT;
+			return active_type;
+		}
+
+		if (oplus_sla_info[index].dual_wifi_download >= DOWNLOAD_FLAG &&
+			oplus_sla_info[index].download_speed < rom_update_info.dual_wlan_download_speed) {
+			active_type = WLAN_DOWNLOAD;
+			return active_type;
+		}
+
+		if(oplus_sla_info[index].wlan_score > 10 &&
+			oplus_sla_info[index].wlan_score <= score) {
+			printk("oplus_sla: send enable dual wifi with score[%d]\n",score);
+			active_type = LOW_WLAN_SCORE;
+			return active_type;
+		}
+
+		if (oplus_sla_info[index].dl_little_speed < rom_update_info.sla_speed &&
+			oplus_sla_info[index].download_speed < VIDEO_SPEED) {
+			printk("oplus_sla:dl_little_speed = %d\n",oplus_sla_info[index].dl_little_speed);
+			active_type = LOW_DL_SPEED;
+			return active_type;
+		}
+	}
+	return active_type;
+}
+
+static bool wlan_can_enable_cell(int index)
+{
+	if (oplus_sla_info[index].if_up ||
+		oplus_sla_info[index].need_up) {
+
+		if (oplus_sla_info[index].download_flag < DOWNLOAD_FLAG) {
+			int score = rom_update_info.wlan_bad_score;
+
+			if(SLA_MODE_DUAL_WIFI != sla_work_mode &&
+				oplus_sla_info[index].wlan_score > 10 &&
+				oplus_sla_info[index].wlan_score <= score) {
+				printk("oplus_sla: send enable sla with score[%d]\n",score);
+				return true;
+			}
+
+			if (oplus_sla_info[index].max_speed <= rom_update_info.sla_speed &&
+				(oplus_sla_info[index].sla_avg_rtt >= rom_update_info.sla_rtt ||
+				 oplus_sla_info[index].wlan_score_bad_count >= WLAN_SCORE_BAD_NUM)) {
+
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+static void sla_show_dailog(void)
+{
+	int i = 0;
+	int bad_count = 0;
+	bool wlan_bad = false;
+
+	/*if has send msg to up second wifi,do no
+	show SLA dailog*/
+	if(enable_second_wifi_to_user) {
+		return;
+	}
+
+	if(sla_screen_on &&
+		!sla_switch_enable &&
+		need_show_dailog &&
+		cell_quality_good &&
+		!send_show_dailog_msg &&
+		!rate_limit_info.rate_limit_enable) {
+
+		for (i = 0; i < WLAN_NUM; i++) {
+			if (oplus_sla_info[i].if_up &&
+				oplus_sla_info[i].download_flag < DOWNLOAD_FLAG &&
+				oplus_sla_info[i].sla_avg_rtt >= rom_update_info.sla_rtt){
+
+				bad_count++;
+				if (MAIN_WLAN == i &&
+					SLA_MODE_DUAL_WIFI != sla_work_mode){
+					wlan_bad = true;
+				}
+				else if (WLAN_NUM == bad_count){
+					wlan_bad = true;
+				}
+			}
+		}
+
+		if (wlan_bad) {
+			send_show_dailog_msg = 1;
+			do_gettimeofday(&last_show_daillog_msg_tv);
+			oplus_sla_send_to_user(SLA_SHOW_DIALOG_NOW,NULL,0);
+			if(oplus_sla_debug){
+				printk("oplus_sla_netlink:show dailog now\n");
+			}
+		}
+
+	}
+	return;
+}
+
+static bool dual_wlan_enable_cell(void)
+{
+	int sum_speed = 0;
+	if (wlan_can_enable_cell(MAIN_WLAN) &&
+		wlan_can_enable_cell(SECOND_WLAN)) {
+		if (oplus_sla_enable) {
+			printk("oplus_sla_netlink:[0] dual sta enable cell\n");
+		}
+		return true;
+	}
+	else if (!init_weight_delay_count) {
+		sum_speed = oplus_sla_info[MAIN_WLAN].max_speed + oplus_sla_info[SECOND_WLAN].max_speed;
+		if (sum_speed <= rom_update_info.sla_speed &&
+			(oplus_sla_info[MAIN_WLAN].sla_avg_rtt >= rom_update_info.sla_rtt ||
+			  oplus_sla_info[SECOND_WLAN].sla_avg_rtt >= rom_update_info.sla_rtt)) {
+
+			if (oplus_sla_enable) {
+				printk("oplus_sla_netlink:[1] dual sta enable cell\n");
+			}
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static void sla_detect_should_enable(void)
+{
+	int active_type = 0;
+	if (sla_screen_on && CELL_INDEX != oplus_sla_def_net) {
+		if (dual_wifi_switch_enable &&
+			SLA_MODE_DUAL_WIFI == sla_detect_mode) {
+			if (!oplus_sla_enable) {
+				if (!enable_second_wifi_to_user) {
+					active_type = wlan_can_enable_second_wifi(MAIN_WLAN);
+					dual_wifi_active_type = active_type;
+					if (active_type) {
+						send_enable_to_framework(SLA_MODE_DUAL_WIFI,active_type);
+					}
+				}
+				else if (!enable_cell_to_user &&
+					sla_switch_enable &&
+					cell_quality_good &&
+					!rate_limit_info.rate_limit_enable &&
+					wlan_can_enable_cell(MAIN_WLAN)) {
+					send_enable_to_framework(SLA_MODE_WIFI_CELL,INIT_ACTIVE_TYPE);
+				}
+			}
+		}
+		else if(!enable_cell_to_user &&
+				sla_switch_enable &&
+				cell_quality_good &&
+				!rate_limit_info.rate_limit_enable &&
+				SLA_MODE_WIFI_CELL == sla_detect_mode) {
+
+			if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+				if (dual_wlan_enable_cell()) {
+					send_enable_to_framework(SLA_MODE_WIFI_CELL,INIT_ACTIVE_TYPE);
+				}
+			}else if (!oplus_sla_enable &&
+					   wlan_can_enable_cell(MAIN_WLAN)) {
+					send_enable_to_framework(SLA_MODE_WIFI_CELL,INIT_ACTIVE_TYPE);
+			}
+		}
+	}
+}
+
+static void calc_network_rtt(struct timeval tv)
+{
+
+	int index = 0;
+	int avg_rtt = 0;
+
+	sla_rtt_write_lock();
+	for(index = 0; index < IFACE_NUM; index++){
+		avg_rtt = 0;
+		if(oplus_sla_info[index].if_up || oplus_sla_info[index].need_up){
+
+			if(oplus_sla_info[index].rtt_index >= RTT_NUM){
+
+				avg_rtt = oplus_sla_info[index].sum_rtt / oplus_sla_info[index].rtt_index;
+				if(oplus_sla_info[index].download_flag >= DOWNLOAD_FLAG) {
+ 					avg_rtt = avg_rtt / 2;
+				}
+
+				oplus_sla_info[index].sla_rtt_num++;
+				oplus_sla_info[index].sla_sum_rtt += avg_rtt;
+				oplus_sla_info[index].avg_rtt = (7*oplus_sla_info[index].avg_rtt + avg_rtt) / 8;
+				oplus_sla_info[index].sum_rtt = 0;
+				oplus_sla_info[index].rtt_index = 0;
+			}
+
+			avg_rtt = oplus_sla_info[index].sla_avg_rtt;
+
+			if(oplus_sla_debug){
+				printk("oplus_sla_rtt: index = %d,wlan_rtt = %d,"
+					   "wlan score bad = %u,cell_good = %d,need_show_dailog = %d,sceen_on = %d,"
+					   "enable_cell_to_user = %d,enable_wifi_to_user = %d,sla_switch_enable = %d,oplus_sla_enable= %d,"
+					   "oplus_sla_def_net = %d,sla_avg_rtt = %d,detect_mode = %d,work_mode = %d,game_cell_to_wifi = %d\n",
+					   index,oplus_sla_info[index].avg_rtt,
+					   oplus_sla_info[index].wlan_score_bad_count,
+					   cell_quality_good,need_show_dailog,sla_screen_on,
+					   enable_cell_to_user,enable_second_wifi_to_user,sla_switch_enable,
+					   oplus_sla_enable,oplus_sla_def_net,avg_rtt,sla_detect_mode,sla_work_mode,game_cell_to_wifi);
+			}
+		}
+	}
+	sla_rtt_write_unlock();
+
+	return;
+
+}
+
+static void init_game_online_info(void)
+{
+	int i = 0;
+
+	game_cell_to_wifi = false;
+
+	sla_game_write_lock();
+	for(i = 1; i < GAME_NUM; i++){
+		game_uid[i].mark = MAIN_WLAN_MARK;
+		game_uid[i].switch_time = 0;
+	}
+	sla_game_write_unlock();
+	if(oplus_sla_debug){
+		printk("oplus_sla:init_game_online_info\n");
+	}
+	memset(&game_online_info,0x0,sizeof(struct oplus_game_online));
+}
+
+static void init_game_start_state(void)
+{
+    int i = 0;
+    for(i = 1; i < GAME_NUM; i++){
+        if(game_start_state[i]){
+            game_start_state[i] = 0;
+        }
+    }
+}
+
+static void game_rx_update(void)
+{
+	if (!oplus_sla_vpn_connected &&
+		game_online_info.game_online) {
+		struct game_traffic_info* cur_info;
+		int i;
+		u32 game_index = 0;
+		u32 tcp_rx_large_count = 0;
+		u32 delta_udp_pkts = game_online_info.udp_rx_pkt_count;
+		u64 delta_tcp_bytes = game_online_info.tcp_rx_byte_count;
+		game_online_info.udp_rx_pkt_count = 0;
+		game_online_info.tcp_rx_byte_count = 0;
+
+		if (wzry_traffic_info.game_in_front) {
+			cur_info = &wzry_traffic_info;
+			game_index = 1;
+		} else if (cjzc_traffic_info.game_in_front) {
+			cur_info = &cjzc_traffic_info;
+			game_index = 2;
+		} else {
+			//for debug only...
+			cur_info = &default_traffic_info;
+			cur_info->game_in_front = 0;
+		}
+		//fill in the latest delta udp rx packets and tcp rx bytes
+		cur_info->udp_rx_packet[cur_info->window_index % UDP_RX_WIN_SIZE] = delta_udp_pkts;
+		cur_info->tcp_rx_byte[cur_info->window_index % TCP_RX_WIN_SIZE] = delta_tcp_bytes;
+		cur_info->window_index++;
+		//deal with the control logic
+		if (udp_rx_show_toast) {
+			oplus_sla_send_to_user(SLA_NOTIFY_GAME_RX_PKT, (char *)&delta_udp_pkts, sizeof(delta_udp_pkts));
+		}
+
+		for (i = 0; i < TCP_RX_WIN_SIZE; i++) {
+			if (cur_info->tcp_rx_byte[i] > TCP_DOWNLOAD_THRESHOLD) {
+				tcp_rx_large_count++;
+			}
+		}
+		if (tcp_rx_large_count == TCP_RX_WIN_SIZE) {
+			if (oplus_sla_debug) {
+				//tcp downloading.. this should not be in a game.
+				if (oplus_sla_debug) {
+					printk("oplus_sla_game_rx_update:TCP downloading...should not be in a game.\n");
+				}
+			}
+			if (inGame) {
+				inGame = false;
+				game_cell_to_wifi = false;
+				memset(cur_info->udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+				cur_info->window_index = 0;
+			}
+		} else {
+			int trafficCount = 0;
+			int lowTrafficCount = 0;
+			for (i = 0; i < UDP_RX_WIN_SIZE; i++) {
+				if (cur_info->udp_rx_packet[i] >= cur_info->udp_rx_min) {
+					trafficCount++;
+					if (cur_info->udp_rx_packet[i] <= cur_info->udp_rx_low_thr) {
+						lowTrafficCount++;
+					}
+				}
+			}
+			if (trafficCount >= cur_info->in_game_true_thr) {
+				if (!inGame) {
+					int index;
+					inGame = true;
+					game_cell_to_wifi = false;
+					for (index = 0; index < UDP_RX_WIN_SIZE; index++) {
+						cur_info->udp_rx_packet[index] = 20;
+					}
+					lowTrafficCount = 0;
+				}
+			} else if (trafficCount <= cur_info->in_game_false_thr) {
+				if (inGame) {
+					inGame = false;
+					game_cell_to_wifi = false;
+					memset(cur_info->udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+					cur_info->window_index = 0;
+				}
+			}
+			if (inGame && cur_info->game_in_front) {
+				if (lowTrafficCount >= cur_info->rx_bad_thr &&
+					game_index > 0 && game_start_state[game_index]) {//wzry has low traffic when game ends
+					game_rx_bad = true;
+				} else {
+					game_rx_bad = false;
+				}
+			}
+			if (oplus_sla_debug) {
+				printk("oplus_sla_game_rx_update:delta_udp_pkts=%d, lowTrafficCount=%d, inGame=%d, "
+				        "game_rx_bad=%d, delta_tcp_bytes=%llu, tcp_rx_large_count=%d, trafficCount=%d\n",
+				        delta_udp_pkts, lowTrafficCount, inGame,
+				        game_rx_bad, delta_tcp_bytes, tcp_rx_large_count, trafficCount);
+			}
+		}
+	}
+}
+
+static void game_online_time_out(struct timeval tv)
+{
+	if(game_online_info.game_online &&
+	   (tv.tv_sec - game_online_info.last_game_skb_tv.tv_sec) >= GAME_SKB_TIME_OUT){
+		init_game_start_state();
+		init_game_online_info();
+	}
+}
+
+static void show_dailog_msg_time_out(struct timeval tv)
+{
+	int time_interval = 0;
+	int time_out = 30;
+	time_interval = tv.tv_sec - last_show_daillog_msg_tv.tv_sec;
+
+	if(time_interval >= time_out && send_show_dailog_msg){
+		send_show_dailog_msg = 0;
+	}
+}
+
+//add for rate limit function to statistics front uid rtt
+static void oplus_rate_limit_rtt_calc(struct timeval tv)
+{
+	int num = 0;
+	int sum = 0;
+	int time_interval = 0;
+
+	time_interval = tv.tv_sec - rate_limit_info.last_tv.tv_sec;
+	if(time_interval >= 10){
+		sla_rtt_write_lock();
+
+		if(rate_limit_info.disable_rtt_num >= 10){
+			num = rate_limit_info.disable_rtt_num;
+		    sum = rate_limit_info.disable_rtt_sum;
+			rate_limit_info.disable_rtt = sum / num;
+		}
+
+		if(rate_limit_info.enable_rtt_num >= 10){
+			num = rate_limit_info.enable_rtt_num;
+		    sum = rate_limit_info.enable_rtt_sum;
+			rate_limit_info.enable_rtt = sum / num;
+		}
+
+		rate_limit_info.disable_rtt_num = 0;
+		rate_limit_info.disable_rtt_sum = 0;
+		rate_limit_info.enable_rtt_num = 0;
+		rate_limit_info.enable_rtt_sum = 0;
+		rate_limit_info.last_tv = tv;
+
+		sla_rtt_write_unlock();
+	}
+}
+
+static void dns_statistic_timer(struct timeval tv)
+{
+	int i;
+
+	for (i = 0; i < IFACE_NUM; i++) {
+		if(dns_info[i].in_timer &&
+			(tv.tv_sec - dns_info[i].last_tv.tv_sec) >= DNS_TIME){
+
+			dns_info[i].send_num = 0;
+			dns_info[i].in_timer = false;
+			reset_invalid_network_info(&oplus_sla_info[i]);
+
+			sla_write_lock();
+			if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+				calc_weight_with_weight_state (MAIN_WLAN,SECOND_WLAN);
+			}
+			else if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+				calc_weight_with_weight_state (MAIN_WLAN,CELL_INDEX);
+			}
+			sla_write_unlock();
+
+			printk("oplus_sla_dns: detec dns[%d] error\n",i);
+		}
+	}
+	return;
+}
+
+static void oplus_sla_work_queue_func(struct work_struct *work)
+{
+	int time_interval;
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+
+	time_interval = tv.tv_sec - last_speed_tv.tv_sec;
+
+	if(time_interval >= CALC_DEV_SPEED_TIME){
+		last_speed_tv = tv;
+		calc_network_congestion();
+		statistic_dev_speed(tv,time_interval);
+		calc_network_rtt(tv);
+		sla_show_dailog();
+		sla_detect_should_enable();
+	}
+
+	if(oplus_sla_enable){
+		time_interval = tv.tv_sec - last_weight_tv.tv_sec;
+		if(time_interval >= RECALC_WEIGHT_TIME){
+			last_weight_tv = tv;
+
+			if (!init_weight_delay_count) {
+				recalc_sla_weight();
+			} else {
+				init_weight_delay_count--;
+			}
+		}
+	}
+
+    dns_statistic_timer(tv);
+	enable_to_user_time_out(tv);
+	up_wlan_iface_by_timer(tv);
+	game_online_time_out(tv);
+	game_rx_update();
+	show_dailog_msg_time_out(tv);
+	reset_oplus_sla_calc_speed(tv);
+	oplus_rate_limit_rtt_calc(tv);
+	send_speed_and_rtt_to_user();
+}
+
+static void oplus_sla_timer_function(void)
+{
+	if (workqueue_sla){
+		queue_work(workqueue_sla, &oplus_sla_work);
+	}
+	mod_timer(&sla_timer, jiffies + SLA_TIMER_EXPIRES);
+
+}
+
+/*
+	timer to statistic each dev speed,
+	start it when sla is enabled
+*/
+static void oplus_sla_timer_init(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0))
+	init_timer(&sla_timer);
+	sla_timer.function = (void*)oplus_sla_timer_function;
+#else
+	timer_setup(&sla_timer, (void*)oplus_sla_timer_function, 0);
+#endif
+
+	sla_timer.expires = jiffies +  SLA_TIMER_EXPIRES;// timer expires in ~1s
+	add_timer (&sla_timer);
+
+	do_gettimeofday(&last_speed_tv);
+	do_gettimeofday(&last_weight_tv);
+	do_gettimeofday(&last_minute_speed_tv);
+	do_gettimeofday(&last_download_speed_tv);
+	do_gettimeofday(&rate_limit_info.last_tv);
+}
+
+
+/*
+	timer to statistic each dev speed,
+	stop it when sla is disabled
+*/
+static void oplus_sla_timer_fini(void)
+{
+	del_timer(&sla_timer);
+}
+
+
+static struct nf_hook_ops oplus_sla_ops[] __read_mostly = {
+	{
+		.hook		= oplus_sla_output_hook,
+		.pf		    = NFPROTO_IPV4,
+		.hooknum	= NF_INET_LOCAL_OUT,
+		//must be here,for  dns packet will do DNAT at mangle table with skb->mark
+		.priority	= NF_IP_PRI_CONNTRACK + 1,
+	},
+	{
+		.hook		= oplus_sla_input_hook,
+		.pf		    = NFPROTO_IPV4,
+		.hooknum	= NF_INET_LOCAL_IN,
+		.priority	= NF_IP_PRI_FILTER + 1,
+	},
+};
+
+static struct ctl_table oplus_sla_sysctl_table[] = {
+	{
+		.procname	= "oplus_sla_enable",
+		.data		= &oplus_sla_enable,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "oplus_sla_debug",
+		.data		= &oplus_sla_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "oplus_sla_calc_speed",
+		.data		= &oplus_sla_calc_speed,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "oplus_sla_vpn_connected",
+		.data		= &oplus_sla_vpn_connected,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "game_mark",
+		.data		= &game_mark,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "disable_rtt",
+		.data		= &rate_limit_info.disable_rtt,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "enable_rtt",
+		.data		= &rate_limit_info.enable_rtt,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "udp_rx_show_toast",
+		.data		= &udp_rx_show_toast,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "game_rtt_show_toast",
+		.data		= &game_rtt_show_toast,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "tee_use_src",
+		.data		= &tee_use_src,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{ }
+};
+
+static int oplus_sla_sysctl_init(void)
+{
+	oplus_sla_table_hrd = register_net_sysctl(&init_net, "net/oplus_sla",
+		                                          oplus_sla_sysctl_table);
+	return oplus_sla_table_hrd == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_sla_send_white_list_app_traffic(void)
+{
+    char *p = NULL;
+    char send_msg[1284];
+
+    memset(send_msg,0x0,sizeof(send_msg));
+
+    p = send_msg;
+    memcpy(p,&white_app_list.count,sizeof(u32));
+
+    p += sizeof(u32);
+    memcpy(p,white_app_list.uid,WHITE_APP_NUM*sizeof(u32));
+
+    p += WHITE_APP_NUM*sizeof(u32);
+    memcpy(p,white_app_list.cell_bytes,WHITE_APP_NUM*sizeof(u64));
+
+	p += WHITE_APP_NUM*sizeof(u64);
+		memcpy(p,white_app_list.cell_bytes_normal,WHITE_APP_NUM*sizeof(u64));
+
+	oplus_sla_send_to_user(SLA_SEND_WHITE_LIST_APP_TRAFFIC,
+		     send_msg,sizeof(send_msg));
+
+	return;
+}
+
+static int oplus_sla_set_debug(struct nlmsghdr *nlh)
+{
+	oplus_sla_debug = *(u32 *)NLMSG_DATA(nlh);
+	printk("oplus_sla_netlink:set debug = %d\n", oplus_sla_debug);
+	return	0;
+}
+
+static int oplus_sla_set_default_network(struct nlmsghdr *nlh)
+{
+	oplus_sla_def_net = *(u32 *)NLMSG_DATA(nlh);
+	printk("oplus_sla_netlink:set default network = %d\n", oplus_sla_def_net);
+
+        /* reset game udp rx data */
+        memset(wzry_traffic_info.udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+        wzry_traffic_info.window_index = 0;
+        memset(cjzc_traffic_info.udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+        cjzc_traffic_info.window_index = 0;
+
+	return	0;
+}
+
+static void oplus_sla_send_game_app_traffic(void)
+{
+	oplus_sla_send_to_user(SLA_SEND_GAME_APP_STATISTIC,
+		     (char *)game_uid,GAME_NUM*sizeof(struct oplus_sla_game_info));
+
+	return;
+}
+
+static void oplus_sla_send_syn_retran_info(void)
+{
+	oplus_sla_send_to_user(SLA_GET_SYN_RETRAN_INFO,
+		     (char *)&syn_retran_statistic,sizeof(struct oplus_syn_retran_statistic));
+
+	memset(&syn_retran_statistic,0x0,sizeof(struct oplus_syn_retran_statistic));
+	return;
+}
+
+static int disable_oplus_sla_module(struct nlmsghdr *nlh)
+{
+	int disable_type = 0;
+
+	int *data = (int *)NLMSG_DATA(nlh);
+	disable_type = data[0];
+	printk("oplus_sla_netlink: type[%d] disable,oplus_sla_enable[%d],work_mode[%d]\n",
+		disable_type,oplus_sla_enable,sla_work_mode);
+
+	sla_write_lock();
+	if(oplus_sla_enable && disable_type){
+		if (SLA_MODE_DUAL_WIFI == disable_type) {
+			main_wlan_download = 1;
+			enable_second_wifi_to_user = false;
+			dual_wifi_active_type = INIT_ACTIVE_TYPE;
+		}
+		else if (SLA_MODE_WIFI_CELL == disable_type) {
+			enable_cell_to_user = false;
+		}
+
+		if (disable_type == sla_work_mode) {
+			oplus_sla_enable = 0;
+			sla_work_mode = SLA_MODE_INIT;
+
+			if (dual_wifi_switch_enable) {
+				sla_detect_mode = SLA_MODE_DUAL_WIFI;
+			} else {
+				sla_detect_mode = SLA_MODE_WIFI_CELL;
+			}
+
+			init_game_online_info();
+			printk("oplus_sla_netlink: type[%d] disabled\n",disable_type);
+		}
+		oplus_sla_send_to_user(SLA_DISABLED, (char *)&disable_type, sizeof(int));
+    }
+	sla_write_unlock();
+	return 0;
+}
+
+static int oplus_sla_iface_changed(struct nlmsghdr *nlh)
+{
+	int index = -1;
+	int up = 0;
+	char *p;
+	struct oplus_dev_info *node = NULL;
+	u32 mark = 0x0;
+
+	int *data = (int *)NLMSG_DATA(nlh);
+	index = data[0];
+	up = data[1];
+	p = (char *)(data + 2);
+	printk("oplus_sla_netlink:oplus_sla_iface_changed index:%d, up:%d, ifname:%s\n", index, up, p);
+
+	if (index >= 0 && index < IFACE_NUM) {
+		struct timeval tv;
+		do_gettimeofday(&tv);
+
+		if (up) {
+			sla_write_lock();
+			oplus_sla_info[index].if_up = 0;
+
+			if (index == MAIN_WLAN || index == SECOND_WLAN) {
+				if (index == MAIN_WLAN) {
+					mark = MAIN_WLAN_MARK;
+					oplus_sla_info[MAIN_WLAN].need_up = true;
+				} else {
+					mark = SECOND_WLAN_MARK;
+					oplus_sla_info[SECOND_WLAN].if_up = 1;
+				}
+
+				last_speed_tv = tv;
+				last_weight_tv = tv;
+				last_minute_speed_tv = tv;
+				calc_wlan_rtt_tv = tv;
+				last_download_speed_tv = tv;
+				oplus_sla_info[CELL_INDEX].max_speed = 0;
+				oplus_sla_info[index].dl_little_speed = DOWNLOAD_SPEED;
+			} else if (index == CELL_INDEX) {
+				mark = CELL_MARK;
+				oplus_sla_info[CELL_INDEX].if_up = 1;
+				oplus_sla_info[CELL_INDEX].wlan_score = WLAN_SCORE_GOOD;
+			}
+			if(p) {
+				node = &oplus_sla_info[index];
+				node->mark = mark;
+				node->minute_speed = MINUTE_LITTE_RATE;
+				memcpy(node->dev_name, p, IFACE_LEN);
+				printk("oplus_sla_netlink:ifname = %s,ifup = %d\n", node->dev_name, node->if_up);
+			}
+			sla_write_unlock();
+        } else {
+			if (index == MAIN_WLAN || index == SECOND_WLAN) {
+				oplus_sla_calc_speed = 0;
+				enable_second_wifi_to_user = false;
+
+				if (index == MAIN_WLAN) {
+					enable_cell_to_user = false;
+					oplus_sla_send_game_app_traffic();
+					memset(game_uid, 0x0, GAME_NUM*sizeof(struct oplus_sla_game_info));
+				}
+			}
+
+			sla_write_lock();
+			memset(&dns_info[index], 0x0, sizeof(struct sla_dns_statistic));
+			memset(&oplus_speed_info[index], 0x0, sizeof(struct oplus_speed_calc));
+			memset(&oplus_sla_info[index], 0x0, sizeof(struct oplus_dev_info));
+			sla_write_unlock();
+        }
+	}
+
+	return 0;
+}
+
+static int oplus_sla_set_primary_wifi(struct nlmsghdr *nlh)
+{
+
+	int *data = (int *)NLMSG_DATA(nlh);
+	if (*data == WLAN0_INDEX || *data == WLAN1_INDEX) {
+		MAIN_WLAN = *data;
+		SECOND_WLAN = (WLAN0_INDEX == MAIN_WLAN) ? WLAN1_INDEX : WLAN0_INDEX;
+		if (WLAN0_INDEX == MAIN_WLAN) {
+			MAIN_WLAN_MARK = WLAN0_MARK;
+			SECOND_WLAN_MARK = WLAN1_MARK;
+		}else {
+			MAIN_WLAN_MARK = WLAN1_MARK;
+			SECOND_WLAN_MARK = WLAN0_MARK;
+		}
+		printk("oplus_sla_netlink: oplus_sla_set_primary_wifi main_wlan[%d],second_wlan[%d]\n",
+				MAIN_WLAN,SECOND_WLAN);
+	} else {
+		printk("oplus_sla_netlink: oplus_sla_set_primary_wifi invalid index = %d\n", *data);
+	}
+
+	return	0;
+}
+
+static int oplus_sla_get_pid(struct sk_buff *skb,struct nlmsghdr *nlh)
+{
+	oplus_sla_pid = NETLINK_CB(skb).portid;
+	printk("oplus_sla_netlink:get oplus_sla_pid = %u\n", oplus_sla_pid);
+
+	return 0;
+}
+
+static void set_weight_state_by_score(int index,int score)
+{
+	if (index >= 0 &&
+		index < IFACE_NUM) {
+		if (WLAN_NETWORK_INVALID == score &&
+			WEIGHT_STATE_SCORE_INVALID != oplus_sla_info[index].weight_state) {
+			printk("oplus_sla_score: network[%d] invalid\n",index);
+			reset_invalid_network_info(&oplus_sla_info[index]);
+			oplus_sla_info[index].weight_state = WEIGHT_STATE_SCORE_INVALID;
+
+			sla_write_lock();
+			if (SLA_MODE_DUAL_WIFI == sla_work_mode) {
+				calc_weight_with_weight_state (MAIN_WLAN,SECOND_WLAN);
+			}
+			else if (SLA_MODE_WIFI_CELL == sla_work_mode) {
+				calc_weight_with_weight_state (MAIN_WLAN,CELL_INDEX);
+			}
+			sla_write_unlock();
+
+		} else if (!oplus_sla_info[index].wlan_score_bad_count &&
+				WEIGHT_STATE_SCORE_INVALID == oplus_sla_info[index].weight_state) {
+			printk("oplus_sla_score: network[%d] reset to normal\n",index);
+			oplus_sla_info[index].weight_state = WEIGHT_STATE_NORMAL;
+		}
+	}
+
+	return;
+}
+
+static int oplus_sla_set_wifi_score(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+
+	if(NULL != data &&
+		data[0] >= 0 && data[0] < IFACE_NUM) {
+
+		int index = data[0];
+		int score = data[1];
+
+		set_weight_state_by_score(index,score);
+
+		oplus_sla_info[index].wlan_score = score;
+
+		if(score <= (rom_update_info.wlan_bad_score - 5)) {
+			oplus_sla_info[index].wlan_score_bad_count += WLAN_SCORE_BAD_NUM;
+		}
+		else if(score <= rom_update_info.wlan_bad_score){
+			oplus_sla_info[index].wlan_score_bad_count += 3;
+		}
+		else if(score >= rom_update_info.wlan_good_score){
+			oplus_sla_info[index].wlan_score_bad_count = 0;
+		}
+		else if(score >= (rom_update_info.wlan_good_score - 5) &&
+			oplus_sla_info[index].wlan_score_bad_count >= 3){
+			oplus_sla_info[index].wlan_score_bad_count -= 3;
+		}
+		else if(score >= (rom_update_info.wlan_good_score - 10) &&
+				oplus_sla_info[index].wlan_score_bad_count){
+			oplus_sla_info[index].wlan_score_bad_count--;
+		}
+
+		if(oplus_sla_info[index].wlan_score_bad_count > (2*WLAN_SCORE_BAD_NUM)){
+			oplus_sla_info[index].wlan_score_bad_count = 2*WLAN_SCORE_BAD_NUM;
+		}
+	} else {
+	        printk("oplus_sla_netlink:oplus_sla_set_wifi_score invalid message!\n");
+	}
+
+	return 0;
+}
+
+static int oplus_sla_set_game_app_uid(struct nlmsghdr *nlh)
+{
+	u32 *uidInfo = (u32 *)NLMSG_DATA(nlh);
+	u32 index = uidInfo[0];
+	u32 uid = uidInfo[1];
+
+	if (index < GAME_NUM) {
+	    game_uid[index].uid = uid;
+		game_uid[index].switch_time = 0;
+		game_uid[index].game_type = index;
+		game_uid[index].mark = MAIN_WLAN_MARK;
+	    printk("oplus_sla_netlink oplus_sla_set_game_app_uid:index=%d uid=%d\n", index, uid);
+	}
+
+	return 0;
+}
+
+static int oplus_sla_set_white_list_app_uid(struct nlmsghdr *nlh)
+{
+    u32 *info = (u32 *)NLMSG_DATA(nlh);
+	memset(&white_app_list,0x0,sizeof(struct oplus_white_app_info));
+    white_app_list.count = info[0];
+    if (white_app_list.count > 0 && white_app_list.count < WHITE_APP_NUM) {
+        int i;
+        for (i = 0; i < white_app_list.count; i++) {
+            white_app_list.uid[i] = info[i + 1];
+            printk("oplus_sla_netlink oplus_sla_set_white_list_app_uid count=%d, uid[%d]=%d\n",
+                    white_app_list.count, i, white_app_list.uid[i]);
+        }
+    }
+	return 0;
+}
+
+static int oplus_sla_set_game_rtt_detecting(struct nlmsghdr *nlh)
+{
+    if(SLA_ENABLE_GAME_RTT== nlh->nlmsg_type){
+        oplus_sla_vpn_connected = 1;
+    } else {
+        oplus_sla_vpn_connected = 0;
+    }
+	printk("oplus_sla_netlink: set game rtt detect:%d\n",nlh->nlmsg_type);
+	return 0;
+}
+
+static int oplus_sla_set_switch_state(struct nlmsghdr *nlh)
+{
+	u32 *data = (u32 *)NLMSG_DATA(nlh);
+
+	if (data[0]) {
+		sla_switch_enable = true;
+	} else {
+		sla_switch_enable = false;
+	}
+
+	if (data[1]) {
+		dual_wifi_switch_enable = true;
+		if (SLA_MODE_INIT == sla_work_mode) {
+			sla_detect_mode = SLA_MODE_DUAL_WIFI;
+		}
+	}
+	else {
+		dual_wifi_switch_enable = false;
+		if (SLA_MODE_INIT == sla_work_mode) {
+			sla_detect_mode = SLA_MODE_WIFI_CELL;
+		}
+	}
+	printk("oplus_sla_netlink:sla switch sla_enable = %d,dual_wifi_enable = %d\n",
+			sla_switch_enable, dual_wifi_switch_enable);
+	return 0;
+}
+
+static int oplus_sla_update_screen_state(struct nlmsghdr *nlh)
+{
+	u32 *screen_state = (u32 *)NLMSG_DATA(nlh);
+	sla_screen_on =	(*screen_state)	? true : false;
+	printk("oplus_sla_netlink:update screen state = %u\n",sla_screen_on);
+	return	0;
+}
+
+static int oplus_sla_update_cell_quality(struct nlmsghdr *nlh)
+{
+	u32 *cell_quality = (u32 *)NLMSG_DATA(nlh);
+	cell_quality_good =	(*cell_quality)	? true : false;
+	printk("oplus_sla_netlink:update cell quality = %u\n", cell_quality_good);
+	return	0;
+}
+
+static int oplus_sla_set_show_dialog_state(struct nlmsghdr *nlh)
+{
+	u32 *show_dailog = (u32 *)NLMSG_DATA(nlh);
+	need_show_dailog = (*show_dailog) ? true : false;
+	if (!need_show_dailog) {
+		send_show_dailog_msg = 0;
+	}
+	printk("oplus_sla_netlink:set show dialog = %u\n", need_show_dailog);
+	return	0;
+}
+
+static int oplus_sla_set_params(struct nlmsghdr *nlh)
+{
+	u32* params = (u32 *)NLMSG_DATA(nlh);
+	u32 count = params[0];
+	params++;
+	if (count == 13) {
+		rom_update_info.sla_speed = params[0];
+		rom_update_info.cell_speed = params[1];
+		rom_update_info.wlan_speed = params[2];
+		rom_update_info.wlan_little_score_speed = params[3];
+		rom_update_info.sla_rtt = params[4];
+		rom_update_info.wzry_rtt = params[5];
+		rom_update_info.cjzc_rtt = params[6];
+		rom_update_info.wlan_bad_score = params[7];
+		rom_update_info.wlan_good_score = params[8];
+		rom_update_info.second_wlan_speed = params[9];
+		rom_update_info.dual_wlan_download_speed = params[10];
+		rom_update_info.dual_wifi_rtt = params[11];
+		rom_update_info.dual_wlan_bad_score = params[12];
+		printk("oplus_sla_netlink:set params count=%u params[0] = %u,params[1] = %u,"
+				"params[2] = %u,params[3] = %u,params[4] = %u,params[5] = %u,params[6] = %u,"
+				"params[7] = %u,params[8] = %u,params[9] = %u,params[10] = %u,params[11] = %u,params[12] = %u\n",
+			    count, params[0],params[1],params[2],params[3],params[4],params[5],
+			    params[6],params[7],params[8],params[9],params[10],params[11],params[12]);
+	} else {
+		printk("oplus_sla_netlink:set params invalid param count:%d", count);
+	}
+
+	return	0;
+}
+
+static int oplus_sla_set_game_start_state(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+	int index = data[0];
+
+	game_cell_to_wifi = false;
+
+	if(index && index < GAME_NUM){
+		game_start_state[index] = data[1];
+		printk("oplus_sla_netlink:set game_start_state[%d] = %d\n",index,game_start_state[index]);
+		/* reset udp rx data */
+		memset(wzry_traffic_info.udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+                wzry_traffic_info.window_index = 0;
+                memset(cjzc_traffic_info.udp_rx_packet, 0x0, sizeof(u32)*UDP_RX_WIN_SIZE);
+                cjzc_traffic_info.window_index = 0;
+	} else {
+		printk("oplus_sla_netlink: set game_start_state error,index = %d\n",index);
+	}
+
+	return	0;
+}
+
+static int oplus_sla_set_game_rtt_params(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+	int index = data[0];
+	int i;
+
+	if(index > 0 && index < GAME_NUM) {
+		memcpy(&game_params[index], data, sizeof(struct oplus_sla_game_rtt_params));
+		printk("oplus_sla_netlink:set game params index=%d tx_offset=%d tx_len=%d tx_fix=",
+		        game_params[index].game_index, game_params[index].tx_offset, game_params[index].tx_len);
+		for (i = 0; i < game_params[index].tx_len; i++) {
+			printk("%02x", game_params[index].tx_fixed_value[i]);
+		}
+		printk(" rx_offset=%d rx_len=%d rx_fix=", game_params[index].rx_offset, game_params[index].rx_len);
+		for (i = 0; i < game_params[index].rx_len; i++) {
+			printk("%02x", game_params[index].rx_fixed_value[i]);
+		}
+		printk("\n");
+	} else {
+		printk("oplus_sla_netlink: set game params error,index = %d\n", index);
+	}
+
+	return	0;
+}
+
+static int oplus_sla_set_game_in_front(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+	int index = data[0];
+	int in_front = data[1];
+
+	if(index > 0 && index < GAME_NUM) {
+		if (index == GAME_WZRY) {
+			if (in_front) {
+				wzry_traffic_info.game_in_front = 1;
+				cjzc_traffic_info.game_in_front = 0;
+			} else {
+				wzry_traffic_info.game_in_front = 0;
+			}
+			printk("oplus_sla_netlink: set_game_in_front game index = %d, in_front=%d\n", index, in_front);
+		} else if (index == GAME_CJZC) {
+			if (in_front) {
+				wzry_traffic_info.game_in_front = 0;
+				cjzc_traffic_info.game_in_front = 1;
+			} else {
+				cjzc_traffic_info.game_in_front = 0;
+			}
+			printk("oplus_sla_netlink: set_game_in_front game index = %d, in_front=%d\n", index, in_front);
+		} else {
+			printk("oplus_sla_netlink: set_game_in_front unknow game, index = %d\n", index);
+		}
+	} else {
+		printk("oplus_sla_netlink: set_game_in_front error, index = %d\n", index);
+	}
+
+	return	0;
+}
+
+static int oplus_sla_set_dual_wifi_app_uid(struct nlmsghdr *nlh)
+{
+    u32 *info = (u32 *)NLMSG_DATA(nlh);
+	memset(&dual_wifi_app_list,0x0,sizeof(struct oplus_dual_sta_info));
+    dual_wifi_app_list.count = info[0];
+    if (dual_wifi_app_list.count > 0 && dual_wifi_app_list.count < DUAL_STA_APP_NUM) {
+        int i;
+        for (i = 0; i < dual_wifi_app_list.count; i++) {
+            dual_wifi_app_list.uid[i] = info[i + 1];
+            printk("oplus_sla_netlink:set_dual_wifi_app_uid count=%d, uid[%d]=%d\n",
+                    dual_wifi_app_list.count, i, dual_wifi_app_list.uid[i]);
+        }
+    }
+	return 0;
+}
+
+static int oplus_sla_set_download_app_uid(struct nlmsghdr *nlh)
+{
+    u32 *info = (u32 *)NLMSG_DATA(nlh);
+    memset(&download_app_list,0x0,sizeof(struct oplus_dual_sta_info));
+    download_app_list.count = info[0];
+    if (download_app_list.count > 0 && download_app_list.count < DUAL_STA_APP_NUM) {
+        int i;
+        for (i = 0; i < download_app_list.count; i++) {
+            download_app_list.uid[i] = info[i + 1];
+            printk("oplus_sla_netlink:set_download_app_uid count=%d, uid[%d]=%d\n",
+                    download_app_list.count, i, download_app_list.uid[i]);
+        }
+    }
+	return 0;
+}
+
+static int oplus_sla_set_vedio_app_uid(struct nlmsghdr *nlh)
+{
+    u32 *info = (u32 *)NLMSG_DATA(nlh);
+    memset(&vedio_app_list,0x0,sizeof(struct oplus_dual_sta_info));
+    vedio_app_list.count = info[0];
+    if (vedio_app_list.count > 0 && vedio_app_list.count < DUAL_STA_APP_NUM) {
+        int i;
+        for (i = 0; i < vedio_app_list.count; i++) {
+            vedio_app_list.uid[i] = info[i + 1];
+            printk("oplus_sla_netlink:vedio_app_list count=%d, uid[%d]=%d\n",
+                    vedio_app_list.count, i, vedio_app_list.uid[i]);
+        }
+    }
+	return 0;
+}
+
+static void oplus_sla_set_vpn_state(struct nlmsghdr *nlh)
+{
+	int *data = (int *)NLMSG_DATA(nlh);
+
+	/*1 ---> vpn connected
+	 *0 ---> vpn disconnected*/
+	oplus_sla_vpn_connected = data[0];
+
+	printk("oplus_sla_netlink:set vpn connecet state = %d\n", data[0]);
+}
+
+static void reset_main_wlan_info(void)
+{
+	struct timeval tv;
+
+	if(oplus_sla_info[MAIN_WLAN].if_up){
+
+		do_gettimeofday(&tv);
+		last_minute_speed_tv = tv;
+
+		oplus_sla_info[MAIN_WLAN].sum_rtt= 0;
+		oplus_sla_info[MAIN_WLAN].avg_rtt = 0;
+		oplus_sla_info[MAIN_WLAN].rtt_index = 0;
+		oplus_sla_info[MAIN_WLAN].sla_avg_rtt = 0;
+		oplus_sla_info[MAIN_WLAN].sla_rtt_num = 0;
+		oplus_sla_info[MAIN_WLAN].sla_sum_rtt = 0;
+		oplus_sla_info[MAIN_WLAN].syn_retran = 0;
+		oplus_sla_info[MAIN_WLAN].max_speed /= 2;
+		oplus_sla_info[MAIN_WLAN].left_speed = 0;
+		oplus_sla_info[MAIN_WLAN].current_speed = 0;
+		oplus_sla_info[MAIN_WLAN].minute_speed = MINUTE_LITTE_RATE;
+		oplus_sla_info[MAIN_WLAN].congestion_flag = CONGESTION_LEVEL_NORMAL;
+	}
+}
+
+static void oplus_sla_init_weight_by_wlan_assi(void)
+{
+	struct timeval tv;
+	do_gettimeofday(&tv);
+
+	sla_write_lock();
+	init_weight_delay_count = 10;
+
+	last_weight_tv = tv;
+	oplus_sla_info[MAIN_WLAN].weight = 30;
+	oplus_sla_info[CELL_INDEX].weight = 100;
+
+	reset_main_wlan_info();
+
+	printk("oplus_sla_weight:init_weight_by_wlan_assi[%d] [%d]\n",
+		oplus_sla_info[MAIN_WLAN].weight, oplus_sla_info[CELL_INDEX].weight);
+	sla_write_unlock();
+}
+
+static int sla_netlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack)
+{
+	int ret = 0;
+
+	switch (nlh->nlmsg_type) {
+	case SLA_ENABLE:
+		ret = enable_oplus_sla_module(nlh);
+		break;
+	case SLA_DISABLE:
+		ret = disable_oplus_sla_module(nlh);
+		break;
+	case SLA_IFACE_CHANGED:
+		ret = oplus_sla_iface_changed(nlh);
+		break;
+	case SLA_NOTIFY_PRIMARY_WIFI:
+		ret = oplus_sla_set_primary_wifi(nlh);
+		break;
+	case SLA_NOTIFY_PID:
+		ret = oplus_sla_get_pid(skb,nlh);
+		break;
+	case SLA_NOTIFY_WIFI_SCORE:
+		ret = oplus_sla_set_wifi_score(nlh);
+		break;
+	case SLA_NOTIFY_APP_UID:
+	    ret = oplus_sla_set_game_app_uid(nlh);
+	    break;
+	case SLA_NOTIFY_WHITE_LIST_APP:
+		oplus_sla_send_white_list_app_traffic();
+	    ret = oplus_sla_set_white_list_app_uid(nlh);
+	    break;
+	case SLA_ENABLE_GAME_RTT:
+	case SLA_DISABLE_GAME_RTT:
+	    ret = oplus_sla_set_game_rtt_detecting(nlh);
+	    break;
+	case SLA_NOTIFY_SWITCH_STATE:
+		ret = oplus_sla_set_switch_state(nlh);
+		break;
+	case SLA_NOTIFY_SCREEN_STATE:
+		ret = oplus_sla_update_screen_state(nlh);
+		break;
+	case SLA_NOTIFY_CELL_QUALITY:
+		ret = oplus_sla_update_cell_quality(nlh);
+		break;
+	case SLA_NOTIFY_SHOW_DIALOG:
+		ret = oplus_sla_set_show_dialog_state(nlh);
+		break;
+	case SLA_GET_SYN_RETRAN_INFO:
+		oplus_sla_send_syn_retran_info();
+		break;
+	case SLA_GET_SPEED_UP_APP:
+		oplus_sla_send_white_list_app_traffic();
+		break;
+	case SLA_SET_DEBUG:
+		oplus_sla_set_debug(nlh);
+		break;
+	case SLA_NOTIFY_DEFAULT_NETWORK:
+		oplus_sla_set_default_network(nlh);
+		break;
+	case SLA_NOTIFY_PARAMS:
+		oplus_sla_set_params(nlh);
+		break;
+	case SLA_NOTIFY_GAME_STATE:
+		oplus_sla_set_game_start_state(nlh);
+		break;
+	case SLA_NOTIFY_GAME_PARAMS:
+		oplus_sla_set_game_rtt_params(nlh);
+		break;
+	case SLA_NOTIFY_GAME_IN_FRONT:
+		oplus_sla_set_game_in_front(nlh);
+		break;
+	case SLA_NOTIFY_DUAL_STA_APP:
+		oplus_sla_set_dual_wifi_app_uid(nlh);
+		break;
+	case SLA_WEIGHT_BY_WLAN_ASSIST:
+		oplus_sla_init_weight_by_wlan_assi();
+		break;
+	case SLA_NOTIFY_VPN_CONNECTED:
+		oplus_sla_set_vpn_state(nlh);
+		break;
+	case SLA_NOTIFY_DOWNLOAD_APP:
+		oplus_sla_set_download_app_uid(nlh);
+		break;
+	case SLA_NOTIFY_VEDIO_APP:
+		oplus_sla_set_vedio_app_uid(nlh);
+		break;
+	case SLA_LIMIT_SPEED_ENABLE:
+		enable_oplus_limit_speed();
+		break;
+	case SLA_LIMIT_SPEED_DISABLE:
+		disable_oplus_limit_speed();
+		break;
+	case SLA_LIMIT_SPEED_FRONT_UID:
+		oplus_limit_uid_changed(nlh);
+		break;
+	case SMART_BW_SET_PARAMS:
+		oplus_smart_bw_set_params(nlh);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+static void sla_netlink_rcv(struct sk_buff *skb)
+{
+	mutex_lock(&sla_netlink_mutex);
+	netlink_rcv_skb(skb, &sla_netlink_rcv_msg);
+	mutex_unlock(&sla_netlink_mutex);
+}
+
+static int oplus_sla_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input	= sla_netlink_rcv,
+	};
+
+	oplus_sla_sock = netlink_kernel_create(&init_net, NETLINK_OPLUS_SLA, &cfg);
+	return oplus_sla_sock == NULL ? -ENOMEM : 0;
+}
+
+static void oplus_sla_netlink_exit(void)
+{
+	netlink_kernel_release(oplus_sla_sock);
+	oplus_sla_sock = NULL;
+}
+
+static int __init oplus_sla_init(void)
+{
+	int ret = 0;
+
+	rwlock_init(&sla_lock);
+	rwlock_init(&sla_rtt_lock);
+	rwlock_init(&sla_game_lock);
+
+	ret = oplus_sla_netlink_init();
+	if (ret < 0) {
+		printk("oplus_sla module can not init oplus sla netlink.\n");
+	}
+
+	ret |= oplus_sla_sysctl_init();
+
+	ret |= nf_register_net_hooks(&init_net,oplus_sla_ops,ARRAY_SIZE(oplus_sla_ops));
+	if (ret < 0) {
+		printk("oplus_sla module can not register netfilter ops.\n");
+	}
+
+	workqueue_sla= create_singlethread_workqueue("workqueue_sla");
+	if (workqueue_sla) {
+		INIT_WORK(&oplus_sla_work, oplus_sla_work_queue_func);
+	}
+	else {
+		printk("oplus_sla module can not create workqueue_sla\n");
+	}
+
+	oplus_sla_timer_init();
+	statistic_dev_rtt = oplus_statistic_dev_rtt;
+	mark_streams_for_iptables_reject = sla_mark_streams_for_iptables_reject;
+
+	return ret;
+}
+
+
+static void __exit oplus_sla_fini(void)
+{
+	oplus_sla_timer_fini();
+	statistic_dev_rtt = NULL;
+	mark_streams_for_iptables_reject = NULL;
+
+	if (workqueue_sla) {
+		flush_workqueue(workqueue_sla);
+		destroy_workqueue(workqueue_sla);
+	}
+
+	oplus_sla_netlink_exit();
+
+	if(oplus_sla_table_hrd){
+		unregister_net_sysctl_table(oplus_sla_table_hrd);
+	}
+
+	nf_unregister_net_hooks(&init_net,oplus_sla_ops, ARRAY_SIZE(oplus_sla_ops));
+}
+
+
+module_init(oplus_sla_init);
+module_exit(oplus_sla_fini);
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
old mode 100644
new mode 100755
index bf6fcba..ae1fd9c
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -241,6 +241,11 @@ struct packet_skb_cb {
 static void __fanout_unlink(struct sock *sk, struct packet_sock *po);
 static void __fanout_link(struct sock *sk, struct packet_sock *po);
 
+//#ifdef OPLUS_FEATURE_DHCP
+
+int (*handle_dhcp)(struct sock *sk, struct sk_buff *skb, struct net_device *dev, struct packet_type *pt) = NULL;
+EXPORT_SYMBOL(handle_dhcp);
+//#endif /* OPLUS_FEATURE_DHCP */
 static int packet_direct_xmit(struct sk_buff *skb)
 {
 	return dev_direct_xmit(skb, packet_pick_tx_queue(skb));
@@ -2121,6 +2126,14 @@ static int packet_rcv(struct sk_buff *skb, struct net_device *dev,
 	/* drop conntrack reference */
 	nf_reset(skb);
 
+//#ifdef OPLUS_FEATURE_DHCP
+
+    if (handle_dhcp != NULL && handle_dhcp(sk, skb, dev, pt)) {
+        printk("drop dhcp offer packet");
+        goto drop;
+    }
+//#endif /* OPLUS_FEATURE_DHCP */
+
 	spin_lock(&sk->sk_receive_queue.lock);
 	po->stats.stats1.tp_packets++;
 	sock_skb_set_dropcount(sk, skb);
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
old mode 100644
new mode 100755
index 8a4d01e..ba00ab3
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -292,6 +292,17 @@ static struct sk_buff *dequeue_skb(struct Qdisc *q, bool *validate,
 	return skb;
 }
 
+#ifdef OPLUS_FEATURE_WIFI_LIMMITBGSPEED
+
+struct sk_buff *qdisc_dequeue_skb(struct Qdisc *q, bool *validate)
+{
+	int packets;
+
+	return dequeue_skb(q, validate, &packets);
+}
+EXPORT_SYMBOL(qdisc_dequeue_skb);
+#endif /* OPLUS_FEATURE_WIFI_LIMMITBGSPEED */
+
 /*
  * Transmit possibly several skbs, and handle the return status as
  * required. Owning running seqcount bit guarantees that
